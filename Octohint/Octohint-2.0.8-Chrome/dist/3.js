(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{191:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es5" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n'},192:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/////////////////////////////\n/// DOM APIs\n/////////////////////////////\n\ninterface Account {\n    displayName: string;\n    id: string;\n    imageURL?: string;\n    name?: string;\n    rpDisplayName: string;\n}\n\ninterface AddEventListenerOptions extends EventListenerOptions {\n    once?: boolean;\n    passive?: boolean;\n}\n\ninterface AesCbcParams extends Algorithm {\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface AesCtrParams extends Algorithm {\n    counter: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    length: number;\n}\n\ninterface AesDerivedKeyParams extends Algorithm {\n    length: number;\n}\n\ninterface AesGcmParams extends Algorithm {\n    additionalData?: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    tagLength?: number;\n}\n\ninterface AesKeyAlgorithm extends KeyAlgorithm {\n    length: number;\n}\n\ninterface AesKeyGenParams extends Algorithm {\n    length: number;\n}\n\ninterface Algorithm {\n    name: string;\n}\n\ninterface AnalyserOptions extends AudioNodeOptions {\n    fftSize?: number;\n    maxDecibels?: number;\n    minDecibels?: number;\n    smoothingTimeConstant?: number;\n}\n\ninterface AnimationEventInit extends EventInit {\n    animationName?: string;\n    elapsedTime?: number;\n    pseudoElement?: string;\n}\n\ninterface AnimationPlaybackEventInit extends EventInit {\n    currentTime?: number | null;\n    timelineTime?: number | null;\n}\n\ninterface AssertionOptions {\n    allowList?: ScopedCredentialDescriptor[];\n    extensions?: WebAuthnExtensions;\n    rpId?: string;\n    timeoutSeconds?: number;\n}\n\ninterface AssignedNodesOptions {\n    flatten?: boolean;\n}\n\ninterface AudioBufferOptions {\n    length: number;\n    numberOfChannels?: number;\n    sampleRate: number;\n}\n\ninterface AudioBufferSourceOptions {\n    buffer?: AudioBuffer | null;\n    detune?: number;\n    loop?: boolean;\n    loopEnd?: number;\n    loopStart?: number;\n    playbackRate?: number;\n}\n\ninterface AudioContextInfo {\n    currentTime?: number;\n    sampleRate?: number;\n}\n\ninterface AudioContextOptions {\n    latencyHint?: AudioContextLatencyCategory | number;\n    sampleRate?: number;\n}\n\ninterface AudioNodeOptions {\n    channelCount?: number;\n    channelCountMode?: ChannelCountMode;\n    channelInterpretation?: ChannelInterpretation;\n}\n\ninterface AudioParamDescriptor {\n    automationRate?: AutomationRate;\n    defaultValue?: number;\n    maxValue?: number;\n    minValue?: number;\n    name: string;\n}\n\ninterface AudioProcessingEventInit extends EventInit {\n    inputBuffer: AudioBuffer;\n    outputBuffer: AudioBuffer;\n    playbackTime: number;\n}\n\ninterface AudioTimestamp {\n    contextTime?: number;\n    performanceTime?: number;\n}\n\ninterface AudioWorkletNodeOptions extends AudioNodeOptions {\n    numberOfInputs?: number;\n    numberOfOutputs?: number;\n    outputChannelCount?: number[];\n    parameterData?: Record<string, number>;\n    processorOptions?: any;\n}\n\ninterface BiquadFilterOptions extends AudioNodeOptions {\n    Q?: number;\n    detune?: number;\n    frequency?: number;\n    gain?: number;\n    type?: BiquadFilterType;\n}\n\ninterface BlobPropertyBag {\n    endings?: EndingType;\n    type?: string;\n}\n\ninterface ByteLengthChunk {\n    byteLength?: number;\n}\n\ninterface CacheQueryOptions {\n    cacheName?: string;\n    ignoreMethod?: boolean;\n    ignoreSearch?: boolean;\n    ignoreVary?: boolean;\n}\n\ninterface CanvasRenderingContext2DSettings {\n    alpha?: boolean;\n}\n\ninterface ChannelMergerOptions extends AudioNodeOptions {\n    numberOfInputs?: number;\n}\n\ninterface ChannelSplitterOptions extends AudioNodeOptions {\n    numberOfOutputs?: number;\n}\n\ninterface ClientData {\n    challenge: string;\n    extensions?: WebAuthnExtensions;\n    hashAlg: string | Algorithm;\n    origin: string;\n    rpId: string;\n    tokenBinding?: string;\n}\n\ninterface ClientQueryOptions {\n    includeUncontrolled?: boolean;\n    type?: ClientTypes;\n}\n\ninterface CloseEventInit extends EventInit {\n    code?: number;\n    reason?: string;\n    wasClean?: boolean;\n}\n\ninterface CompositionEventInit extends UIEventInit {\n    data?: string;\n}\n\ninterface ComputedEffectTiming extends EffectTiming {\n    activeDuration?: number;\n    currentIteration?: number | null;\n    endTime?: number;\n    localTime?: number | null;\n    progress?: number | null;\n}\n\ninterface ComputedKeyframe {\n    composite: CompositeOperationOrAuto;\n    computedOffset: number;\n    easing: string;\n    offset: number | null;\n    [property: string]: string | number | null | undefined;\n}\n\ninterface ConfirmSiteSpecificExceptionsInformation extends ExceptionInformation {\n    arrayOfDomainStrings?: string[];\n}\n\ninterface ConstantSourceOptions {\n    offset?: number;\n}\n\ninterface ConstrainBooleanParameters {\n    exact?: boolean;\n    ideal?: boolean;\n}\n\ninterface ConstrainDOMStringParameters {\n    exact?: string | string[];\n    ideal?: string | string[];\n}\n\ninterface ConstrainDoubleRange extends DoubleRange {\n    exact?: number;\n    ideal?: number;\n}\n\ninterface ConstrainLongRange extends LongRange {\n    exact?: number;\n    ideal?: number;\n}\n\ninterface ConstrainVideoFacingModeParameters {\n    exact?: VideoFacingModeEnum | VideoFacingModeEnum[];\n    ideal?: VideoFacingModeEnum | VideoFacingModeEnum[];\n}\n\ninterface ConvolverOptions extends AudioNodeOptions {\n    buffer?: AudioBuffer | null;\n    disableNormalization?: boolean;\n}\n\ninterface CustomEventInit<T = any> extends EventInit {\n    detail?: T;\n}\n\ninterface DOMMatrix2DInit {\n    a?: number;\n    b?: number;\n    c?: number;\n    d?: number;\n    e?: number;\n    f?: number;\n    m11?: number;\n    m12?: number;\n    m21?: number;\n    m22?: number;\n    m41?: number;\n    m42?: number;\n}\n\ninterface DOMMatrixInit extends DOMMatrix2DInit {\n    is2D?: boolean;\n    m13?: number;\n    m14?: number;\n    m23?: number;\n    m24?: number;\n    m31?: number;\n    m32?: number;\n    m33?: number;\n    m34?: number;\n    m43?: number;\n    m44?: number;\n}\n\ninterface DOMPointInit {\n    w?: number;\n    x?: number;\n    y?: number;\n    z?: number;\n}\n\ninterface DOMQuadInit {\n    p1?: DOMPointInit;\n    p2?: DOMPointInit;\n    p3?: DOMPointInit;\n    p4?: DOMPointInit;\n}\n\ninterface DOMRectInit {\n    height?: number;\n    width?: number;\n    x?: number;\n    y?: number;\n}\n\ninterface DelayOptions extends AudioNodeOptions {\n    delayTime?: number;\n    maxDelayTime?: number;\n}\n\ninterface DeviceAccelerationDict {\n    x?: number | null;\n    y?: number | null;\n    z?: number | null;\n}\n\ninterface DeviceLightEventInit extends EventInit {\n    value?: number;\n}\n\ninterface DeviceMotionEventInit extends EventInit {\n    acceleration?: DeviceAccelerationDict | null;\n    accelerationIncludingGravity?: DeviceAccelerationDict | null;\n    interval?: number | null;\n    rotationRate?: DeviceRotationRateDict | null;\n}\n\ninterface DeviceOrientationEventInit extends EventInit {\n    absolute?: boolean;\n    alpha?: number | null;\n    beta?: number | null;\n    gamma?: number | null;\n}\n\ninterface DeviceRotationRateDict {\n    alpha?: number | null;\n    beta?: number | null;\n    gamma?: number | null;\n}\n\ninterface DocumentTimelineOptions {\n    originTime?: number;\n}\n\ninterface DoubleRange {\n    max?: number;\n    min?: number;\n}\n\ninterface DragEventInit extends MouseEventInit {\n    dataTransfer?: DataTransfer | null;\n}\n\ninterface DynamicsCompressorOptions extends AudioNodeOptions {\n    attack?: number;\n    knee?: number;\n    ratio?: number;\n    release?: number;\n    threshold?: number;\n}\n\ninterface EcKeyAlgorithm extends KeyAlgorithm {\n    namedCurve: NamedCurve;\n}\n\ninterface EcKeyGenParams extends Algorithm {\n    namedCurve: NamedCurve;\n}\n\ninterface EcKeyImportParams extends Algorithm {\n    namedCurve: NamedCurve;\n}\n\ninterface EcdhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface EcdsaParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface EffectTiming {\n    delay?: number;\n    direction?: PlaybackDirection;\n    duration?: number | string;\n    easing?: string;\n    endDelay?: number;\n    fill?: FillMode;\n    iterationStart?: number;\n    iterations?: number;\n}\n\ninterface ElementDefinitionOptions {\n    extends?: string;\n}\n\ninterface ErrorEventInit extends EventInit {\n    colno?: number;\n    error?: any;\n    filename?: string;\n    lineno?: number;\n    message?: string;\n}\n\ninterface EventInit {\n    bubbles?: boolean;\n    cancelable?: boolean;\n    composed?: boolean;\n}\n\ninterface EventListenerOptions {\n    capture?: boolean;\n}\n\ninterface EventModifierInit extends UIEventInit {\n    altKey?: boolean;\n    ctrlKey?: boolean;\n    metaKey?: boolean;\n    modifierAltGraph?: boolean;\n    modifierCapsLock?: boolean;\n    modifierFn?: boolean;\n    modifierFnLock?: boolean;\n    modifierHyper?: boolean;\n    modifierNumLock?: boolean;\n    modifierOS?: boolean;\n    modifierScrollLock?: boolean;\n    modifierSuper?: boolean;\n    modifierSymbol?: boolean;\n    modifierSymbolLock?: boolean;\n    shiftKey?: boolean;\n}\n\ninterface ExceptionInformation {\n    domain?: string | null;\n}\n\ninterface FilePropertyBag extends BlobPropertyBag {\n    lastModified?: number;\n}\n\ninterface FocusEventInit extends UIEventInit {\n    relatedTarget?: EventTarget | null;\n}\n\ninterface FocusNavigationEventInit extends EventInit {\n    navigationReason?: string | null;\n    originHeight?: number;\n    originLeft?: number;\n    originTop?: number;\n    originWidth?: number;\n}\n\ninterface FocusNavigationOrigin {\n    originHeight?: number;\n    originLeft?: number;\n    originTop?: number;\n    originWidth?: number;\n}\n\ninterface FocusOptions {\n    preventScroll?: boolean;\n}\n\ninterface GainOptions extends AudioNodeOptions {\n    gain?: number;\n}\n\ninterface GamepadEventInit extends EventInit {\n    gamepad?: Gamepad;\n}\n\ninterface GetNotificationOptions {\n    tag?: string;\n}\n\ninterface GetRootNodeOptions {\n    composed?: boolean;\n}\n\ninterface HashChangeEventInit extends EventInit {\n    newURL?: string;\n    oldURL?: string;\n}\n\ninterface HkdfParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    info: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    salt: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface HmacImportParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    length?: number;\n}\n\ninterface HmacKeyAlgorithm extends KeyAlgorithm {\n    hash: KeyAlgorithm;\n    length: number;\n}\n\ninterface HmacKeyGenParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    length?: number;\n}\n\ninterface IDBIndexParameters {\n    multiEntry?: boolean;\n    unique?: boolean;\n}\n\ninterface IDBObjectStoreParameters {\n    autoIncrement?: boolean;\n    keyPath?: string | string[] | null;\n}\n\ninterface IDBVersionChangeEventInit extends EventInit {\n    newVersion?: number | null;\n    oldVersion?: number;\n}\n\ninterface IIRFilterOptions extends AudioNodeOptions {\n    feedback: number[];\n    feedforward: number[];\n}\n\ninterface IntersectionObserverEntryInit {\n    boundingClientRect: DOMRectInit;\n    intersectionRect: DOMRectInit;\n    isIntersecting: boolean;\n    rootBounds: DOMRectInit;\n    target: Element;\n    time: number;\n}\n\ninterface IntersectionObserverInit {\n    root?: Element | null;\n    rootMargin?: string;\n    threshold?: number | number[];\n}\n\ninterface JsonWebKey {\n    alg?: string;\n    crv?: string;\n    d?: string;\n    dp?: string;\n    dq?: string;\n    e?: string;\n    ext?: boolean;\n    k?: string;\n    key_ops?: string[];\n    kty?: string;\n    n?: string;\n    oth?: RsaOtherPrimesInfo[];\n    p?: string;\n    q?: string;\n    qi?: string;\n    use?: string;\n    x?: string;\n    y?: string;\n}\n\ninterface KeyAlgorithm {\n    name: string;\n}\n\ninterface KeyboardEventInit extends EventModifierInit {\n    code?: string;\n    key?: string;\n    location?: number;\n    repeat?: boolean;\n}\n\ninterface Keyframe {\n    composite?: CompositeOperationOrAuto;\n    easing?: string;\n    offset?: number | null;\n    [property: string]: string | number | null | undefined;\n}\n\ninterface KeyframeAnimationOptions extends KeyframeEffectOptions {\n    id?: string;\n}\n\ninterface KeyframeEffectOptions extends EffectTiming {\n    composite?: CompositeOperation;\n    iterationComposite?: IterationCompositeOperation;\n}\n\ninterface LongRange {\n    max?: number;\n    min?: number;\n}\n\ninterface MediaElementAudioSourceOptions {\n    mediaElement: HTMLMediaElement;\n}\n\ninterface MediaEncryptedEventInit extends EventInit {\n    initData?: ArrayBuffer | null;\n    initDataType?: string;\n}\n\ninterface MediaKeyMessageEventInit extends EventInit {\n    message?: ArrayBuffer | null;\n    messageType?: MediaKeyMessageType;\n}\n\ninterface MediaKeySystemConfiguration {\n    audioCapabilities?: MediaKeySystemMediaCapability[];\n    distinctiveIdentifier?: MediaKeysRequirement;\n    initDataTypes?: string[];\n    persistentState?: MediaKeysRequirement;\n    videoCapabilities?: MediaKeySystemMediaCapability[];\n}\n\ninterface MediaKeySystemMediaCapability {\n    contentType?: string;\n    robustness?: string;\n}\n\ninterface MediaQueryListEventInit extends EventInit {\n    matches?: boolean;\n    media?: string;\n}\n\ninterface MediaStreamAudioSourceOptions {\n    mediaStream: MediaStream;\n}\n\ninterface MediaStreamConstraints {\n    audio?: boolean | MediaTrackConstraints;\n    peerIdentity?: string;\n    video?: boolean | MediaTrackConstraints;\n}\n\ninterface MediaStreamErrorEventInit extends EventInit {\n    error?: MediaStreamError | null;\n}\n\ninterface MediaStreamEventInit extends EventInit {\n    stream?: MediaStream;\n}\n\ninterface MediaStreamTrackAudioSourceOptions {\n    mediaStreamTrack: MediaStreamTrack;\n}\n\ninterface MediaStreamTrackEventInit extends EventInit {\n    track?: MediaStreamTrack | null;\n}\n\ninterface MediaTrackCapabilities {\n    aspectRatio?: number | DoubleRange;\n    deviceId?: string;\n    echoCancellation?: boolean[];\n    facingMode?: string;\n    frameRate?: number | DoubleRange;\n    groupId?: string;\n    height?: number | LongRange;\n    sampleRate?: number | LongRange;\n    sampleSize?: number | LongRange;\n    volume?: number | DoubleRange;\n    width?: number | LongRange;\n}\n\ninterface MediaTrackConstraintSet {\n    aspectRatio?: number | ConstrainDoubleRange;\n    channelCount?: number | ConstrainLongRange;\n    deviceId?: string | string[] | ConstrainDOMStringParameters;\n    displaySurface?: string | string[] | ConstrainDOMStringParameters;\n    echoCancellation?: boolean | ConstrainBooleanParameters;\n    facingMode?: string | string[] | ConstrainDOMStringParameters;\n    frameRate?: number | ConstrainDoubleRange;\n    groupId?: string | string[] | ConstrainDOMStringParameters;\n    height?: number | ConstrainLongRange;\n    latency?: number | ConstrainDoubleRange;\n    logicalSurface?: boolean | ConstrainBooleanParameters;\n    sampleRate?: number | ConstrainLongRange;\n    sampleSize?: number | ConstrainLongRange;\n    volume?: number | ConstrainDoubleRange;\n    width?: number | ConstrainLongRange;\n}\n\ninterface MediaTrackConstraints extends MediaTrackConstraintSet {\n    advanced?: MediaTrackConstraintSet[];\n}\n\ninterface MediaTrackSettings {\n    aspectRatio?: number;\n    deviceId?: string;\n    echoCancellation?: boolean;\n    facingMode?: string;\n    frameRate?: number;\n    groupId?: string;\n    height?: number;\n    sampleRate?: number;\n    sampleSize?: number;\n    volume?: number;\n    width?: number;\n}\n\ninterface MediaTrackSupportedConstraints {\n    aspectRatio?: boolean;\n    deviceId?: boolean;\n    echoCancellation?: boolean;\n    facingMode?: boolean;\n    frameRate?: boolean;\n    groupId?: boolean;\n    height?: boolean;\n    sampleRate?: boolean;\n    sampleSize?: boolean;\n    volume?: boolean;\n    width?: boolean;\n}\n\ninterface MessageEventInit extends EventInit {\n    data?: any;\n    lastEventId?: string;\n    origin?: string;\n    ports?: MessagePort[];\n    source?: MessageEventSource | null;\n}\n\ninterface MouseEventInit extends EventModifierInit {\n    button?: number;\n    buttons?: number;\n    clientX?: number;\n    clientY?: number;\n    relatedTarget?: EventTarget | null;\n    screenX?: number;\n    screenY?: number;\n}\n\ninterface MutationObserverInit {\n    attributeFilter?: string[];\n    attributeOldValue?: boolean;\n    attributes?: boolean;\n    characterData?: boolean;\n    characterDataOldValue?: boolean;\n    childList?: boolean;\n    subtree?: boolean;\n}\n\ninterface NavigationPreloadState {\n    enabled?: boolean;\n    headerValue?: string;\n}\n\ninterface NotificationAction {\n    action: string;\n    icon?: string;\n    title: string;\n}\n\ninterface NotificationOptions {\n    actions?: NotificationAction[];\n    badge?: string;\n    body?: string;\n    data?: any;\n    dir?: NotificationDirection;\n    icon?: string;\n    image?: string;\n    lang?: string;\n    renotify?: boolean;\n    requireInteraction?: boolean;\n    silent?: boolean;\n    tag?: string;\n    timestamp?: number;\n    vibrate?: VibratePattern;\n}\n\ninterface OfflineAudioCompletionEventInit extends EventInit {\n    renderedBuffer: AudioBuffer;\n}\n\ninterface OfflineAudioContextOptions {\n    length: number;\n    numberOfChannels?: number;\n    sampleRate: number;\n}\n\ninterface OptionalEffectTiming {\n    delay?: number;\n    direction?: PlaybackDirection;\n    duration?: number | string;\n    easing?: string;\n    endDelay?: number;\n    fill?: FillMode;\n    iterationStart?: number;\n    iterations?: number;\n}\n\ninterface OscillatorOptions extends AudioNodeOptions {\n    detune?: number;\n    frequency?: number;\n    periodicWave?: PeriodicWave;\n    type?: OscillatorType;\n}\n\ninterface PannerOptions extends AudioNodeOptions {\n    coneInnerAngle?: number;\n    coneOuterAngle?: number;\n    coneOuterGain?: number;\n    distanceModel?: DistanceModelType;\n    maxDistance?: number;\n    orientationX?: number;\n    orientationY?: number;\n    orientationZ?: number;\n    panningModel?: PanningModelType;\n    positionX?: number;\n    positionY?: number;\n    positionZ?: number;\n    refDistance?: number;\n    rolloffFactor?: number;\n}\n\ninterface PaymentCurrencyAmount {\n    currency: string;\n    currencySystem?: string;\n    value: string;\n}\n\ninterface PaymentDetailsBase {\n    displayItems?: PaymentItem[];\n    modifiers?: PaymentDetailsModifier[];\n    shippingOptions?: PaymentShippingOption[];\n}\n\ninterface PaymentDetailsInit extends PaymentDetailsBase {\n    id?: string;\n    total: PaymentItem;\n}\n\ninterface PaymentDetailsModifier {\n    additionalDisplayItems?: PaymentItem[];\n    data?: any;\n    supportedMethods: string | string[];\n    total?: PaymentItem;\n}\n\ninterface PaymentDetailsUpdate extends PaymentDetailsBase {\n    error?: string;\n    total?: PaymentItem;\n}\n\ninterface PaymentItem {\n    amount: PaymentCurrencyAmount;\n    label: string;\n    pending?: boolean;\n}\n\ninterface PaymentMethodData {\n    data?: any;\n    supportedMethods: string | string[];\n}\n\ninterface PaymentOptions {\n    requestPayerEmail?: boolean;\n    requestPayerName?: boolean;\n    requestPayerPhone?: boolean;\n    requestShipping?: boolean;\n    shippingType?: string;\n}\n\ninterface PaymentRequestUpdateEventInit extends EventInit {\n}\n\ninterface PaymentShippingOption {\n    amount: PaymentCurrencyAmount;\n    id: string;\n    label: string;\n    selected?: boolean;\n}\n\ninterface Pbkdf2Params extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    iterations: number;\n    salt: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface PerformanceObserverInit {\n    buffered?: boolean;\n    entryTypes: string[];\n}\n\ninterface PeriodicWaveConstraints {\n    disableNormalization?: boolean;\n}\n\ninterface PeriodicWaveOptions extends PeriodicWaveConstraints {\n    imag?: number[] | Float32Array;\n    real?: number[] | Float32Array;\n}\n\ninterface PipeOptions {\n    preventAbort?: boolean;\n    preventCancel?: boolean;\n    preventClose?: boolean;\n}\n\ninterface PointerEventInit extends MouseEventInit {\n    height?: number;\n    isPrimary?: boolean;\n    pointerId?: number;\n    pointerType?: string;\n    pressure?: number;\n    tangentialPressure?: number;\n    tiltX?: number;\n    tiltY?: number;\n    twist?: number;\n    width?: number;\n}\n\ninterface PopStateEventInit extends EventInit {\n    state?: any;\n}\n\ninterface PositionOptions {\n    enableHighAccuracy?: boolean;\n    maximumAge?: number;\n    timeout?: number;\n}\n\ninterface ProgressEventInit extends EventInit {\n    lengthComputable?: boolean;\n    loaded?: number;\n    total?: number;\n}\n\ninterface PromiseRejectionEventInit extends EventInit {\n    promise: Promise<any>;\n    reason?: any;\n}\n\ninterface PropertyIndexedKeyframes {\n    composite?: CompositeOperationOrAuto | CompositeOperationOrAuto[];\n    easing?: string | string[];\n    offset?: number | (number | null)[];\n    [property: string]: string | string[] | number | null | (number | null)[] | undefined;\n}\n\ninterface PushSubscriptionJSON {\n    endpoint?: string;\n    expirationTime?: number | null;\n    keys?: Record<string, string>;\n}\n\ninterface PushSubscriptionOptionsInit {\n    applicationServerKey?: BufferSource | string | null;\n    userVisibleOnly?: boolean;\n}\n\ninterface QueuingStrategy<T = any> {\n    highWaterMark?: number;\n    size?: QueuingStrategySizeCallback<T>;\n}\n\ninterface RTCAnswerOptions extends RTCOfferAnswerOptions {\n}\n\ninterface RTCCertificateExpiration {\n    expires?: number;\n}\n\ninterface RTCConfiguration {\n    bundlePolicy?: RTCBundlePolicy;\n    certificates?: RTCCertificate[];\n    iceCandidatePoolSize?: number;\n    iceServers?: RTCIceServer[];\n    iceTransportPolicy?: RTCIceTransportPolicy;\n    peerIdentity?: string;\n    rtcpMuxPolicy?: RTCRtcpMuxPolicy;\n}\n\ninterface RTCDTMFToneChangeEventInit extends EventInit {\n    tone: string;\n}\n\ninterface RTCDataChannelEventInit extends EventInit {\n    channel: RTCDataChannel;\n}\n\ninterface RTCDataChannelInit {\n    id?: number;\n    maxPacketLifeTime?: number;\n    maxRetransmits?: number;\n    negotiated?: boolean;\n    ordered?: boolean;\n    priority?: RTCPriorityType;\n    protocol?: string;\n}\n\ninterface RTCDtlsFingerprint {\n    algorithm?: string;\n    value?: string;\n}\n\ninterface RTCDtlsParameters {\n    fingerprints?: RTCDtlsFingerprint[];\n    role?: RTCDtlsRole;\n}\n\ninterface RTCErrorEventInit extends EventInit {\n    error?: RTCError | null;\n}\n\ninterface RTCIceCandidateAttributes extends RTCStats {\n    addressSourceUrl?: string;\n    candidateType?: RTCStatsIceCandidateType;\n    ipAddress?: string;\n    portNumber?: number;\n    priority?: number;\n    transport?: string;\n}\n\ninterface RTCIceCandidateComplete {\n}\n\ninterface RTCIceCandidateDictionary {\n    foundation?: string;\n    ip?: string;\n    msMTurnSessionId?: string;\n    port?: number;\n    priority?: number;\n    protocol?: RTCIceProtocol;\n    relatedAddress?: string;\n    relatedPort?: number;\n    tcpType?: RTCIceTcpCandidateType;\n    type?: RTCIceCandidateType;\n}\n\ninterface RTCIceCandidateInit {\n    candidate?: string;\n    sdpMLineIndex?: number | null;\n    sdpMid?: string | null;\n    usernameFragment?: string;\n}\n\ninterface RTCIceCandidatePair {\n    local?: RTCIceCandidate;\n    remote?: RTCIceCandidate;\n}\n\ninterface RTCIceCandidatePairStats extends RTCStats {\n    availableIncomingBitrate?: number;\n    availableOutgoingBitrate?: number;\n    bytesReceived?: number;\n    bytesSent?: number;\n    localCandidateId?: string;\n    nominated?: boolean;\n    priority?: number;\n    readable?: boolean;\n    remoteCandidateId?: string;\n    roundTripTime?: number;\n    state?: RTCStatsIceCandidatePairState;\n    transportId?: string;\n    writable?: boolean;\n}\n\ninterface RTCIceGatherOptions {\n    gatherPolicy?: RTCIceGatherPolicy;\n    iceservers?: RTCIceServer[];\n}\n\ninterface RTCIceParameters {\n    password?: string;\n    usernameFragment?: string;\n}\n\ninterface RTCIceServer {\n    credential?: string | RTCOAuthCredential;\n    credentialType?: RTCIceCredentialType;\n    urls: string | string[];\n    username?: string;\n}\n\ninterface RTCIdentityProviderOptions {\n    peerIdentity?: string;\n    protocol?: string;\n    usernameHint?: string;\n}\n\ninterface RTCInboundRTPStreamStats extends RTCRTPStreamStats {\n    bytesReceived?: number;\n    fractionLost?: number;\n    jitter?: number;\n    packetsLost?: number;\n    packetsReceived?: number;\n}\n\ninterface RTCMediaStreamTrackStats extends RTCStats {\n    audioLevel?: number;\n    echoReturnLoss?: number;\n    echoReturnLossEnhancement?: number;\n    frameHeight?: number;\n    frameWidth?: number;\n    framesCorrupted?: number;\n    framesDecoded?: number;\n    framesDropped?: number;\n    framesPerSecond?: number;\n    framesReceived?: number;\n    framesSent?: number;\n    remoteSource?: boolean;\n    ssrcIds?: string[];\n    trackIdentifier?: string;\n}\n\ninterface RTCOAuthCredential {\n    accessToken: string;\n    macKey: string;\n}\n\ninterface RTCOfferAnswerOptions {\n    voiceActivityDetection?: boolean;\n}\n\ninterface RTCOfferOptions extends RTCOfferAnswerOptions {\n    iceRestart?: boolean;\n    offerToReceiveAudio?: boolean;\n    offerToReceiveVideo?: boolean;\n}\n\ninterface RTCOutboundRTPStreamStats extends RTCRTPStreamStats {\n    bytesSent?: number;\n    packetsSent?: number;\n    roundTripTime?: number;\n    targetBitrate?: number;\n}\n\ninterface RTCPeerConnectionIceErrorEventInit extends EventInit {\n    errorCode: number;\n    hostCandidate?: string;\n    statusText?: string;\n    url?: string;\n}\n\ninterface RTCPeerConnectionIceEventInit extends EventInit {\n    candidate?: RTCIceCandidate | null;\n    url?: string | null;\n}\n\ninterface RTCRTPStreamStats extends RTCStats {\n    associateStatsId?: string;\n    codecId?: string;\n    firCount?: number;\n    isRemote?: boolean;\n    mediaTrackId?: string;\n    mediaType?: string;\n    nackCount?: number;\n    pliCount?: number;\n    sliCount?: number;\n    ssrc?: string;\n    transportId?: string;\n}\n\ninterface RTCRtcpFeedback {\n    parameter?: string;\n    type?: string;\n}\n\ninterface RTCRtcpParameters {\n    cname?: string;\n    reducedSize?: boolean;\n}\n\ninterface RTCRtpCapabilities {\n    codecs: RTCRtpCodecCapability[];\n    headerExtensions: RTCRtpHeaderExtensionCapability[];\n}\n\ninterface RTCRtpCodecCapability {\n    channels?: number;\n    clockRate: number;\n    mimeType: string;\n    sdpFmtpLine?: string;\n}\n\ninterface RTCRtpCodecParameters {\n    channels?: number;\n    clockRate: number;\n    mimeType: string;\n    payloadType: number;\n    sdpFmtpLine?: string;\n}\n\ninterface RTCRtpCodingParameters {\n    rid?: string;\n}\n\ninterface RTCRtpContributingSource {\n    audioLevel?: number;\n    source: number;\n    timestamp: number;\n}\n\ninterface RTCRtpDecodingParameters extends RTCRtpCodingParameters {\n}\n\ninterface RTCRtpEncodingParameters extends RTCRtpCodingParameters {\n    active?: boolean;\n    codecPayloadType?: number;\n    dtx?: RTCDtxStatus;\n    maxBitrate?: number;\n    maxFramerate?: number;\n    priority?: RTCPriorityType;\n    ptime?: number;\n    scaleResolutionDownBy?: number;\n}\n\ninterface RTCRtpFecParameters {\n    mechanism?: string;\n    ssrc?: number;\n}\n\ninterface RTCRtpHeaderExtension {\n    kind?: string;\n    preferredEncrypt?: boolean;\n    preferredId?: number;\n    uri?: string;\n}\n\ninterface RTCRtpHeaderExtensionCapability {\n    uri?: string;\n}\n\ninterface RTCRtpHeaderExtensionParameters {\n    encrypted?: boolean;\n    id: number;\n    uri: string;\n}\n\ninterface RTCRtpParameters {\n    codecs: RTCRtpCodecParameters[];\n    headerExtensions: RTCRtpHeaderExtensionParameters[];\n    rtcp: RTCRtcpParameters;\n}\n\ninterface RTCRtpReceiveParameters extends RTCRtpParameters {\n    encodings: RTCRtpDecodingParameters[];\n}\n\ninterface RTCRtpRtxParameters {\n    ssrc?: number;\n}\n\ninterface RTCRtpSendParameters extends RTCRtpParameters {\n    degradationPreference?: RTCDegradationPreference;\n    encodings: RTCRtpEncodingParameters[];\n    transactionId: string;\n}\n\ninterface RTCRtpSynchronizationSource extends RTCRtpContributingSource {\n    voiceActivityFlag?: boolean;\n}\n\ninterface RTCRtpTransceiverInit {\n    direction?: RTCRtpTransceiverDirection;\n    sendEncodings?: RTCRtpEncodingParameters[];\n    streams?: MediaStream[];\n}\n\ninterface RTCRtpUnhandled {\n    muxId?: string;\n    payloadType?: number;\n    ssrc?: number;\n}\n\ninterface RTCSessionDescriptionInit {\n    sdp?: string;\n    type: RTCSdpType;\n}\n\ninterface RTCSrtpKeyParam {\n    keyMethod?: string;\n    keySalt?: string;\n    lifetime?: string;\n    mkiLength?: number;\n    mkiValue?: number;\n}\n\ninterface RTCSrtpSdesParameters {\n    cryptoSuite?: string;\n    keyParams?: RTCSrtpKeyParam[];\n    sessionParams?: string[];\n    tag?: number;\n}\n\ninterface RTCSsrcRange {\n    max?: number;\n    min?: number;\n}\n\ninterface RTCStats {\n    id: string;\n    timestamp: number;\n    type: RTCStatsType;\n}\n\ninterface RTCStatsEventInit extends EventInit {\n    report: RTCStatsReport;\n}\n\ninterface RTCStatsReport {\n}\n\ninterface RTCTrackEventInit extends EventInit {\n    receiver: RTCRtpReceiver;\n    streams?: MediaStream[];\n    track: MediaStreamTrack;\n    transceiver: RTCRtpTransceiver;\n}\n\ninterface RTCTransportStats extends RTCStats {\n    activeConnection?: boolean;\n    bytesReceived?: number;\n    bytesSent?: number;\n    localCertificateId?: string;\n    remoteCertificateId?: string;\n    rtcpTransportStatsId?: string;\n    selectedCandidatePairId?: string;\n}\n\ninterface RegistrationOptions {\n    scope?: string;\n    type?: WorkerType;\n    updateViaCache?: ServiceWorkerUpdateViaCache;\n}\n\ninterface RequestInit {\n    body?: BodyInit | null;\n    cache?: RequestCache;\n    credentials?: RequestCredentials;\n    headers?: HeadersInit;\n    integrity?: string;\n    keepalive?: boolean;\n    method?: string;\n    mode?: RequestMode;\n    redirect?: RequestRedirect;\n    referrer?: string;\n    referrerPolicy?: ReferrerPolicy;\n    signal?: AbortSignal | null;\n    window?: any;\n}\n\ninterface ResponseInit {\n    headers?: HeadersInit;\n    status?: number;\n    statusText?: string;\n}\n\ninterface RsaHashedImportParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {\n    hash: KeyAlgorithm;\n}\n\ninterface RsaHashedKeyGenParams extends RsaKeyGenParams {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface RsaKeyAlgorithm extends KeyAlgorithm {\n    modulusLength: number;\n    publicExponent: BigInteger;\n}\n\ninterface RsaKeyGenParams extends Algorithm {\n    modulusLength: number;\n    publicExponent: BigInteger;\n}\n\ninterface RsaOaepParams extends Algorithm {\n    label?: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface RsaOtherPrimesInfo {\n    d?: string;\n    r?: string;\n    t?: string;\n}\n\ninterface RsaPssParams extends Algorithm {\n    saltLength: number;\n}\n\ninterface SVGBoundingBoxOptions {\n    clipped?: boolean;\n    fill?: boolean;\n    markers?: boolean;\n    stroke?: boolean;\n}\n\ninterface ScopedCredentialDescriptor {\n    id: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null;\n    transports?: Transport[];\n    type: ScopedCredentialType;\n}\n\ninterface ScopedCredentialOptions {\n    excludeList?: ScopedCredentialDescriptor[];\n    extensions?: WebAuthnExtensions;\n    rpId?: string;\n    timeoutSeconds?: number;\n}\n\ninterface ScopedCredentialParameters {\n    algorithm: string | Algorithm;\n    type: ScopedCredentialType;\n}\n\ninterface ScrollIntoViewOptions extends ScrollOptions {\n    block?: ScrollLogicalPosition;\n    inline?: ScrollLogicalPosition;\n}\n\ninterface ScrollOptions {\n    behavior?: ScrollBehavior;\n}\n\ninterface ScrollToOptions extends ScrollOptions {\n    left?: number;\n    top?: number;\n}\n\ninterface SecurityPolicyViolationEventInit extends EventInit {\n    blockedURI?: string;\n    columnNumber?: number;\n    documentURI?: string;\n    effectiveDirective?: string;\n    lineNumber?: number;\n    originalPolicy?: string;\n    referrer?: string;\n    sourceFile?: string;\n    statusCode?: number;\n    violatedDirective?: string;\n}\n\ninterface ServiceWorkerMessageEventInit extends EventInit {\n    data?: any;\n    lastEventId?: string;\n    origin?: string;\n    ports?: MessagePort[] | null;\n    source?: ServiceWorker | MessagePort | null;\n}\n\ninterface StereoPannerOptions extends AudioNodeOptions {\n    pan?: number;\n}\n\ninterface StorageEstimate {\n    quota?: number;\n    usage?: number;\n}\n\ninterface StorageEventInit extends EventInit {\n    key?: string | null;\n    newValue?: string | null;\n    oldValue?: string | null;\n    storageArea?: Storage | null;\n    url?: string;\n}\n\ninterface StoreExceptionsInformation extends ExceptionInformation {\n    detailURI?: string | null;\n    explanationString?: string | null;\n    siteName?: string | null;\n}\n\ninterface StoreSiteSpecificExceptionsInformation extends StoreExceptionsInformation {\n    arrayOfDomainStrings?: string[];\n}\n\ninterface TextDecodeOptions {\n    stream?: boolean;\n}\n\ninterface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ninterface TouchEventInit extends EventModifierInit {\n    changedTouches?: Touch[];\n    targetTouches?: Touch[];\n    touches?: Touch[];\n}\n\ninterface TouchInit {\n    altitudeAngle?: number;\n    azimuthAngle?: number;\n    clientX?: number;\n    clientY?: number;\n    force?: number;\n    identifier: number;\n    pageX?: number;\n    pageY?: number;\n    radiusX?: number;\n    radiusY?: number;\n    rotationAngle?: number;\n    screenX?: number;\n    screenY?: number;\n    target: EventTarget;\n    touchType?: TouchType;\n}\n\ninterface TrackEventInit extends EventInit {\n    track?: VideoTrack | AudioTrack | TextTrack | null;\n}\n\ninterface Transformer<I = any, O = any> {\n    flush?: TransformStreamDefaultControllerCallback<O>;\n    readableType?: undefined;\n    start?: TransformStreamDefaultControllerCallback<O>;\n    transform?: TransformStreamDefaultControllerTransformCallback<I, O>;\n    writableType?: undefined;\n}\n\ninterface TransitionEventInit extends EventInit {\n    elapsedTime?: number;\n    propertyName?: string;\n    pseudoElement?: string;\n}\n\ninterface UIEventInit extends EventInit {\n    detail?: number;\n    view?: Window | null;\n}\n\ninterface UnderlyingByteSource {\n    autoAllocateChunkSize?: number;\n    cancel?: ReadableStreamErrorCallback;\n    pull?: ReadableByteStreamControllerCallback;\n    start?: ReadableByteStreamControllerCallback;\n    type: "bytes";\n}\n\ninterface UnderlyingSink<W = any> {\n    abort?: WritableStreamErrorCallback;\n    close?: WritableStreamDefaultControllerCloseCallback;\n    start?: WritableStreamDefaultControllerStartCallback;\n    type?: undefined;\n    write?: WritableStreamDefaultControllerWriteCallback<W>;\n}\n\ninterface UnderlyingSource<R = any> {\n    cancel?: ReadableStreamErrorCallback;\n    pull?: ReadableStreamDefaultControllerCallback<R>;\n    start?: ReadableStreamDefaultControllerCallback<R>;\n    type?: undefined;\n}\n\ninterface VRDisplayEventInit extends EventInit {\n    display: VRDisplay;\n    reason?: VRDisplayEventReason;\n}\n\ninterface VRLayer {\n    leftBounds?: number[] | Float32Array | null;\n    rightBounds?: number[] | Float32Array | null;\n    source?: HTMLCanvasElement | null;\n}\n\ninterface VRStageParameters {\n    sittingToStandingTransform?: Float32Array;\n    sizeX?: number;\n    sizeY?: number;\n}\n\ninterface WaveShaperOptions extends AudioNodeOptions {\n    curve?: number[] | Float32Array;\n    oversample?: OverSampleType;\n}\n\ninterface WebAuthnExtensions {\n}\n\ninterface WebGLContextAttributes {\n    alpha?: GLboolean;\n    antialias?: GLboolean;\n    depth?: GLboolean;\n    failIfMajorPerformanceCaveat?: boolean;\n    powerPreference?: WebGLPowerPreference;\n    premultipliedAlpha?: GLboolean;\n    preserveDrawingBuffer?: GLboolean;\n    stencil?: GLboolean;\n}\n\ninterface WebGLContextEventInit extends EventInit {\n    statusMessage?: string;\n}\n\ninterface WheelEventInit extends MouseEventInit {\n    deltaMode?: number;\n    deltaX?: number;\n    deltaY?: number;\n    deltaZ?: number;\n}\n\ninterface WorkerOptions {\n    credentials?: RequestCredentials;\n    name?: string;\n    type?: WorkerType;\n}\n\ninterface WorkletOptions {\n    credentials?: RequestCredentials;\n}\n\ninterface EventListener {\n    (evt: Event): void;\n}\n\ninterface ANGLE_instanced_arrays {\n    drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei): void;\n    drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei): void;\n    vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint): void;\n    readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: GLenum;\n}\n\ninterface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n    /**\n     * Invoking this method will set this object\'s AbortSignal\'s aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort(): void;\n}\n\ndeclare var AbortController: {\n    prototype: AbortController;\n    new(): AbortController;\n};\n\ninterface AbortSignalEventMap {\n    "abort": ProgressEvent;\n}\n\ninterface AbortSignal extends EventTarget {\n    /**\n     * Returns true if this AbortSignal\'s AbortController has signaled to abort, and false\n     * otherwise.\n     */\n    readonly aborted: boolean;\n    onabort: ((this: AbortSignal, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AbortSignal: {\n    prototype: AbortSignal;\n    new(): AbortSignal;\n};\n\ninterface AbstractRange {\n    readonly collapsed: boolean;\n    readonly endContainer: Node;\n    readonly endOffset: number;\n    readonly startContainer: Node;\n    readonly startOffset: number;\n}\n\ndeclare var AbstractRange: {\n    prototype: AbstractRange;\n    new(): AbstractRange;\n};\n\ninterface AbstractWorkerEventMap {\n    "error": ErrorEvent;\n}\n\ninterface AbstractWorker {\n    onerror: ((this: AbstractWorker, ev: ErrorEvent) => any) | null;\n    addEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface AesCfbParams extends Algorithm {\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface AesCmacParams extends Algorithm {\n    length: number;\n}\n\ninterface AnalyserNode extends AudioNode {\n    fftSize: number;\n    readonly frequencyBinCount: number;\n    maxDecibels: number;\n    minDecibels: number;\n    smoothingTimeConstant: number;\n    getByteFrequencyData(array: Uint8Array): void;\n    getByteTimeDomainData(array: Uint8Array): void;\n    getFloatFrequencyData(array: Float32Array): void;\n    getFloatTimeDomainData(array: Float32Array): void;\n}\n\ndeclare var AnalyserNode: {\n    prototype: AnalyserNode;\n    new(context: BaseAudioContext, options?: AnalyserOptions): AnalyserNode;\n};\n\ninterface Animatable {\n    animate(keyframes: Keyframe[] | PropertyIndexedKeyframes | null, options?: number | KeyframeAnimationOptions): Animation;\n    getAnimations(): Animation[];\n}\n\ninterface AnimationEventMap {\n    "cancel": AnimationPlaybackEvent;\n    "finish": AnimationPlaybackEvent;\n}\n\ninterface Animation extends EventTarget {\n    currentTime: number | null;\n    effect: AnimationEffect | null;\n    readonly finished: Promise<Animation>;\n    id: string;\n    oncancel: ((this: Animation, ev: AnimationPlaybackEvent) => any) | null;\n    onfinish: ((this: Animation, ev: AnimationPlaybackEvent) => any) | null;\n    readonly pending: boolean;\n    readonly playState: AnimationPlayState;\n    playbackRate: number;\n    readonly ready: Promise<Animation>;\n    startTime: number | null;\n    timeline: AnimationTimeline | null;\n    cancel(): void;\n    finish(): void;\n    pause(): void;\n    play(): void;\n    reverse(): void;\n    updatePlaybackRate(playbackRate: number): void;\n    addEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: Animation, ev: AnimationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AnimationEventMap>(type: K, listener: (this: Animation, ev: AnimationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Animation: {\n    prototype: Animation;\n    new(effect?: AnimationEffect | null, timeline?: AnimationTimeline | null): Animation;\n};\n\ninterface AnimationEffect {\n    getComputedTiming(): ComputedEffectTiming;\n    getTiming(): EffectTiming;\n    updateTiming(timing?: OptionalEffectTiming): void;\n}\n\ndeclare var AnimationEffect: {\n    prototype: AnimationEffect;\n    new(): AnimationEffect;\n};\n\ninterface AnimationEvent extends Event {\n    readonly animationName: string;\n    readonly elapsedTime: number;\n    readonly pseudoElement: string;\n}\n\ndeclare var AnimationEvent: {\n    prototype: AnimationEvent;\n    new(type: string, animationEventInitDict?: AnimationEventInit): AnimationEvent;\n};\n\ninterface AnimationPlaybackEvent extends Event {\n    readonly currentTime: number | null;\n    readonly timelineTime: number | null;\n}\n\ndeclare var AnimationPlaybackEvent: {\n    prototype: AnimationPlaybackEvent;\n    new(type: string, eventInitDict?: AnimationPlaybackEventInit): AnimationPlaybackEvent;\n};\n\ninterface AnimationTimeline {\n    readonly currentTime: number | null;\n}\n\ndeclare var AnimationTimeline: {\n    prototype: AnimationTimeline;\n    new(): AnimationTimeline;\n};\n\ninterface ApplicationCacheEventMap {\n    "cached": Event;\n    "checking": Event;\n    "downloading": Event;\n    "error": Event;\n    "noupdate": Event;\n    "obsolete": Event;\n    "progress": ProgressEvent;\n    "updateready": Event;\n}\n\ninterface ApplicationCache extends EventTarget {\n    /** @deprecated */\n    oncached: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    onchecking: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    ondownloading: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    onerror: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    onnoupdate: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    onobsolete: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    onprogress: ((this: ApplicationCache, ev: ProgressEvent) => any) | null;\n    /** @deprecated */\n    onupdateready: ((this: ApplicationCache, ev: Event) => any) | null;\n    /** @deprecated */\n    readonly status: number;\n    /** @deprecated */\n    abort(): void;\n    /** @deprecated */\n    swapCache(): void;\n    /** @deprecated */\n    update(): void;\n    readonly CHECKING: number;\n    readonly DOWNLOADING: number;\n    readonly IDLE: number;\n    readonly OBSOLETE: number;\n    readonly UNCACHED: number;\n    readonly UPDATEREADY: number;\n    addEventListener<K extends keyof ApplicationCacheEventMap>(type: K, listener: (this: ApplicationCache, ev: ApplicationCacheEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ApplicationCacheEventMap>(type: K, listener: (this: ApplicationCache, ev: ApplicationCacheEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ApplicationCache: {\n    prototype: ApplicationCache;\n    new(): ApplicationCache;\n    readonly CHECKING: number;\n    readonly DOWNLOADING: number;\n    readonly IDLE: number;\n    readonly OBSOLETE: number;\n    readonly UNCACHED: number;\n    readonly UPDATEREADY: number;\n};\n\ninterface Attr extends Node {\n    readonly localName: string;\n    readonly name: string;\n    readonly namespaceURI: string | null;\n    readonly ownerElement: Element | null;\n    readonly prefix: string | null;\n    readonly specified: boolean;\n    value: string;\n}\n\ndeclare var Attr: {\n    prototype: Attr;\n    new(): Attr;\n};\n\ninterface AudioBuffer {\n    readonly duration: number;\n    readonly length: number;\n    readonly numberOfChannels: number;\n    readonly sampleRate: number;\n    copyFromChannel(destination: Float32Array, channelNumber: number, startInChannel?: number): void;\n    copyToChannel(source: Float32Array, channelNumber: number, startInChannel?: number): void;\n    getChannelData(channel: number): Float32Array;\n}\n\ndeclare var AudioBuffer: {\n    prototype: AudioBuffer;\n    new(options: AudioBufferOptions): AudioBuffer;\n};\n\ninterface AudioBufferSourceNode extends AudioScheduledSourceNode {\n    buffer: AudioBuffer | null;\n    readonly detune: AudioParam;\n    loop: boolean;\n    loopEnd: number;\n    loopStart: number;\n    readonly playbackRate: AudioParam;\n    start(when?: number, offset?: number, duration?: number): void;\n    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioBufferSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioBufferSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AudioBufferSourceNode: {\n    prototype: AudioBufferSourceNode;\n    new(context: BaseAudioContext, options?: AudioBufferSourceOptions): AudioBufferSourceNode;\n};\n\ninterface AudioContext extends BaseAudioContext {\n    readonly baseLatency: number;\n    readonly outputLatency: number;\n    close(): Promise<void>;\n    createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode;\n    createMediaStreamDestination(): MediaStreamAudioDestinationNode;\n    createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode;\n    createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): MediaStreamTrackAudioSourceNode;\n    getOutputTimestamp(): AudioTimestamp;\n    suspend(): Promise<void>;\n    addEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: AudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: AudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AudioContext: {\n    prototype: AudioContext;\n    new(contextOptions?: AudioContextOptions): AudioContext;\n};\n\ninterface AudioDestinationNode extends AudioNode {\n    readonly maxChannelCount: number;\n}\n\ndeclare var AudioDestinationNode: {\n    prototype: AudioDestinationNode;\n    new(): AudioDestinationNode;\n};\n\ninterface AudioListener {\n    readonly forwardX: AudioParam;\n    readonly forwardY: AudioParam;\n    readonly forwardZ: AudioParam;\n    readonly positionX: AudioParam;\n    readonly positionY: AudioParam;\n    readonly positionZ: AudioParam;\n    readonly upX: AudioParam;\n    readonly upY: AudioParam;\n    readonly upZ: AudioParam;\n    /** @deprecated */\n    setOrientation(x: number, y: number, z: number, xUp: number, yUp: number, zUp: number): void;\n    /** @deprecated */\n    setPosition(x: number, y: number, z: number): void;\n}\n\ndeclare var AudioListener: {\n    prototype: AudioListener;\n    new(): AudioListener;\n};\n\ninterface AudioNode extends EventTarget {\n    channelCount: number;\n    channelCountMode: ChannelCountMode;\n    channelInterpretation: ChannelInterpretation;\n    readonly context: BaseAudioContext;\n    readonly numberOfInputs: number;\n    readonly numberOfOutputs: number;\n    connect(destinationNode: AudioNode, output?: number, input?: number): AudioNode;\n    connect(destinationParam: AudioParam, output?: number): void;\n    disconnect(): void;\n    disconnect(output: number): void;\n    disconnect(destinationNode: AudioNode): void;\n    disconnect(destinationNode: AudioNode, output: number): void;\n    disconnect(destinationNode: AudioNode, output: number, input: number): void;\n    disconnect(destinationParam: AudioParam): void;\n    disconnect(destinationParam: AudioParam, output: number): void;\n}\n\ndeclare var AudioNode: {\n    prototype: AudioNode;\n    new(): AudioNode;\n};\n\ninterface AudioParam {\n    automationRate: AutomationRate;\n    readonly defaultValue: number;\n    readonly maxValue: number;\n    readonly minValue: number;\n    value: number;\n    cancelAndHoldAtTime(cancelTime: number): AudioParam;\n    cancelScheduledValues(cancelTime: number): AudioParam;\n    exponentialRampToValueAtTime(value: number, endTime: number): AudioParam;\n    linearRampToValueAtTime(value: number, endTime: number): AudioParam;\n    setTargetAtTime(target: number, startTime: number, timeConstant: number): AudioParam;\n    setValueAtTime(value: number, startTime: number): AudioParam;\n    setValueCurveAtTime(values: number[] | Float32Array, startTime: number, duration: number): AudioParam;\n}\n\ndeclare var AudioParam: {\n    prototype: AudioParam;\n    new(): AudioParam;\n};\n\ninterface AudioParamMap {\n    forEach(callbackfn: (value: AudioParam, key: string, parent: AudioParamMap) => void, thisArg?: any): void;\n}\n\ndeclare var AudioParamMap: {\n    prototype: AudioParamMap;\n    new(): AudioParamMap;\n};\n\ninterface AudioProcessingEvent extends Event {\n    readonly inputBuffer: AudioBuffer;\n    readonly outputBuffer: AudioBuffer;\n    readonly playbackTime: number;\n}\n\ndeclare var AudioProcessingEvent: {\n    prototype: AudioProcessingEvent;\n    new(type: string, eventInitDict: AudioProcessingEventInit): AudioProcessingEvent;\n};\n\ninterface AudioScheduledSourceNodeEventMap {\n    "ended": Event;\n}\n\ninterface AudioScheduledSourceNode extends AudioNode {\n    onended: ((this: AudioScheduledSourceNode, ev: Event) => any) | null;\n    start(when?: number): void;\n    stop(when?: number): void;\n    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioScheduledSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: AudioScheduledSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AudioScheduledSourceNode: {\n    prototype: AudioScheduledSourceNode;\n    new(): AudioScheduledSourceNode;\n};\n\ninterface AudioTrack {\n    enabled: boolean;\n    readonly id: string;\n    kind: string;\n    readonly label: string;\n    language: string;\n    readonly sourceBuffer: SourceBuffer;\n}\n\ndeclare var AudioTrack: {\n    prototype: AudioTrack;\n    new(): AudioTrack;\n};\n\ninterface AudioTrackListEventMap {\n    "addtrack": TrackEvent;\n    "change": Event;\n    "removetrack": TrackEvent;\n}\n\ninterface AudioTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: ((this: AudioTrackList, ev: TrackEvent) => any) | null;\n    onchange: ((this: AudioTrackList, ev: Event) => any) | null;\n    onremovetrack: ((this: AudioTrackList, ev: TrackEvent) => any) | null;\n    getTrackById(id: string): AudioTrack | null;\n    item(index: number): AudioTrack;\n    addEventListener<K extends keyof AudioTrackListEventMap>(type: K, listener: (this: AudioTrackList, ev: AudioTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioTrackListEventMap>(type: K, listener: (this: AudioTrackList, ev: AudioTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    [index: number]: AudioTrack;\n}\n\ndeclare var AudioTrackList: {\n    prototype: AudioTrackList;\n    new(): AudioTrackList;\n};\n\ninterface AudioWorklet extends Worklet {\n}\n\ndeclare var AudioWorklet: {\n    prototype: AudioWorklet;\n    new(): AudioWorklet;\n};\n\ninterface AudioWorkletNodeEventMap {\n    "processorerror": Event;\n}\n\ninterface AudioWorkletNode extends AudioNode {\n    onprocessorerror: ((this: AudioWorkletNode, ev: Event) => any) | null;\n    readonly parameters: AudioParamMap;\n    readonly port: MessagePort;\n    addEventListener<K extends keyof AudioWorkletNodeEventMap>(type: K, listener: (this: AudioWorkletNode, ev: AudioWorkletNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioWorkletNodeEventMap>(type: K, listener: (this: AudioWorkletNode, ev: AudioWorkletNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AudioWorkletNode: {\n    prototype: AudioWorkletNode;\n    new(context: BaseAudioContext, name: string, options?: AudioWorkletNodeOptions): AudioWorkletNode;\n};\n\ninterface BarProp {\n    readonly visible: boolean;\n}\n\ndeclare var BarProp: {\n    prototype: BarProp;\n    new(): BarProp;\n};\n\ninterface BaseAudioContextEventMap {\n    "statechange": Event;\n}\n\ninterface BaseAudioContext extends EventTarget {\n    readonly audioWorklet: AudioWorklet;\n    readonly currentTime: number;\n    readonly destination: AudioDestinationNode;\n    readonly listener: AudioListener;\n    onstatechange: ((this: BaseAudioContext, ev: Event) => any) | null;\n    readonly sampleRate: number;\n    readonly state: AudioContextState;\n    createAnalyser(): AnalyserNode;\n    createBiquadFilter(): BiquadFilterNode;\n    createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;\n    createBufferSource(): AudioBufferSourceNode;\n    createChannelMerger(numberOfInputs?: number): ChannelMergerNode;\n    createChannelSplitter(numberOfOutputs?: number): ChannelSplitterNode;\n    createConstantSource(): ConstantSourceNode;\n    createConvolver(): ConvolverNode;\n    createDelay(maxDelayTime?: number): DelayNode;\n    createDynamicsCompressor(): DynamicsCompressorNode;\n    createGain(): GainNode;\n    createIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode;\n    createOscillator(): OscillatorNode;\n    createPanner(): PannerNode;\n    createPeriodicWave(real: number[] | Float32Array, imag: number[] | Float32Array, constraints?: PeriodicWaveConstraints): PeriodicWave;\n    createScriptProcessor(bufferSize?: number, numberOfInputChannels?: number, numberOfOutputChannels?: number): ScriptProcessorNode;\n    createStereoPanner(): StereoPannerNode;\n    createWaveShaper(): WaveShaperNode;\n    decodeAudioData(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback | null, errorCallback?: DecodeErrorCallback | null): Promise<AudioBuffer>;\n    resume(): Promise<void>;\n    addEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: BaseAudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof BaseAudioContextEventMap>(type: K, listener: (this: BaseAudioContext, ev: BaseAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var BaseAudioContext: {\n    prototype: BaseAudioContext;\n    new(): BaseAudioContext;\n};\n\ninterface BeforeUnloadEvent extends Event {\n    returnValue: any;\n}\n\ndeclare var BeforeUnloadEvent: {\n    prototype: BeforeUnloadEvent;\n    new(): BeforeUnloadEvent;\n};\n\ninterface BhxBrowser {\n    readonly lastError: DOMException;\n    checkMatchesGlobExpression(pattern: string, value: string): boolean;\n    checkMatchesUriExpression(pattern: string, value: string): boolean;\n    clearLastError(): void;\n    currentWindowId(): number;\n    fireExtensionApiTelemetry(functionName: string, isSucceeded: boolean, isSupported: boolean, errorString: string): void;\n    genericFunction(functionId: number, destination: any, parameters?: string, callbackId?: number): void;\n    genericSynchronousFunction(functionId: number, parameters?: string): string;\n    getExtensionId(): string;\n    getThisAddress(): any;\n    registerGenericFunctionCallbackHandler(callbackHandler: Function): void;\n    registerGenericListenerHandler(eventHandler: Function): void;\n    setLastError(parameters: string): void;\n    webPlatformGenericFunction(destination: any, parameters?: string, callbackId?: number): void;\n}\n\ndeclare var BhxBrowser: {\n    prototype: BhxBrowser;\n    new(): BhxBrowser;\n};\n\ninterface BiquadFilterNode extends AudioNode {\n    readonly Q: AudioParam;\n    readonly detune: AudioParam;\n    readonly frequency: AudioParam;\n    readonly gain: AudioParam;\n    type: BiquadFilterType;\n    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;\n}\n\ndeclare var BiquadFilterNode: {\n    prototype: BiquadFilterNode;\n    new(context: BaseAudioContext, options?: BiquadFilterOptions): BiquadFilterNode;\n};\n\ninterface Blob {\n    readonly size: number;\n    readonly type: string;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new(blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;\n};\n\ninterface Body {\n    readonly body: ReadableStream<Uint8Array> | null;\n    readonly bodyUsed: boolean;\n    arrayBuffer(): Promise<ArrayBuffer>;\n    blob(): Promise<Blob>;\n    formData(): Promise<FormData>;\n    json(): Promise<any>;\n    text(): Promise<string>;\n}\n\ninterface BroadcastChannelEventMap {\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface BroadcastChannel extends EventTarget {\n    /**\n     * Returns the channel name (as passed to the constructor).\n     */\n    readonly name: string;\n    onmessage: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n    /**\n     * Closes the BroadcastChannel object, opening it up to garbage collection.\n     */\n    close(): void;\n    /**\n     * Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.\n     */\n    postMessage(message: any): void;\n    addEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var BroadcastChannel: {\n    prototype: BroadcastChannel;\n    new(name: string): BroadcastChannel;\n};\n\ninterface BroadcastChannelEventMap {\n    message: MessageEvent;\n    messageerror: MessageEvent;\n}\n\ninterface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView> {\n    highWaterMark: number;\n    size(chunk: ArrayBufferView): number;\n}\n\ndeclare var ByteLengthQueuingStrategy: {\n    prototype: ByteLengthQueuingStrategy;\n    new(options: { highWaterMark: number }): ByteLengthQueuingStrategy;\n};\n\ninterface CDATASection extends Text {\n}\n\ndeclare var CDATASection: {\n    prototype: CDATASection;\n    new(): CDATASection;\n};\n\ninterface CSS {\n    escape(value: string): string;\n    supports(property: string, value?: string): boolean;\n}\ndeclare var CSS: CSS;\n\ninterface CSSConditionRule extends CSSGroupingRule {\n    conditionText: string;\n}\n\ndeclare var CSSConditionRule: {\n    prototype: CSSConditionRule;\n    new(): CSSConditionRule;\n};\n\ninterface CSSFontFaceRule extends CSSRule {\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSFontFaceRule: {\n    prototype: CSSFontFaceRule;\n    new(): CSSFontFaceRule;\n};\n\ninterface CSSGroupingRule extends CSSRule {\n    readonly cssRules: CSSRuleList;\n    deleteRule(index: number): void;\n    insertRule(rule: string, index: number): number;\n}\n\ndeclare var CSSGroupingRule: {\n    prototype: CSSGroupingRule;\n    new(): CSSGroupingRule;\n};\n\ninterface CSSImportRule extends CSSRule {\n    readonly href: string;\n    readonly media: MediaList;\n    readonly styleSheet: CSSStyleSheet;\n}\n\ndeclare var CSSImportRule: {\n    prototype: CSSImportRule;\n    new(): CSSImportRule;\n};\n\ninterface CSSKeyframeRule extends CSSRule {\n    keyText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSKeyframeRule: {\n    prototype: CSSKeyframeRule;\n    new(): CSSKeyframeRule;\n};\n\ninterface CSSKeyframesRule extends CSSRule {\n    readonly cssRules: CSSRuleList;\n    name: string;\n    appendRule(rule: string): void;\n    deleteRule(select: string): void;\n    findRule(select: string): CSSKeyframeRule | null;\n}\n\ndeclare var CSSKeyframesRule: {\n    prototype: CSSKeyframesRule;\n    new(): CSSKeyframesRule;\n};\n\ninterface CSSMediaRule extends CSSConditionRule {\n    readonly media: MediaList;\n}\n\ndeclare var CSSMediaRule: {\n    prototype: CSSMediaRule;\n    new(): CSSMediaRule;\n};\n\ninterface CSSNamespaceRule extends CSSRule {\n    readonly namespaceURI: string;\n    readonly prefix: string;\n}\n\ndeclare var CSSNamespaceRule: {\n    prototype: CSSNamespaceRule;\n    new(): CSSNamespaceRule;\n};\n\ninterface CSSPageRule extends CSSRule {\n    readonly pseudoClass: string;\n    readonly selector: string;\n    selectorText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSPageRule: {\n    prototype: CSSPageRule;\n    new(): CSSPageRule;\n};\n\ninterface CSSRule {\n    cssText: string;\n    readonly parentRule: CSSRule | null;\n    readonly parentStyleSheet: CSSStyleSheet | null;\n    readonly type: number;\n    readonly CHARSET_RULE: number;\n    readonly FONT_FACE_RULE: number;\n    readonly IMPORT_RULE: number;\n    readonly KEYFRAMES_RULE: number;\n    readonly KEYFRAME_RULE: number;\n    readonly MEDIA_RULE: number;\n    readonly NAMESPACE_RULE: number;\n    readonly PAGE_RULE: number;\n    readonly STYLE_RULE: number;\n    readonly SUPPORTS_RULE: number;\n    readonly UNKNOWN_RULE: number;\n    readonly VIEWPORT_RULE: number;\n}\n\ndeclare var CSSRule: {\n    prototype: CSSRule;\n    new(): CSSRule;\n    readonly CHARSET_RULE: number;\n    readonly FONT_FACE_RULE: number;\n    readonly IMPORT_RULE: number;\n    readonly KEYFRAMES_RULE: number;\n    readonly KEYFRAME_RULE: number;\n    readonly MEDIA_RULE: number;\n    readonly NAMESPACE_RULE: number;\n    readonly PAGE_RULE: number;\n    readonly STYLE_RULE: number;\n    readonly SUPPORTS_RULE: number;\n    readonly UNKNOWN_RULE: number;\n    readonly VIEWPORT_RULE: number;\n};\n\ninterface CSSRuleList {\n    readonly length: number;\n    item(index: number): CSSRule | null;\n    [index: number]: CSSRule;\n}\n\ndeclare var CSSRuleList: {\n    prototype: CSSRuleList;\n    new(): CSSRuleList;\n};\n\ninterface CSSStyleDeclaration {\n    alignContent: string | null;\n    alignItems: string | null;\n    alignSelf: string | null;\n    alignmentBaseline: string | null;\n    animation: string;\n    animationDelay: string;\n    animationDirection: string;\n    animationDuration: string;\n    animationFillMode: string;\n    animationIterationCount: string;\n    animationName: string;\n    animationPlayState: string;\n    animationTimingFunction: string;\n    backfaceVisibility: string | null;\n    background: string | null;\n    backgroundAttachment: string | null;\n    backgroundClip: string | null;\n    backgroundColor: string | null;\n    backgroundImage: string | null;\n    backgroundOrigin: string | null;\n    backgroundPosition: string | null;\n    backgroundPositionX: string | null;\n    backgroundPositionY: string | null;\n    backgroundRepeat: string | null;\n    backgroundSize: string | null;\n    baselineShift: string | null;\n    border: string | null;\n    borderBottom: string | null;\n    borderBottomColor: string | null;\n    borderBottomLeftRadius: string | null;\n    borderBottomRightRadius: string | null;\n    borderBottomStyle: string | null;\n    borderBottomWidth: string | null;\n    borderCollapse: string | null;\n    borderColor: string | null;\n    borderImage: string | null;\n    borderImageOutset: string | null;\n    borderImageRepeat: string | null;\n    borderImageSlice: string | null;\n    borderImageSource: string | null;\n    borderImageWidth: string | null;\n    borderLeft: string | null;\n    borderLeftColor: string | null;\n    borderLeftStyle: string | null;\n    borderLeftWidth: string | null;\n    borderRadius: string | null;\n    borderRight: string | null;\n    borderRightColor: string | null;\n    borderRightStyle: string | null;\n    borderRightWidth: string | null;\n    borderSpacing: string | null;\n    borderStyle: string | null;\n    borderTop: string | null;\n    borderTopColor: string | null;\n    borderTopLeftRadius: string | null;\n    borderTopRightRadius: string | null;\n    borderTopStyle: string | null;\n    borderTopWidth: string | null;\n    borderWidth: string | null;\n    bottom: string | null;\n    boxShadow: string | null;\n    boxSizing: string | null;\n    breakAfter: string | null;\n    breakBefore: string | null;\n    breakInside: string | null;\n    captionSide: string | null;\n    clear: string | null;\n    clip: string | null;\n    clipPath: string | null;\n    clipRule: string | null;\n    color: string | null;\n    colorInterpolationFilters: string | null;\n    columnCount: any;\n    columnFill: string | null;\n    columnGap: any;\n    columnRule: string | null;\n    columnRuleColor: any;\n    columnRuleStyle: string | null;\n    columnRuleWidth: any;\n    columnSpan: string | null;\n    columnWidth: any;\n    columns: string | null;\n    content: string | null;\n    counterIncrement: string | null;\n    counterReset: string | null;\n    cssFloat: string | null;\n    cssText: string;\n    cursor: string | null;\n    direction: string | null;\n    display: string | null;\n    dominantBaseline: string | null;\n    emptyCells: string | null;\n    enableBackground: string | null;\n    fill: string | null;\n    fillOpacity: string | null;\n    fillRule: string | null;\n    filter: string | null;\n    flex: string | null;\n    flexBasis: string | null;\n    flexDirection: string | null;\n    flexFlow: string | null;\n    flexGrow: string | null;\n    flexShrink: string | null;\n    flexWrap: string | null;\n    floodColor: string | null;\n    floodOpacity: string | null;\n    font: string | null;\n    fontFamily: string | null;\n    fontFeatureSettings: string | null;\n    fontSize: string | null;\n    fontSizeAdjust: string | null;\n    fontStretch: string | null;\n    fontStyle: string | null;\n    fontVariant: string | null;\n    fontWeight: string | null;\n    gap: string | null;\n    glyphOrientationHorizontal: string | null;\n    glyphOrientationVertical: string | null;\n    grid: string | null;\n    gridArea: string | null;\n    gridAutoColumns: string | null;\n    gridAutoFlow: string | null;\n    gridAutoRows: string | null;\n    gridColumn: string | null;\n    gridColumnEnd: string | null;\n    gridColumnGap: string | null;\n    gridColumnStart: string | null;\n    gridGap: string | null;\n    gridRow: string | null;\n    gridRowEnd: string | null;\n    gridRowGap: string | null;\n    gridRowStart: string | null;\n    gridTemplate: string | null;\n    gridTemplateAreas: string | null;\n    gridTemplateColumns: string | null;\n    gridTemplateRows: string | null;\n    height: string | null;\n    imeMode: string | null;\n    justifyContent: string | null;\n    justifyItems: string | null;\n    justifySelf: string | null;\n    kerning: string | null;\n    layoutGrid: string | null;\n    layoutGridChar: string | null;\n    layoutGridLine: string | null;\n    layoutGridMode: string | null;\n    layoutGridType: string | null;\n    left: string | null;\n    readonly length: number;\n    letterSpacing: string | null;\n    lightingColor: string | null;\n    lineBreak: string | null;\n    lineHeight: string | null;\n    listStyle: string | null;\n    listStyleImage: string | null;\n    listStylePosition: string | null;\n    listStyleType: string | null;\n    margin: string | null;\n    marginBottom: string | null;\n    marginLeft: string | null;\n    marginRight: string | null;\n    marginTop: string | null;\n    marker: string | null;\n    markerEnd: string | null;\n    markerMid: string | null;\n    markerStart: string | null;\n    mask: string | null;\n    maskImage: string | null;\n    maxHeight: string | null;\n    maxWidth: string | null;\n    minHeight: string | null;\n    minWidth: string | null;\n    msContentZoomChaining: string | null;\n    msContentZoomLimit: string | null;\n    msContentZoomLimitMax: any;\n    msContentZoomLimitMin: any;\n    msContentZoomSnap: string | null;\n    msContentZoomSnapPoints: string | null;\n    msContentZoomSnapType: string | null;\n    msContentZooming: string | null;\n    msFlowFrom: string | null;\n    msFlowInto: string | null;\n    msFontFeatureSettings: string | null;\n    msGridColumn: any;\n    msGridColumnAlign: string | null;\n    msGridColumnSpan: any;\n    msGridColumns: string | null;\n    msGridRow: any;\n    msGridRowAlign: string | null;\n    msGridRowSpan: any;\n    msGridRows: string | null;\n    msHighContrastAdjust: string | null;\n    msHyphenateLimitChars: string | null;\n    msHyphenateLimitLines: any;\n    msHyphenateLimitZone: any;\n    msHyphens: string | null;\n    msImeAlign: string | null;\n    msOverflowStyle: string | null;\n    msScrollChaining: string | null;\n    msScrollLimit: string | null;\n    msScrollLimitXMax: any;\n    msScrollLimitXMin: any;\n    msScrollLimitYMax: any;\n    msScrollLimitYMin: any;\n    msScrollRails: string | null;\n    msScrollSnapPointsX: string | null;\n    msScrollSnapPointsY: string | null;\n    msScrollSnapType: string | null;\n    msScrollSnapX: string | null;\n    msScrollSnapY: string | null;\n    msScrollTranslation: string | null;\n    msTextCombineHorizontal: string | null;\n    msTextSizeAdjust: any;\n    msTouchAction: string | null;\n    msTouchSelect: string | null;\n    msUserSelect: string | null;\n    msWrapFlow: string;\n    msWrapMargin: any;\n    msWrapThrough: string;\n    objectFit: string | null;\n    objectPosition: string | null;\n    opacity: string | null;\n    order: string | null;\n    orphans: string | null;\n    outline: string | null;\n    outlineColor: string | null;\n    outlineOffset: string | null;\n    outlineStyle: string | null;\n    outlineWidth: string | null;\n    overflow: string | null;\n    overflowX: string | null;\n    overflowY: string | null;\n    padding: string | null;\n    paddingBottom: string | null;\n    paddingLeft: string | null;\n    paddingRight: string | null;\n    paddingTop: string | null;\n    pageBreakAfter: string | null;\n    pageBreakBefore: string | null;\n    pageBreakInside: string | null;\n    readonly parentRule: CSSRule;\n    penAction: string | null;\n    perspective: string | null;\n    perspectiveOrigin: string | null;\n    pointerEvents: string | null;\n    position: string | null;\n    quotes: string | null;\n    resize: string | null;\n    right: string | null;\n    rotate: string | null;\n    rowGap: string | null;\n    rubyAlign: string | null;\n    rubyOverhang: string | null;\n    rubyPosition: string | null;\n    scale: string | null;\n    scrollBehavior: string;\n    stopColor: string | null;\n    stopOpacity: string | null;\n    stroke: string | null;\n    strokeDasharray: string | null;\n    strokeDashoffset: string | null;\n    strokeLinecap: string | null;\n    strokeLinejoin: string | null;\n    strokeMiterlimit: string | null;\n    strokeOpacity: string | null;\n    strokeWidth: string | null;\n    tableLayout: string | null;\n    textAlign: string | null;\n    textAlignLast: string | null;\n    textAnchor: string | null;\n    textCombineUpright: string | null;\n    textDecoration: string | null;\n    textIndent: string | null;\n    textJustify: string | null;\n    textKashida: string | null;\n    textKashidaSpace: string | null;\n    textOverflow: string | null;\n    textShadow: string | null;\n    textTransform: string | null;\n    textUnderlinePosition: string | null;\n    top: string | null;\n    touchAction: string;\n    transform: string | null;\n    transformOrigin: string | null;\n    transformStyle: string | null;\n    transition: string;\n    transitionDelay: string;\n    transitionDuration: string;\n    transitionProperty: string;\n    transitionTimingFunction: string;\n    translate: string | null;\n    unicodeBidi: string | null;\n    userSelect: string | null;\n    verticalAlign: string | null;\n    visibility: string | null;\n    /** @deprecated */\n    webkitAlignContent: string;\n    /** @deprecated */\n    webkitAlignItems: string;\n    /** @deprecated */\n    webkitAlignSelf: string;\n    /** @deprecated */\n    webkitAnimation: string;\n    /** @deprecated */\n    webkitAnimationDelay: string;\n    /** @deprecated */\n    webkitAnimationDirection: string;\n    /** @deprecated */\n    webkitAnimationDuration: string;\n    /** @deprecated */\n    webkitAnimationFillMode: string;\n    /** @deprecated */\n    webkitAnimationIterationCount: string;\n    /** @deprecated */\n    webkitAnimationName: string;\n    /** @deprecated */\n    webkitAnimationPlayState: string;\n    /** @deprecated */\n    webkitAnimationTimingFunction: string;\n    /** @deprecated */\n    webkitAppearance: string;\n    /** @deprecated */\n    webkitBackfaceVisibility: string;\n    /** @deprecated */\n    webkitBackgroundClip: string;\n    /** @deprecated */\n    webkitBackgroundOrigin: string;\n    /** @deprecated */\n    webkitBackgroundSize: string;\n    /** @deprecated */\n    webkitBorderBottomLeftRadius: string;\n    /** @deprecated */\n    webkitBorderBottomRightRadius: string;\n    webkitBorderImage: string | null;\n    /** @deprecated */\n    webkitBorderRadius: string;\n    /** @deprecated */\n    webkitBorderTopLeftRadius: string;\n    /** @deprecated */\n    webkitBorderTopRightRadius: string;\n    /** @deprecated */\n    webkitBoxAlign: string;\n    webkitBoxDirection: string | null;\n    /** @deprecated */\n    webkitBoxFlex: string;\n    /** @deprecated */\n    webkitBoxOrdinalGroup: string;\n    webkitBoxOrient: string | null;\n    /** @deprecated */\n    webkitBoxPack: string;\n    /** @deprecated */\n    webkitBoxShadow: string;\n    /** @deprecated */\n    webkitBoxSizing: string;\n    webkitColumnBreakAfter: string | null;\n    webkitColumnBreakBefore: string | null;\n    webkitColumnBreakInside: string | null;\n    webkitColumnCount: any;\n    webkitColumnGap: any;\n    webkitColumnRule: string | null;\n    webkitColumnRuleColor: any;\n    webkitColumnRuleStyle: string | null;\n    webkitColumnRuleWidth: any;\n    webkitColumnSpan: string | null;\n    webkitColumnWidth: any;\n    webkitColumns: string | null;\n    /** @deprecated */\n    webkitFilter: string;\n    /** @deprecated */\n    webkitFlex: string;\n    /** @deprecated */\n    webkitFlexBasis: string;\n    /** @deprecated */\n    webkitFlexDirection: string;\n    /** @deprecated */\n    webkitFlexFlow: string;\n    /** @deprecated */\n    webkitFlexGrow: string;\n    /** @deprecated */\n    webkitFlexShrink: string;\n    /** @deprecated */\n    webkitFlexWrap: string;\n    /** @deprecated */\n    webkitJustifyContent: string;\n    /** @deprecated */\n    webkitMask: string;\n    /** @deprecated */\n    webkitMaskBoxImage: string;\n    /** @deprecated */\n    webkitMaskBoxImageOutset: string;\n    /** @deprecated */\n    webkitMaskBoxImageRepeat: string;\n    /** @deprecated */\n    webkitMaskBoxImageSlice: string;\n    /** @deprecated */\n    webkitMaskBoxImageSource: string;\n    /** @deprecated */\n    webkitMaskBoxImageWidth: string;\n    /** @deprecated */\n    webkitMaskClip: string;\n    /** @deprecated */\n    webkitMaskComposite: string;\n    /** @deprecated */\n    webkitMaskImage: string;\n    /** @deprecated */\n    webkitMaskOrigin: string;\n    /** @deprecated */\n    webkitMaskPosition: string;\n    /** @deprecated */\n    webkitMaskRepeat: string;\n    /** @deprecated */\n    webkitMaskSize: string;\n    /** @deprecated */\n    webkitOrder: string;\n    /** @deprecated */\n    webkitPerspective: string;\n    /** @deprecated */\n    webkitPerspectiveOrigin: string;\n    webkitTapHighlightColor: string | null;\n    /** @deprecated */\n    webkitTextFillColor: string;\n    /** @deprecated */\n    webkitTextSizeAdjust: string;\n    /** @deprecated */\n    webkitTextStroke: string;\n    /** @deprecated */\n    webkitTextStrokeColor: string;\n    /** @deprecated */\n    webkitTextStrokeWidth: string;\n    /** @deprecated */\n    webkitTransform: string;\n    /** @deprecated */\n    webkitTransformOrigin: string;\n    /** @deprecated */\n    webkitTransformStyle: string;\n    /** @deprecated */\n    webkitTransition: string;\n    /** @deprecated */\n    webkitTransitionDelay: string;\n    /** @deprecated */\n    webkitTransitionDuration: string;\n    /** @deprecated */\n    webkitTransitionProperty: string;\n    /** @deprecated */\n    webkitTransitionTimingFunction: string;\n    webkitUserModify: string | null;\n    webkitUserSelect: string | null;\n    webkitWritingMode: string | null;\n    whiteSpace: string | null;\n    widows: string | null;\n    width: string | null;\n    wordBreak: string | null;\n    wordSpacing: string | null;\n    wordWrap: string | null;\n    writingMode: string | null;\n    zIndex: string | null;\n    zoom: string | null;\n    getPropertyPriority(propertyName: string): string;\n    getPropertyValue(propertyName: string): string;\n    item(index: number): string;\n    removeProperty(propertyName: string): string;\n    setProperty(propertyName: string, value: string | null, priority?: string | null): void;\n    [index: number]: string;\n}\n\ndeclare var CSSStyleDeclaration: {\n    prototype: CSSStyleDeclaration;\n    new(): CSSStyleDeclaration;\n};\n\ninterface CSSStyleRule extends CSSRule {\n    selectorText: string;\n    readonly style: CSSStyleDeclaration;\n}\n\ndeclare var CSSStyleRule: {\n    prototype: CSSStyleRule;\n    new(): CSSStyleRule;\n};\n\ninterface CSSStyleSheet extends StyleSheet {\n    readonly cssRules: CSSRuleList;\n    /** @deprecated */\n    cssText: string;\n    /** @deprecated */\n    readonly id: string;\n    /** @deprecated */\n    readonly imports: StyleSheetList;\n    /** @deprecated */\n    readonly isAlternate: boolean;\n    /** @deprecated */\n    readonly isPrefAlternate: boolean;\n    readonly ownerRule: CSSRule | null;\n    /** @deprecated */\n    readonly owningElement: Element;\n    /** @deprecated */\n    readonly pages: any;\n    /** @deprecated */\n    readonly readOnly: boolean;\n    readonly rules: CSSRuleList;\n    /** @deprecated */\n    addImport(bstrURL: string, lIndex?: number): number;\n    /** @deprecated */\n    addPageRule(bstrSelector: string, bstrStyle: string, lIndex?: number): number;\n    addRule(bstrSelector: string, bstrStyle?: string, lIndex?: number): number;\n    deleteRule(index?: number): void;\n    insertRule(rule: string, index?: number): number;\n    /** @deprecated */\n    removeImport(lIndex: number): void;\n    removeRule(lIndex: number): void;\n}\n\ndeclare var CSSStyleSheet: {\n    prototype: CSSStyleSheet;\n    new(): CSSStyleSheet;\n};\n\ninterface CSSSupportsRule extends CSSConditionRule {\n}\n\ndeclare var CSSSupportsRule: {\n    prototype: CSSSupportsRule;\n    new(): CSSSupportsRule;\n};\n\ninterface Cache {\n    add(request: RequestInfo): Promise<void>;\n    addAll(requests: RequestInfo[]): Promise<void>;\n    delete(request: RequestInfo, options?: CacheQueryOptions): Promise<boolean>;\n    keys(request?: RequestInfo, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response | undefined>;\n    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n    put(request: RequestInfo, response: Response): Promise<void>;\n}\n\ndeclare var Cache: {\n    prototype: Cache;\n    new(): Cache;\n};\n\ninterface CacheStorage {\n    delete(cacheName: string): Promise<boolean>;\n    has(cacheName: string): Promise<boolean>;\n    keys(): Promise<string[]>;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response | undefined>;\n    open(cacheName: string): Promise<Cache>;\n}\n\ndeclare var CacheStorage: {\n    prototype: CacheStorage;\n    new(): CacheStorage;\n};\n\ninterface CanvasCompositing {\n    globalAlpha: number;\n    globalCompositeOperation: string;\n}\n\ninterface CanvasDrawImage {\n    drawImage(image: CanvasImageSource, dx: number, dy: number): void;\n    drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;\n    drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;\n}\n\ninterface CanvasDrawPath {\n    beginPath(): void;\n    clip(fillRule?: CanvasFillRule): void;\n    clip(path: Path2D, fillRule?: CanvasFillRule): void;\n    fill(fillRule?: CanvasFillRule): void;\n    fill(path: Path2D, fillRule?: CanvasFillRule): void;\n    isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean;\n    isPointInPath(path: Path2D, x: number, y: number, fillRule?: CanvasFillRule): boolean;\n    isPointInStroke(x: number, y: number): boolean;\n    isPointInStroke(path: Path2D, x: number, y: number): boolean;\n    stroke(): void;\n    stroke(path: Path2D): void;\n}\n\ninterface CanvasFillStrokeStyles {\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;\n    createPattern(image: CanvasImageSource, repetition: string): CanvasPattern | null;\n    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;\n}\n\ninterface CanvasFilters {\n    filter: string;\n}\n\ninterface CanvasGradient {\n    /**\n     * Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset\n     * at one end of the gradient, 1.0 is the offset at the other end.\n     * Throws an "IndexSizeError" DOMException if the offset\n     * is out of range. Throws a "SyntaxError" DOMException if\n     * the color cannot be parsed.\n     */\n    addColorStop(offset: number, color: string): void;\n}\n\ndeclare var CanvasGradient: {\n    prototype: CanvasGradient;\n    new(): CanvasGradient;\n};\n\ninterface CanvasImageData {\n    createImageData(sw: number, sh: number): ImageData;\n    createImageData(imagedata: ImageData): ImageData;\n    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;\n    putImageData(imagedata: ImageData, dx: number, dy: number): void;\n    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;\n}\n\ninterface CanvasImageSmoothing {\n    imageSmoothingEnabled: boolean;\n    imageSmoothingQuality: ImageSmoothingQuality;\n}\n\ninterface CanvasPath {\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n    closePath(): void;\n    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    lineTo(x: number, y: number): void;\n    moveTo(x: number, y: number): void;\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n    rect(x: number, y: number, w: number, h: number): void;\n}\n\ninterface CanvasPathDrawingStyles {\n    lineCap: CanvasLineCap;\n    lineDashOffset: number;\n    lineJoin: CanvasLineJoin;\n    lineWidth: number;\n    miterLimit: number;\n    getLineDash(): number[];\n    setLineDash(segments: number[]): void;\n}\n\ninterface CanvasPattern {\n    /**\n     * Sets the transformation matrix that will be used when rendering the pattern during a fill or\n     * stroke painting operation.\n     */\n    setTransform(transform?: DOMMatrix2DInit): void;\n}\n\ndeclare var CanvasPattern: {\n    prototype: CanvasPattern;\n    new(): CanvasPattern;\n};\n\ninterface CanvasRect {\n    clearRect(x: number, y: number, w: number, h: number): void;\n    fillRect(x: number, y: number, w: number, h: number): void;\n    strokeRect(x: number, y: number, w: number, h: number): void;\n}\n\ninterface CanvasRenderingContext2D extends CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath {\n    readonly canvas: HTMLCanvasElement;\n}\n\ndeclare var CanvasRenderingContext2D: {\n    prototype: CanvasRenderingContext2D;\n    new(): CanvasRenderingContext2D;\n};\n\ninterface CanvasShadowStyles {\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n}\n\ninterface CanvasState {\n    restore(): void;\n    save(): void;\n}\n\ninterface CanvasText {\n    fillText(text: string, x: number, y: number, maxWidth?: number): void;\n    measureText(text: string): TextMetrics;\n    strokeText(text: string, x: number, y: number, maxWidth?: number): void;\n}\n\ninterface CanvasTextDrawingStyles {\n    direction: CanvasDirection;\n    font: string;\n    textAlign: CanvasTextAlign;\n    textBaseline: CanvasTextBaseline;\n}\n\ninterface CanvasTransform {\n    getTransform(): DOMMatrix;\n    resetTransform(): void;\n    rotate(angle: number): void;\n    scale(x: number, y: number): void;\n    setTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;\n    setTransform(transform?: DOMMatrix2DInit): void;\n    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;\n    translate(x: number, y: number): void;\n}\n\ninterface CanvasUserInterface {\n    drawFocusIfNeeded(element: Element): void;\n    drawFocusIfNeeded(path: Path2D, element: Element): void;\n    scrollPathIntoView(): void;\n    scrollPathIntoView(path: Path2D): void;\n}\n\ninterface CaretPosition {\n    readonly offset: number;\n    readonly offsetNode: Node;\n    getClientRect(): DOMRect | null;\n}\n\ndeclare var CaretPosition: {\n    prototype: CaretPosition;\n    new(): CaretPosition;\n};\n\ninterface ChannelMergerNode extends AudioNode {\n}\n\ndeclare var ChannelMergerNode: {\n    prototype: ChannelMergerNode;\n    new(context: BaseAudioContext, options?: ChannelMergerOptions): ChannelMergerNode;\n};\n\ninterface ChannelSplitterNode extends AudioNode {\n}\n\ndeclare var ChannelSplitterNode: {\n    prototype: ChannelSplitterNode;\n    new(context: BaseAudioContext, options?: ChannelSplitterOptions): ChannelSplitterNode;\n};\n\ninterface CharacterData extends Node, NonDocumentTypeChildNode, ChildNode {\n    data: string;\n    readonly length: number;\n    appendData(data: string): void;\n    deleteData(offset: number, count: number): void;\n    insertData(offset: number, data: string): void;\n    replaceData(offset: number, count: number, data: string): void;\n    substringData(offset: number, count: number): string;\n}\n\ndeclare var CharacterData: {\n    prototype: CharacterData;\n    new(): CharacterData;\n};\n\ninterface ChildNode extends Node {\n    /**\n     * Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.\n     * Throws a "HierarchyRequestError" DOMException if the constraints of\n     * the node tree are violated.\n     */\n    after(...nodes: (Node | string)[]): void;\n    /**\n     * Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.\n     * Throws a "HierarchyRequestError" DOMException if the constraints of\n     * the node tree are violated.\n     */\n    before(...nodes: (Node | string)[]): void;\n    /**\n     * Removes node.\n     */\n    remove(): void;\n    /**\n     * Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.\n     * Throws a "HierarchyRequestError" DOMException if the constraints of\n     * the node tree are violated.\n     */\n    replaceWith(...nodes: (Node | string)[]): void;\n}\n\ninterface ClientRect {\n    bottom: number;\n    readonly height: number;\n    left: number;\n    right: number;\n    top: number;\n    readonly width: number;\n}\n\ndeclare var ClientRect: {\n    prototype: ClientRect;\n    new(): ClientRect;\n};\n\ninterface ClientRectList {\n    readonly length: number;\n    item(index: number): ClientRect;\n    [index: number]: ClientRect;\n}\n\ndeclare var ClientRectList: {\n    prototype: ClientRectList;\n    new(): ClientRectList;\n};\n\ninterface ClipboardEvent extends Event {\n    readonly clipboardData: DataTransfer;\n}\n\ndeclare var ClipboardEvent: {\n    prototype: ClipboardEvent;\n    new(type: string, eventInitDict?: ClipboardEventInit): ClipboardEvent;\n};\n\ninterface ClipboardEventInit extends EventInit {\n    data?: string;\n    dataType?: string;\n}\n\ninterface CloseEvent extends Event {\n    readonly code: number;\n    readonly reason: string;\n    readonly wasClean: boolean;\n    /** @deprecated */\n    initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;\n}\n\ndeclare var CloseEvent: {\n    prototype: CloseEvent;\n    new(type: string, eventInitDict?: CloseEventInit): CloseEvent;\n};\n\ninterface Comment extends CharacterData {\n}\n\ndeclare var Comment: {\n    prototype: Comment;\n    new(data?: string): Comment;\n};\n\ninterface CompositionEvent extends UIEvent {\n    readonly data: string;\n    readonly locale: string;\n    initCompositionEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, locale: string): void;\n}\n\ndeclare var CompositionEvent: {\n    prototype: CompositionEvent;\n    new(typeArg: string, eventInitDict?: CompositionEventInit): CompositionEvent;\n};\n\ninterface ConcatParams extends Algorithm {\n    algorithmId: Uint8Array;\n    hash?: string | Algorithm;\n    partyUInfo: Uint8Array;\n    partyVInfo: Uint8Array;\n    privateInfo?: Uint8Array;\n    publicInfo?: Uint8Array;\n}\n\ninterface Console {\n    memory: any;\n    assert(condition?: boolean, message?: string, ...data: any[]): void;\n    clear(): void;\n    count(label?: string): void;\n    debug(message?: any, ...optionalParams: any[]): void;\n    dir(value?: any, ...optionalParams: any[]): void;\n    dirxml(value: any): void;\n    error(message?: any, ...optionalParams: any[]): void;\n    exception(message?: string, ...optionalParams: any[]): void;\n    group(groupTitle?: string, ...optionalParams: any[]): void;\n    groupCollapsed(groupTitle?: string, ...optionalParams: any[]): void;\n    groupEnd(): void;\n    info(message?: any, ...optionalParams: any[]): void;\n    log(message?: any, ...optionalParams: any[]): void;\n    markTimeline(label?: string): void;\n    profile(reportName?: string): void;\n    profileEnd(reportName?: string): void;\n    table(...tabularData: any[]): void;\n    time(label?: string): void;\n    timeEnd(label?: string): void;\n    timeStamp(label?: string): void;\n    timeline(label?: string): void;\n    timelineEnd(label?: string): void;\n    trace(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n}\n\ndeclare var Console: {\n    prototype: Console;\n    new(): Console;\n};\n\ninterface ConstantSourceNode extends AudioScheduledSourceNode {\n    readonly offset: AudioParam;\n    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: ConstantSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: ConstantSourceNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ConstantSourceNode: {\n    prototype: ConstantSourceNode;\n    new(context: BaseAudioContext, options?: ConstantSourceOptions): ConstantSourceNode;\n};\n\ninterface ConvolverNode extends AudioNode {\n    buffer: AudioBuffer | null;\n    normalize: boolean;\n}\n\ndeclare var ConvolverNode: {\n    prototype: ConvolverNode;\n    new(context: BaseAudioContext, options?: ConvolverOptions): ConvolverNode;\n};\n\ninterface Coordinates {\n    readonly accuracy: number;\n    readonly altitude: number | null;\n    readonly altitudeAccuracy: number | null;\n    readonly heading: number | null;\n    readonly latitude: number;\n    readonly longitude: number;\n    readonly speed: number | null;\n}\n\ninterface CountQueuingStrategy extends QueuingStrategy {\n    highWaterMark: number;\n    size(chunk: any): 1;\n}\n\ndeclare var CountQueuingStrategy: {\n    prototype: CountQueuingStrategy;\n    new(options: { highWaterMark: number }): CountQueuingStrategy;\n};\n\ninterface Crypto {\n    readonly subtle: SubtleCrypto;\n    getRandomValues<T extends Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | null>(array: T): T;\n}\n\ndeclare var Crypto: {\n    prototype: Crypto;\n    new(): Crypto;\n};\n\ninterface CryptoKey {\n    readonly algorithm: KeyAlgorithm;\n    readonly extractable: boolean;\n    readonly type: KeyType;\n    readonly usages: KeyUsage[];\n}\n\ndeclare var CryptoKey: {\n    prototype: CryptoKey;\n    new(): CryptoKey;\n};\n\ninterface CryptoKeyPair {\n    privateKey: CryptoKey;\n    publicKey: CryptoKey;\n}\n\ndeclare var CryptoKeyPair: {\n    prototype: CryptoKeyPair;\n    new(): CryptoKeyPair;\n};\n\ninterface CustomElementRegistry {\n    define(name: string, constructor: Function, options?: ElementDefinitionOptions): void;\n    get(name: string): any;\n    upgrade(root: Node): void;\n    whenDefined(name: string): Promise<void>;\n}\n\ndeclare var CustomElementRegistry: {\n    prototype: CustomElementRegistry;\n    new(): CustomElementRegistry;\n};\n\ninterface CustomEvent<T = any> extends Event {\n    /**\n     * Returns any custom data event was created with.\n     * Typically used for synthetic events.\n     */\n    readonly detail: T;\n    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;\n}\n\ndeclare var CustomEvent: {\n    prototype: CustomEvent;\n    new<T>(typeArg: string, eventInitDict?: CustomEventInit<T>): CustomEvent<T>;\n};\n\ninterface DOMError {\n    readonly name: string;\n    toString(): string;\n}\n\ndeclare var DOMError: {\n    prototype: DOMError;\n    new(): DOMError;\n};\n\ninterface DOMException {\n    readonly code: number;\n    readonly message: string;\n    readonly name: string;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n}\n\ndeclare var DOMException: {\n    prototype: DOMException;\n    new(message?: string, name?: string): DOMException;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n};\n\ninterface DOMImplementation {\n    createDocument(namespaceURI: string | null, qualifiedName: string | null, doctype: DocumentType | null): Document;\n    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;\n    createHTMLDocument(title?: string): Document;\n    /** @deprecated */\n    hasFeature(...args: any[]): true;\n}\n\ndeclare var DOMImplementation: {\n    prototype: DOMImplementation;\n    new(): DOMImplementation;\n};\n\ninterface DOML2DeprecatedColorProperty {\n    color: string;\n}\n\ninterface DOMMatrix extends DOMMatrixReadOnly {\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n    e: number;\n    f: number;\n    m11: number;\n    m12: number;\n    m13: number;\n    m14: number;\n    m21: number;\n    m22: number;\n    m23: number;\n    m24: number;\n    m31: number;\n    m32: number;\n    m33: number;\n    m34: number;\n    m41: number;\n    m42: number;\n    m43: number;\n    m44: number;\n    invertSelf(): DOMMatrix;\n    multiplySelf(other?: DOMMatrixInit): DOMMatrix;\n    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;\n    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;\n    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;\n    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;\n    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    setMatrixValue(transformList: string): DOMMatrix;\n    skewXSelf(sx?: number): DOMMatrix;\n    skewYSelf(sy?: number): DOMMatrix;\n    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;\n}\n\ndeclare var DOMMatrix: {\n    prototype: DOMMatrix;\n    new(init?: string | number[]): DOMMatrix;\n    fromFloat32Array(array32: Float32Array): DOMMatrix;\n    fromFloat64Array(array64: Float64Array): DOMMatrix;\n    fromMatrix(other?: DOMMatrixInit): DOMMatrix;\n};\n\ntype SVGMatrix = DOMMatrix;\ndeclare var SVGMatrix: typeof DOMMatrix;\n\ntype WebKitCSSMatrix = DOMMatrix;\ndeclare var WebKitCSSMatrix: typeof DOMMatrix;\n\ninterface DOMMatrixReadOnly {\n    readonly a: number;\n    readonly b: number;\n    readonly c: number;\n    readonly d: number;\n    readonly e: number;\n    readonly f: number;\n    readonly is2D: boolean;\n    readonly isIdentity: boolean;\n    readonly m11: number;\n    readonly m12: number;\n    readonly m13: number;\n    readonly m14: number;\n    readonly m21: number;\n    readonly m22: number;\n    readonly m23: number;\n    readonly m24: number;\n    readonly m31: number;\n    readonly m32: number;\n    readonly m33: number;\n    readonly m34: number;\n    readonly m41: number;\n    readonly m42: number;\n    readonly m43: number;\n    readonly m44: number;\n    flipX(): DOMMatrix;\n    flipY(): DOMMatrix;\n    inverse(): DOMMatrix;\n    multiply(other?: DOMMatrixInit): DOMMatrix;\n    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;\n    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;\n    rotateFromVector(x?: number, y?: number): DOMMatrix;\n    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    skewX(sx?: number): DOMMatrix;\n    skewY(sy?: number): DOMMatrix;\n    toFloat32Array(): Float32Array;\n    toFloat64Array(): Float64Array;\n    toJSON(): any;\n    transformPoint(point?: DOMPointInit): DOMPoint;\n    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;\n}\n\ndeclare var DOMMatrixReadOnly: {\n    prototype: DOMMatrixReadOnly;\n    new(init?: string | number[]): DOMMatrixReadOnly;\n    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;\n    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;\n    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;\n};\n\ninterface DOMParser {\n    parseFromString(str: string, type: SupportedType): Document;\n}\n\ndeclare var DOMParser: {\n    prototype: DOMParser;\n    new(): DOMParser;\n};\n\ninterface DOMPoint extends DOMPointReadOnly {\n    w: number;\n    x: number;\n    y: number;\n    z: number;\n}\n\ndeclare var DOMPoint: {\n    prototype: DOMPoint;\n    new(x?: number, y?: number, z?: number, w?: number): DOMPoint;\n    fromPoint(other?: DOMPointInit): DOMPoint;\n};\n\ntype SVGPoint = DOMPoint;\ndeclare var SVGPoint: typeof DOMPoint;\n\ninterface DOMPointReadOnly {\n    readonly w: number;\n    readonly x: number;\n    readonly y: number;\n    readonly z: number;\n    matrixTransform(matrix?: DOMMatrixInit): DOMPoint;\n    toJSON(): any;\n}\n\ndeclare var DOMPointReadOnly: {\n    prototype: DOMPointReadOnly;\n    new(x?: number, y?: number, z?: number, w?: number): DOMPointReadOnly;\n    fromPoint(other?: DOMPointInit): DOMPointReadOnly;\n};\n\ninterface DOMQuad {\n    readonly p1: DOMPoint;\n    readonly p2: DOMPoint;\n    readonly p3: DOMPoint;\n    readonly p4: DOMPoint;\n    getBounds(): DOMRect;\n    toJSON(): any;\n}\n\ndeclare var DOMQuad: {\n    prototype: DOMQuad;\n    new(p1?: DOMPointInit, p2?: DOMPointInit, p3?: DOMPointInit, p4?: DOMPointInit): DOMQuad;\n    fromQuad(other?: DOMQuadInit): DOMQuad;\n    fromRect(other?: DOMRectInit): DOMQuad;\n};\n\ninterface DOMRect extends DOMRectReadOnly {\n    height: number;\n    width: number;\n    x: number;\n    y: number;\n}\n\ndeclare var DOMRect: {\n    prototype: DOMRect;\n    new(x?: number, y?: number, width?: number, height?: number): DOMRect;\n    fromRect(other?: DOMRectInit): DOMRect;\n};\n\ntype SVGRect = DOMRect;\ndeclare var SVGRect: typeof DOMRect;\n\ninterface DOMRectList {\n    readonly length: number;\n    item(index: number): DOMRect | null;\n    [index: number]: DOMRect;\n}\n\ndeclare var DOMRectList: {\n    prototype: DOMRectList;\n    new(): DOMRectList;\n};\n\ninterface DOMRectReadOnly {\n    readonly bottom: number;\n    readonly height: number;\n    readonly left: number;\n    readonly right: number;\n    readonly top: number;\n    readonly width: number;\n    readonly x: number;\n    readonly y: number;\n    toJSON(): any;\n}\n\ndeclare var DOMRectReadOnly: {\n    prototype: DOMRectReadOnly;\n    new(x?: number, y?: number, width?: number, height?: number): DOMRectReadOnly;\n    fromRect(other?: DOMRectInit): DOMRectReadOnly;\n};\n\ninterface DOMSettableTokenList extends DOMTokenList {\n    value: string;\n}\n\ndeclare var DOMSettableTokenList: {\n    prototype: DOMSettableTokenList;\n    new(): DOMSettableTokenList;\n};\n\ninterface DOMStringList {\n    /**\n     * Returns the number of strings in strings.\n     */\n    readonly length: number;\n    /**\n     * Returns true if strings contains string, and false\n     * otherwise.\n     */\n    contains(string: string): boolean;\n    /**\n     * Returns the string with index index from strings.\n     */\n    item(index: number): string | null;\n    [index: number]: string;\n}\n\ndeclare var DOMStringList: {\n    prototype: DOMStringList;\n    new(): DOMStringList;\n};\n\ninterface DOMStringMap {\n    [name: string]: string | undefined;\n}\n\ndeclare var DOMStringMap: {\n    prototype: DOMStringMap;\n    new(): DOMStringMap;\n};\n\ninterface DOMTokenList {\n    /**\n     * Returns the number of tokens.\n     */\n    readonly length: number;\n    /**\n     * Returns the associated set as string.\n     * Can be set, to change the associated attribute.\n     */\n    value: string;\n    /**\n     * Adds all arguments passed, except those already present.\n     * Throws a "SyntaxError" DOMException if one of the arguments is the empty\n     * string.\n     * Throws an "InvalidCharacterError" DOMException if one of the arguments\n     * contains any ASCII whitespace.\n     */\n    add(...tokens: string[]): void;\n    /**\n     * Returns true if token is present, and false otherwise.\n     */\n    contains(token: string): boolean;\n    /**\n     * tokenlist[index]\n     */\n    item(index: number): string | null;\n    /**\n     * Removes arguments passed, if they are present.\n     * Throws a "SyntaxError" DOMException if one of the arguments is the empty\n     * string.\n     * Throws an "InvalidCharacterError" DOMException if one of the arguments\n     * contains any ASCII whitespace.\n     */\n    remove(...tokens: string[]): void;\n    /**\n     * Replaces token with newToken.\n     * Returns true if token was replaced with newToken, and false otherwise.\n     * Throws a "SyntaxError" DOMException if one of the arguments is the empty\n     * string.\n     * Throws an "InvalidCharacterError" DOMException if one of the arguments\n     * contains any ASCII whitespace.\n     */\n    replace(oldToken: string, newToken: string): void;\n    /**\n     * Returns true if token is in the associated attribute\'s supported tokens. Returns\n     * false otherwise.\n     * Throws a TypeError if the associated attribute has no supported tokens defined.\n     */\n    supports(token: string): boolean;\n    toggle(token: string, force?: boolean): boolean;\n    forEach(callbackfn: (value: string, key: number, parent: DOMTokenList) => void, thisArg?: any): void;\n    [index: number]: string;\n}\n\ndeclare var DOMTokenList: {\n    prototype: DOMTokenList;\n    new(): DOMTokenList;\n};\n\ninterface DataCue extends TextTrackCue {\n    data: ArrayBuffer;\n    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: DataCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: DataCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var DataCue: {\n    prototype: DataCue;\n    new(): DataCue;\n};\n\ninterface DataTransfer {\n    dropEffect: string;\n    effectAllowed: string;\n    /**\n     * Returns a FileList of the files being dragged, if any.\n     */\n    readonly files: FileList;\n    /**\n     * Returns a DataTransferItemList object, with the drag data.\n     */\n    readonly items: DataTransferItemList;\n    /**\n     * Returns a frozen array listing the formats that were set in the dragstart event. In addition, if any files are being\n     * dragged, then one of the types will be the string "Files".\n     */\n    readonly types: ReadonlyArray<string>;\n    /**\n     * Removes the data of the specified formats. Removes all data if the argument is omitted.\n     */\n    clearData(format?: string): void;\n    /**\n     * Returns the specified data. If there is no such data, returns the empty string.\n     */\n    getData(format: string): string;\n    /**\n     * Adds the specified data.\n     */\n    setData(format: string, data: string): void;\n    /**\n     * Uses the given element to update the drag feedback, replacing any previously specified\n     * feedback.\n     */\n    setDragImage(image: Element, x: number, y: number): void;\n}\n\ndeclare var DataTransfer: {\n    prototype: DataTransfer;\n    new(): DataTransfer;\n};\n\ninterface DataTransferItem {\n    /**\n     * Returns the drag data item kind, one of: "string",\n     * "file".\n     */\n    readonly kind: string;\n    /**\n     * Returns the drag data item type string.\n     */\n    readonly type: string;\n    /**\n     * Returns a File object, if the drag data item kind is File.\n     */\n    getAsFile(): File | null;\n    /**\n     * Invokes the callback with the string data as the argument, if the drag data item\n     * kind is Plain Unicode string.\n     */\n    getAsString(callback: FunctionStringCallback | null): void;\n    webkitGetAsEntry(): any;\n}\n\ndeclare var DataTransferItem: {\n    prototype: DataTransferItem;\n    new(): DataTransferItem;\n};\n\ninterface DataTransferItemList {\n    /**\n     * Returns the number of items in the drag data store.\n     */\n    readonly length: number;\n    /**\n     * Adds a new entry for the given data to the drag data store. If the data is plain\n     * text  then a type string has to be provided\n     * also.\n     */\n    add(data: string, type: string): DataTransferItem | null;\n    add(data: File): DataTransferItem | null;\n    /**\n     * Removes all the entries in the drag data store.\n     */\n    clear(): void;\n    item(index: number): DataTransferItem;\n    /**\n     * Removes the indexth entry in the drag data store.\n     */\n    remove(index: number): void;\n    [name: number]: DataTransferItem;\n}\n\ndeclare var DataTransferItemList: {\n    prototype: DataTransferItemList;\n    new(): DataTransferItemList;\n};\n\ninterface DeferredPermissionRequest {\n    readonly id: number;\n    readonly type: MSWebViewPermissionType;\n    readonly uri: string;\n    allow(): void;\n    deny(): void;\n}\n\ndeclare var DeferredPermissionRequest: {\n    prototype: DeferredPermissionRequest;\n    new(): DeferredPermissionRequest;\n};\n\ninterface DelayNode extends AudioNode {\n    readonly delayTime: AudioParam;\n}\n\ndeclare var DelayNode: {\n    prototype: DelayNode;\n    new(context: BaseAudioContext, options?: DelayOptions): DelayNode;\n};\n\ninterface DeviceAcceleration {\n    readonly x: number | null;\n    readonly y: number | null;\n    readonly z: number | null;\n}\n\ndeclare var DeviceAcceleration: {\n    prototype: DeviceAcceleration;\n    new(): DeviceAcceleration;\n};\n\ninterface DeviceLightEvent extends Event {\n    readonly value: number;\n}\n\ndeclare var DeviceLightEvent: {\n    prototype: DeviceLightEvent;\n    new(typeArg: string, eventInitDict?: DeviceLightEventInit): DeviceLightEvent;\n};\n\ninterface DeviceMotionEvent extends Event {\n    readonly acceleration: DeviceAcceleration | null;\n    readonly accelerationIncludingGravity: DeviceAcceleration | null;\n    readonly interval: number | null;\n    readonly rotationRate: DeviceRotationRate | null;\n    initDeviceMotionEvent(type: string, bubbles: boolean, cancelable: boolean, acceleration: DeviceAccelerationDict | null, accelerationIncludingGravity: DeviceAccelerationDict | null, rotationRate: DeviceRotationRateDict | null, interval: number | null): void;\n}\n\ndeclare var DeviceMotionEvent: {\n    prototype: DeviceMotionEvent;\n    new(typeArg: string, eventInitDict?: DeviceMotionEventInit): DeviceMotionEvent;\n};\n\ninterface DeviceOrientationEvent extends Event {\n    readonly absolute: boolean;\n    readonly alpha: number | null;\n    readonly beta: number | null;\n    readonly gamma: number | null;\n    initDeviceOrientationEvent(type: string, bubbles: boolean, cancelable: boolean, alpha: number | null, beta: number | null, gamma: number | null, absolute: boolean): void;\n}\n\ndeclare var DeviceOrientationEvent: {\n    prototype: DeviceOrientationEvent;\n    new(typeArg: string, eventInitDict?: DeviceOrientationEventInit): DeviceOrientationEvent;\n};\n\ninterface DeviceRotationRate {\n    readonly alpha: number | null;\n    readonly beta: number | null;\n    readonly gamma: number | null;\n}\n\ndeclare var DeviceRotationRate: {\n    prototype: DeviceRotationRate;\n    new(): DeviceRotationRate;\n};\n\ninterface DhImportKeyParams extends Algorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface DhKeyAlgorithm extends KeyAlgorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface DhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface DhKeyGenParams extends Algorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface DocumentEventMap extends GlobalEventHandlersEventMap, DocumentAndElementEventHandlersEventMap {\n    "fullscreenchange": Event;\n    "fullscreenerror": Event;\n    "readystatechange": ProgressEvent;\n    "visibilitychange": Event;\n}\n\ninterface Document extends Node, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GlobalEventHandlers, DocumentAndElementEventHandlers {\n    /**\n     * Sets or gets the URL for the current document.\n     */\n    readonly URL: string;\n    /**\n     * Gets the object that has the focus when the parent document has focus.\n     */\n    readonly activeElement: Element | null;\n    /**\n     * Sets or gets the color of all active links in the document.\n     */\n    /** @deprecated */\n    alinkColor: string;\n    /**\n     * Returns a reference to the collection of elements contained by the object.\n     */\n    /** @deprecated */\n    readonly all: HTMLAllCollection;\n    /**\n     * Retrieves a collection of all a objects that have a name and/or id property. Objects in this collection are in HTML source order.\n     */\n    /** @deprecated */\n    readonly anchors: HTMLCollectionOf<HTMLAnchorElement>;\n    /**\n     * Retrieves a collection of all applet objects in the document.\n     */\n    /** @deprecated */\n    readonly applets: HTMLCollectionOf<HTMLAppletElement>;\n    /**\n     * Deprecated. Sets or retrieves a value that indicates the background color behind the object.\n     */\n    /** @deprecated */\n    bgColor: string;\n    /**\n     * Specifies the beginning and end of the document body.\n     */\n    body: HTMLElement;\n    /**\n     * Returns document\'s encoding.\n     */\n    readonly characterSet: string;\n    /**\n     * Gets or sets the character set used to encode the object.\n     */\n    readonly charset: string;\n    /**\n     * Gets a value that indicates whether standards-compliant mode is switched on for the object.\n     */\n    readonly compatMode: string;\n    /**\n     * Returns document\'s content type.\n     */\n    readonly contentType: string;\n    /**\n     * Returns the HTTP cookies that apply to the Document. If there are no cookies or\n     * cookies can\'t be applied to this resource, the empty string will be returned.\n     * Can be set, to add a new cookie to the element\'s set of HTTP cookies.\n     * If the contents are sandboxed into a\n     * unique origin (e.g. in an iframe with the sandbox attribute), a\n     * "SecurityError" DOMException will be thrown on getting\n     * and setting.\n     */\n    cookie: string;\n    /**\n     * Returns the script element, or the SVG script element,\n     * that is currently executing, as long as the element represents a classic script.\n     * In the case of reentrant script execution, returns the one that most recently started executing\n     * amongst those that have not yet finished executing.\n     * Returns null if the Document is not currently executing a script\n     * or SVG script element (e.g., because the running script is an event\n     * handler, or a timeout), or if the currently executing script or SVG\n     * script element represents a module script.\n     */\n    readonly currentScript: HTMLOrSVGScriptElement | null;\n    readonly defaultView: WindowProxy | null;\n    /**\n     * Sets or gets a value that indicates whether the document can be edited.\n     */\n    designMode: string;\n    /**\n     * Sets or retrieves a value that indicates the reading order of the object.\n     */\n    dir: string;\n    /**\n     * Gets an object representing the document type declaration associated with the current document.\n     */\n    readonly doctype: DocumentType | null;\n    /**\n     * Gets a reference to the root node of the document.\n     */\n    readonly documentElement: HTMLElement;\n    /**\n     * Returns document\'s URL.\n     */\n    readonly documentURI: string;\n    /**\n     * Sets or gets the security domain of the document.\n     */\n    domain: string;\n    /**\n     * Retrieves a collection of all embed objects in the document.\n     */\n    readonly embeds: HTMLCollectionOf<HTMLEmbedElement>;\n    /**\n     * Sets or gets the foreground (text) color of the document.\n     */\n    /** @deprecated */\n    fgColor: string;\n    /**\n     * Retrieves a collection, in source order, of all form objects in the document.\n     */\n    readonly forms: HTMLCollectionOf<HTMLFormElement>;\n    /** @deprecated */\n    readonly fullscreen: boolean;\n    /**\n     * Returns true if document has the ability to display elements fullscreen\n     * and fullscreen is supported, or false otherwise.\n     */\n    readonly fullscreenEnabled: boolean;\n    /**\n     * Returns the head element.\n     */\n    readonly head: HTMLHeadElement;\n    readonly hidden: boolean;\n    /**\n     * Retrieves a collection, in source order, of img objects in the document.\n     */\n    readonly images: HTMLCollectionOf<HTMLImageElement>;\n    /**\n     * Gets the implementation object of the current document.\n     */\n    readonly implementation: DOMImplementation;\n    /**\n     * Returns the character encoding used to create the webpage that is loaded into the document object.\n     */\n    readonly inputEncoding: string;\n    /**\n     * Gets the date that the page was last modified, if the page supplies one.\n     */\n    readonly lastModified: string;\n    /**\n     * Sets or gets the color of the document links.\n     */\n    /** @deprecated */\n    linkColor: string;\n    /**\n     * Retrieves a collection of all a objects that specify the href property and all area objects in the document.\n     */\n    readonly links: HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>;\n    /**\n     * Contains information about the current URL.\n     */\n    location: Location;\n    onfullscreenchange: ((this: Document, ev: Event) => any) | null;\n    onfullscreenerror: ((this: Document, ev: Event) => any) | null;\n    /**\n     * Fires when the state of the object has changed.\n     * @param ev The event\n     */\n    onreadystatechange: ((this: Document, ev: ProgressEvent) => any) | null;\n    onvisibilitychange: ((this: Document, ev: Event) => any) | null;\n    /**\n     * Returns document\'s origin.\n     */\n    readonly origin: string;\n    /**\n     * Return an HTMLCollection of the embed elements in the Document.\n     */\n    readonly plugins: HTMLCollectionOf<HTMLEmbedElement>;\n    /**\n     * Retrieves a value that indicates the current state of the object.\n     */\n    readonly readyState: DocumentReadyState;\n    /**\n     * Gets the URL of the location that referred the user to the current page.\n     */\n    readonly referrer: string;\n    /**\n     * Retrieves a collection of all script objects in the document.\n     */\n    readonly scripts: HTMLCollectionOf<HTMLScriptElement>;\n    readonly scrollingElement: Element | null;\n    readonly timeline: DocumentTimeline;\n    /**\n     * Contains the title of the document.\n     */\n    title: string;\n    readonly visibilityState: VisibilityState;\n    /**\n     * Sets or gets the color of the links that the user has visited.\n     */\n    /** @deprecated */\n    vlinkColor: string;\n    /**\n     * Moves node from another document and returns it.\n     * If node is a document, throws a "NotSupportedError" DOMException or, if node is a shadow root, throws a\n     * "HierarchyRequestError" DOMException.\n     */\n    adoptNode<T extends Node>(source: T): T;\n    /** @deprecated */\n    captureEvents(): void;\n    caretPositionFromPoint(x: number, y: number): CaretPosition | null;\n    /** @deprecated */\n    caretRangeFromPoint(x: number, y: number): Range;\n    /** @deprecated */\n    clear(): void;\n    /**\n     * Closes an output stream and forces the sent data to display.\n     */\n    close(): void;\n    /**\n     * Creates an attribute object with a specified name.\n     * @param name String that sets the attribute object\'s name.\n     */\n    createAttribute(localName: string): Attr;\n    createAttributeNS(namespace: string | null, qualifiedName: string): Attr;\n    /**\n     * Returns a CDATASection node whose data is data.\n     */\n    createCDATASection(data: string): CDATASection;\n    /**\n     * Creates a comment object with the specified data.\n     * @param data Sets the comment object\'s data.\n     */\n    createComment(data: string): Comment;\n    /**\n     * Creates a new document.\n     */\n    createDocumentFragment(): DocumentFragment;\n    /**\n     * Creates an instance of the element for the specified tag.\n     * @param tagName The name of an element.\n     */\n    createElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];\n    /** @deprecated */\n    createElement<K extends keyof HTMLElementDeprecatedTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementDeprecatedTagNameMap[K];\n    createElement(tagName: string, options?: ElementCreationOptions): HTMLElement;\n    /**\n     * Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after\n     * ":" (U+003E) in qualifiedName or qualifiedName.\n     * If localName does not match the Name production an\n     * "InvalidCharacterError" DOMException will be thrown.\n     * If one of the following conditions is true a "NamespaceError" DOMException will be thrown:\n     * localName does not match the QName production.\n     * Namespace prefix is not null and namespace is the empty string.\n     * Namespace prefix is "xml" and namespace is not the XML namespace.\n     * qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.\n     * namespace is the XMLNS namespace and\n     * neither qualifiedName nor namespace prefix is "xmlns".\n     * When supplied, options\'s is can be used to create a customized built-in element.\n     */\n    createElementNS(namespaceURI: "http://www.w3.org/1999/xhtml", qualifiedName: string): HTMLElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "a"): SVGAElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "circle"): SVGCircleElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "clipPath"): SVGClipPathElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "componentTransferFunction"): SVGComponentTransferFunctionElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "cursor"): SVGCursorElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "defs"): SVGDefsElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "desc"): SVGDescElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "ellipse"): SVGEllipseElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feBlend"): SVGFEBlendElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feColorMatrix"): SVGFEColorMatrixElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feComponentTransfer"): SVGFEComponentTransferElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feComposite"): SVGFECompositeElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feConvolveMatrix"): SVGFEConvolveMatrixElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feDiffuseLighting"): SVGFEDiffuseLightingElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feDisplacementMap"): SVGFEDisplacementMapElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feDistantLight"): SVGFEDistantLightElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feFlood"): SVGFEFloodElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feFuncA"): SVGFEFuncAElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feFuncB"): SVGFEFuncBElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feFuncG"): SVGFEFuncGElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feFuncR"): SVGFEFuncRElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feGaussianBlur"): SVGFEGaussianBlurElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feImage"): SVGFEImageElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feMerge"): SVGFEMergeElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feMergeNode"): SVGFEMergeNodeElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feMorphology"): SVGFEMorphologyElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feOffset"): SVGFEOffsetElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "fePointLight"): SVGFEPointLightElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feSpecularLighting"): SVGFESpecularLightingElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feSpotLight"): SVGFESpotLightElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feTile"): SVGFETileElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "feTurbulence"): SVGFETurbulenceElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "filter"): SVGFilterElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "foreignObject"): SVGForeignObjectElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "g"): SVGGElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "image"): SVGImageElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "gradient"): SVGGradientElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "line"): SVGLineElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "linearGradient"): SVGLinearGradientElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "marker"): SVGMarkerElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "mask"): SVGMaskElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "path"): SVGPathElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "metadata"): SVGMetadataElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "pattern"): SVGPatternElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "polygon"): SVGPolygonElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "polyline"): SVGPolylineElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "radialGradient"): SVGRadialGradientElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "rect"): SVGRectElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "svg"): SVGSVGElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "script"): SVGScriptElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "stop"): SVGStopElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "style"): SVGStyleElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "switch"): SVGSwitchElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "symbol"): SVGSymbolElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "tspan"): SVGTSpanElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "textContent"): SVGTextContentElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "text"): SVGTextElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "textPath"): SVGTextPathElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "textPositioning"): SVGTextPositioningElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "title"): SVGTitleElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "use"): SVGUseElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: "view"): SVGViewElement;\n    createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: string): SVGElement;\n    createElementNS(namespaceURI: string | null, qualifiedName: string, options?: ElementCreationOptions): Element;\n    createElementNS(namespace: string | null, qualifiedName: string, options?: string | ElementCreationOptions): Element;\n    createEvent(eventInterface: "AnimationEvent"): AnimationEvent;\n    createEvent(eventInterface: "AnimationPlaybackEvent"): AnimationPlaybackEvent;\n    createEvent(eventInterface: "AudioProcessingEvent"): AudioProcessingEvent;\n    createEvent(eventInterface: "BeforeUnloadEvent"): BeforeUnloadEvent;\n    createEvent(eventInterface: "ClipboardEvent"): ClipboardEvent;\n    createEvent(eventInterface: "CloseEvent"): CloseEvent;\n    createEvent(eventInterface: "CompositionEvent"): CompositionEvent;\n    createEvent(eventInterface: "CustomEvent"): CustomEvent;\n    createEvent(eventInterface: "DeviceLightEvent"): DeviceLightEvent;\n    createEvent(eventInterface: "DeviceMotionEvent"): DeviceMotionEvent;\n    createEvent(eventInterface: "DeviceOrientationEvent"): DeviceOrientationEvent;\n    createEvent(eventInterface: "DragEvent"): DragEvent;\n    createEvent(eventInterface: "ErrorEvent"): ErrorEvent;\n    createEvent(eventInterface: "Event"): Event;\n    createEvent(eventInterface: "Events"): Event;\n    createEvent(eventInterface: "FocusEvent"): FocusEvent;\n    createEvent(eventInterface: "FocusNavigationEvent"): FocusNavigationEvent;\n    createEvent(eventInterface: "GamepadEvent"): GamepadEvent;\n    createEvent(eventInterface: "HashChangeEvent"): HashChangeEvent;\n    createEvent(eventInterface: "IDBVersionChangeEvent"): IDBVersionChangeEvent;\n    createEvent(eventInterface: "KeyboardEvent"): KeyboardEvent;\n    createEvent(eventInterface: "ListeningStateChangedEvent"): ListeningStateChangedEvent;\n    createEvent(eventInterface: "MSGestureEvent"): MSGestureEvent;\n    createEvent(eventInterface: "MSMediaKeyMessageEvent"): MSMediaKeyMessageEvent;\n    createEvent(eventInterface: "MSMediaKeyNeededEvent"): MSMediaKeyNeededEvent;\n    createEvent(eventInterface: "MSPointerEvent"): MSPointerEvent;\n    createEvent(eventInterface: "MediaEncryptedEvent"): MediaEncryptedEvent;\n    createEvent(eventInterface: "MediaKeyMessageEvent"): MediaKeyMessageEvent;\n    createEvent(eventInterface: "MediaQueryListEvent"): MediaQueryListEvent;\n    createEvent(eventInterface: "MediaStreamErrorEvent"): MediaStreamErrorEvent;\n    createEvent(eventInterface: "MediaStreamEvent"): MediaStreamEvent;\n    createEvent(eventInterface: "MediaStreamTrackEvent"): MediaStreamTrackEvent;\n    createEvent(eventInterface: "MessageEvent"): MessageEvent;\n    createEvent(eventInterface: "MouseEvent"): MouseEvent;\n    createEvent(eventInterface: "MouseEvents"): MouseEvent;\n    createEvent(eventInterface: "MutationEvent"): MutationEvent;\n    createEvent(eventInterface: "MutationEvents"): MutationEvent;\n    createEvent(eventInterface: "OfflineAudioCompletionEvent"): OfflineAudioCompletionEvent;\n    createEvent(eventInterface: "OverflowEvent"): OverflowEvent;\n    createEvent(eventInterface: "PageTransitionEvent"): PageTransitionEvent;\n    createEvent(eventInterface: "PaymentRequestUpdateEvent"): PaymentRequestUpdateEvent;\n    createEvent(eventInterface: "PermissionRequestedEvent"): PermissionRequestedEvent;\n    createEvent(eventInterface: "PointerEvent"): PointerEvent;\n    createEvent(eventInterface: "PopStateEvent"): PopStateEvent;\n    createEvent(eventInterface: "ProgressEvent"): ProgressEvent;\n    createEvent(eventInterface: "PromiseRejectionEvent"): PromiseRejectionEvent;\n    createEvent(eventInterface: "RTCDTMFToneChangeEvent"): RTCDTMFToneChangeEvent;\n    createEvent(eventInterface: "RTCDataChannelEvent"): RTCDataChannelEvent;\n    createEvent(eventInterface: "RTCDtlsTransportStateChangedEvent"): RTCDtlsTransportStateChangedEvent;\n    createEvent(eventInterface: "RTCErrorEvent"): RTCErrorEvent;\n    createEvent(eventInterface: "RTCIceCandidatePairChangedEvent"): RTCIceCandidatePairChangedEvent;\n    createEvent(eventInterface: "RTCIceGathererEvent"): RTCIceGathererEvent;\n    createEvent(eventInterface: "RTCIceTransportStateChangedEvent"): RTCIceTransportStateChangedEvent;\n    createEvent(eventInterface: "RTCPeerConnectionIceErrorEvent"): RTCPeerConnectionIceErrorEvent;\n    createEvent(eventInterface: "RTCPeerConnectionIceEvent"): RTCPeerConnectionIceEvent;\n    createEvent(eventInterface: "RTCSsrcConflictEvent"): RTCSsrcConflictEvent;\n    createEvent(eventInterface: "RTCStatsEvent"): RTCStatsEvent;\n    createEvent(eventInterface: "RTCTrackEvent"): RTCTrackEvent;\n    createEvent(eventInterface: "SVGZoomEvent"): SVGZoomEvent;\n    createEvent(eventInterface: "SVGZoomEvents"): SVGZoomEvent;\n    createEvent(eventInterface: "SecurityPolicyViolationEvent"): SecurityPolicyViolationEvent;\n    createEvent(eventInterface: "ServiceWorkerMessageEvent"): ServiceWorkerMessageEvent;\n    createEvent(eventInterface: "SpeechRecognitionError"): SpeechRecognitionError;\n    createEvent(eventInterface: "SpeechRecognitionEvent"): SpeechRecognitionEvent;\n    createEvent(eventInterface: "SpeechSynthesisErrorEvent"): SpeechSynthesisErrorEvent;\n    createEvent(eventInterface: "SpeechSynthesisEvent"): SpeechSynthesisEvent;\n    createEvent(eventInterface: "StorageEvent"): StorageEvent;\n    createEvent(eventInterface: "TextEvent"): TextEvent;\n    createEvent(eventInterface: "TouchEvent"): TouchEvent;\n    createEvent(eventInterface: "TrackEvent"): TrackEvent;\n    createEvent(eventInterface: "TransitionEvent"): TransitionEvent;\n    createEvent(eventInterface: "UIEvent"): UIEvent;\n    createEvent(eventInterface: "UIEvents"): UIEvent;\n    createEvent(eventInterface: "VRDisplayEvent"): VRDisplayEvent;\n    createEvent(eventInterface: "VRDisplayEvent "): VRDisplayEvent ;\n    createEvent(eventInterface: "WebGLContextEvent"): WebGLContextEvent;\n    createEvent(eventInterface: "WheelEvent"): WheelEvent;\n    createEvent(eventInterface: string): Event;\n    /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     * @param root The root element or node to start traversing on.\n     * @param whatToShow The type of nodes or elements to appear in the node list\n     * @param filter A custom NodeFilter function to use. For more information, see filter. Use null for no filter.\n     * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\n     */\n    createNodeIterator(root: Node, whatToShow?: number, filter?: NodeFilter | null): NodeIterator;\n    /**\n     * Returns a ProcessingInstruction node whose target is target and data is data.\n     * If target does not match the Name production an\n     * "InvalidCharacterError" DOMException will be thrown.\n     * If data contains "?>" an\n     * "InvalidCharacterError" DOMException will be thrown.\n     */\n    createProcessingInstruction(target: string, data: string): ProcessingInstruction;\n    /**\n     *  Returns an empty range object that has both of its boundary points positioned at the beginning of the document.\n     */\n    createRange(): Range;\n    /**\n     * Creates a text string from the specified value.\n     * @param data String that specifies the nodeValue property of the text node.\n     */\n    createTextNode(data: string): Text;\n    createTouch(view: WindowProxy, target: EventTarget, identifier: number, pageX: number, pageY: number, screenX: number, screenY: number): Touch;\n    createTouchList(...touches: Touch[]): TouchList;\n    /**\n     * Creates a TreeWalker object that you can use to traverse filtered lists of nodes or elements in a document.\n     * @param root The root element or node to start traversing on.\n     * @param whatToShow The type of nodes or elements to appear in the node list. For more information, see whatToShow.\n     * @param filter A custom NodeFilter function to use.\n     * @param entityReferenceExpansion A flag that specifies whether entity reference nodes are expanded.\n     */\n    createTreeWalker(root: Node, whatToShow?: number, filter?: NodeFilter | null): TreeWalker;\n    /** @deprecated */\n    createTreeWalker(root: Node, whatToShow: number, filter: NodeFilter | null, entityReferenceExpansion?: boolean): TreeWalker;\n    /**\n     * Returns the element for the specified x coordinate and the specified y coordinate.\n     * @param x The x-offset\n     * @param y The y-offset\n     */\n    elementFromPoint(x: number, y: number): Element | null;\n    elementsFromPoint(x: number, y: number): Element[];\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver | ((prefix: string) => string | null) | null, type: number, result: XPathResult | null): XPathResult;\n    /**\n     * Executes a command on the current document, current selection, or the given range.\n     * @param commandId String that specifies the command to execute. This command can be any of the command identifiers that can be executed in script.\n     * @param showUI Display the user interface, defaults to false.\n     * @param value Value to assign.\n     */\n    execCommand(commandId: string, showUI?: boolean, value?: string): boolean;\n    /**\n     * Stops document\'s fullscreen element from being displayed fullscreen and\n     * resolves promise when done.\n     */\n    exitFullscreen(): Promise<void>;\n    getAnimations(): Animation[];\n    /**\n     * Returns a reference to the first object with the specified value of the ID or NAME attribute.\n     * @param elementId String that specifies the ID value. Case-insensitive.\n     */\n    getElementById(elementId: string): HTMLElement | null;\n    /**\n     * collection = element . getElementsByClassName(classNames)\n     */\n    getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;\n    /**\n     * Gets a collection of objects based on the value of the NAME or ID attribute.\n     * @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.\n     */\n    getElementsByName(elementName: string): NodeListOf<HTMLElement>;\n    /**\n     * Retrieves a collection of objects based on the specified element name.\n     * @param name Specifies the name of an element.\n     */\n    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;\n    getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;\n    getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;\n    /**\n     * If namespace and localName are\n     * "*" returns a HTMLCollection of all descendant elements.\n     * If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.\n     * If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.\n     * Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.\n     */\n    getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;\n    getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;\n    getElementsByTagNameNS(namespaceURI: string, localName: string): HTMLCollectionOf<Element>;\n    /**\n     * Gets a value indicating whether the object currently has focus.\n     */\n    hasFocus(): boolean;\n    importNode<T extends Node>(importedNode: T, deep: boolean): T;\n    /**\n     * Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method.\n     * @param url Specifies a MIME type for the document.\n     * @param name Specifies the name of the window. This name is used as the value for the TARGET attribute on a form or an anchor element.\n     * @param features Contains a list of items separated by commas. Each item consists of an option and a value, separated by an equals sign (for example, "fullscreen=yes, toolbar=yes"). The following values are supported.\n     * @param replace Specifies whether the existing entry for the document is replaced in the history list.\n     */\n    open(url?: string, name?: string, features?: string, replace?: boolean): Document;\n    /**\n     * Returns a Boolean value that indicates whether a specified command can be successfully executed using execCommand, given the current state of the document.\n     * @param commandId Specifies a command identifier.\n     */\n    queryCommandEnabled(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates whether the specified command is in the indeterminate state.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandIndeterm(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates the current state of the command.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandState(commandId: string): boolean;\n    /**\n     * Returns a Boolean value that indicates whether the current command is supported on the current range.\n     * @param commandId Specifies a command identifier.\n     */\n    queryCommandSupported(commandId: string): boolean;\n    /**\n     * Returns the current value of the document, range, or current selection for the given command.\n     * @param commandId String that specifies a command identifier.\n     */\n    queryCommandValue(commandId: string): string;\n    /** @deprecated */\n    releaseEvents(): void;\n    /**\n     * Writes one or more HTML expressions to a document in the specified window.\n     * @param content Specifies the text and HTML tags to write.\n     */\n    write(...text: string[]): void;\n    /**\n     * Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.\n     * @param content The text and HTML tags to write.\n     */\n    writeln(...text: string[]): void;\n    /**\n     * Returns an object representing the current selection of the document that is loaded into the object displaying a webpage.\n     */\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Document: {\n    prototype: Document;\n    new(): Document;\n};\n\ninterface DocumentAndElementEventHandlersEventMap {\n    "copy": ClipboardEvent;\n    "cut": ClipboardEvent;\n    "paste": ClipboardEvent;\n}\n\ninterface DocumentAndElementEventHandlers {\n    oncopy: ((this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any) | null;\n    oncut: ((this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any) | null;\n    onpaste: ((this: DocumentAndElementEventHandlers, ev: ClipboardEvent) => any) | null;\n    addEventListener<K extends keyof DocumentAndElementEventHandlersEventMap>(type: K, listener: (this: DocumentAndElementEventHandlers, ev: DocumentAndElementEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof DocumentAndElementEventHandlersEventMap>(type: K, listener: (this: DocumentAndElementEventHandlers, ev: DocumentAndElementEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface DocumentEvent {\n    createEvent(eventInterface: "AnimationEvent"): AnimationEvent;\n    createEvent(eventInterface: "AnimationPlaybackEvent"): AnimationPlaybackEvent;\n    createEvent(eventInterface: "AudioProcessingEvent"): AudioProcessingEvent;\n    createEvent(eventInterface: "BeforeUnloadEvent"): BeforeUnloadEvent;\n    createEvent(eventInterface: "ClipboardEvent"): ClipboardEvent;\n    createEvent(eventInterface: "CloseEvent"): CloseEvent;\n    createEvent(eventInterface: "CompositionEvent"): CompositionEvent;\n    createEvent(eventInterface: "CustomEvent"): CustomEvent;\n    createEvent(eventInterface: "DeviceLightEvent"): DeviceLightEvent;\n    createEvent(eventInterface: "DeviceMotionEvent"): DeviceMotionEvent;\n    createEvent(eventInterface: "DeviceOrientationEvent"): DeviceOrientationEvent;\n    createEvent(eventInterface: "DragEvent"): DragEvent;\n    createEvent(eventInterface: "ErrorEvent"): ErrorEvent;\n    createEvent(eventInterface: "Event"): Event;\n    createEvent(eventInterface: "Events"): Event;\n    createEvent(eventInterface: "FocusEvent"): FocusEvent;\n    createEvent(eventInterface: "FocusNavigationEvent"): FocusNavigationEvent;\n    createEvent(eventInterface: "GamepadEvent"): GamepadEvent;\n    createEvent(eventInterface: "HashChangeEvent"): HashChangeEvent;\n    createEvent(eventInterface: "IDBVersionChangeEvent"): IDBVersionChangeEvent;\n    createEvent(eventInterface: "KeyboardEvent"): KeyboardEvent;\n    createEvent(eventInterface: "ListeningStateChangedEvent"): ListeningStateChangedEvent;\n    createEvent(eventInterface: "MSGestureEvent"): MSGestureEvent;\n    createEvent(eventInterface: "MSMediaKeyMessageEvent"): MSMediaKeyMessageEvent;\n    createEvent(eventInterface: "MSMediaKeyNeededEvent"): MSMediaKeyNeededEvent;\n    createEvent(eventInterface: "MSPointerEvent"): MSPointerEvent;\n    createEvent(eventInterface: "MediaEncryptedEvent"): MediaEncryptedEvent;\n    createEvent(eventInterface: "MediaKeyMessageEvent"): MediaKeyMessageEvent;\n    createEvent(eventInterface: "MediaQueryListEvent"): MediaQueryListEvent;\n    createEvent(eventInterface: "MediaStreamErrorEvent"): MediaStreamErrorEvent;\n    createEvent(eventInterface: "MediaStreamEvent"): MediaStreamEvent;\n    createEvent(eventInterface: "MediaStreamTrackEvent"): MediaStreamTrackEvent;\n    createEvent(eventInterface: "MessageEvent"): MessageEvent;\n    createEvent(eventInterface: "MouseEvent"): MouseEvent;\n    createEvent(eventInterface: "MouseEvents"): MouseEvent;\n    createEvent(eventInterface: "MutationEvent"): MutationEvent;\n    createEvent(eventInterface: "MutationEvents"): MutationEvent;\n    createEvent(eventInterface: "OfflineAudioCompletionEvent"): OfflineAudioCompletionEvent;\n    createEvent(eventInterface: "OverflowEvent"): OverflowEvent;\n    createEvent(eventInterface: "PageTransitionEvent"): PageTransitionEvent;\n    createEvent(eventInterface: "PaymentRequestUpdateEvent"): PaymentRequestUpdateEvent;\n    createEvent(eventInterface: "PermissionRequestedEvent"): PermissionRequestedEvent;\n    createEvent(eventInterface: "PointerEvent"): PointerEvent;\n    createEvent(eventInterface: "PopStateEvent"): PopStateEvent;\n    createEvent(eventInterface: "ProgressEvent"): ProgressEvent;\n    createEvent(eventInterface: "PromiseRejectionEvent"): PromiseRejectionEvent;\n    createEvent(eventInterface: "RTCDTMFToneChangeEvent"): RTCDTMFToneChangeEvent;\n    createEvent(eventInterface: "RTCDataChannelEvent"): RTCDataChannelEvent;\n    createEvent(eventInterface: "RTCDtlsTransportStateChangedEvent"): RTCDtlsTransportStateChangedEvent;\n    createEvent(eventInterface: "RTCErrorEvent"): RTCErrorEvent;\n    createEvent(eventInterface: "RTCIceCandidatePairChangedEvent"): RTCIceCandidatePairChangedEvent;\n    createEvent(eventInterface: "RTCIceGathererEvent"): RTCIceGathererEvent;\n    createEvent(eventInterface: "RTCIceTransportStateChangedEvent"): RTCIceTransportStateChangedEvent;\n    createEvent(eventInterface: "RTCPeerConnectionIceErrorEvent"): RTCPeerConnectionIceErrorEvent;\n    createEvent(eventInterface: "RTCPeerConnectionIceEvent"): RTCPeerConnectionIceEvent;\n    createEvent(eventInterface: "RTCSsrcConflictEvent"): RTCSsrcConflictEvent;\n    createEvent(eventInterface: "RTCStatsEvent"): RTCStatsEvent;\n    createEvent(eventInterface: "RTCTrackEvent"): RTCTrackEvent;\n    createEvent(eventInterface: "SVGZoomEvent"): SVGZoomEvent;\n    createEvent(eventInterface: "SVGZoomEvents"): SVGZoomEvent;\n    createEvent(eventInterface: "SecurityPolicyViolationEvent"): SecurityPolicyViolationEvent;\n    createEvent(eventInterface: "ServiceWorkerMessageEvent"): ServiceWorkerMessageEvent;\n    createEvent(eventInterface: "SpeechRecognitionError"): SpeechRecognitionError;\n    createEvent(eventInterface: "SpeechRecognitionEvent"): SpeechRecognitionEvent;\n    createEvent(eventInterface: "SpeechSynthesisErrorEvent"): SpeechSynthesisErrorEvent;\n    createEvent(eventInterface: "SpeechSynthesisEvent"): SpeechSynthesisEvent;\n    createEvent(eventInterface: "StorageEvent"): StorageEvent;\n    createEvent(eventInterface: "TextEvent"): TextEvent;\n    createEvent(eventInterface: "TouchEvent"): TouchEvent;\n    createEvent(eventInterface: "TrackEvent"): TrackEvent;\n    createEvent(eventInterface: "TransitionEvent"): TransitionEvent;\n    createEvent(eventInterface: "UIEvent"): UIEvent;\n    createEvent(eventInterface: "UIEvents"): UIEvent;\n    createEvent(eventInterface: "VRDisplayEvent"): VRDisplayEvent;\n    createEvent(eventInterface: "VRDisplayEvent "): VRDisplayEvent ;\n    createEvent(eventInterface: "WebGLContextEvent"): WebGLContextEvent;\n    createEvent(eventInterface: "WheelEvent"): WheelEvent;\n    createEvent(eventInterface: string): Event;\n}\n\ninterface DocumentFragment extends Node, NonElementParentNode, ParentNode {\n    getElementById(elementId: string): HTMLElement | null;\n}\n\ndeclare var DocumentFragment: {\n    prototype: DocumentFragment;\n    new(): DocumentFragment;\n};\n\ninterface DocumentOrShadowRoot {\n    readonly activeElement: Element | null;\n    /**\n     * Retrieves a collection of styleSheet objects representing the style sheets that correspond to each instance of a link or style object in the document.\n     */\n    readonly styleSheets: StyleSheetList;\n    caretPositionFromPoint(x: number, y: number): CaretPosition | null;\n    /** @deprecated */\n    caretRangeFromPoint(x: number, y: number): Range;\n    elementFromPoint(x: number, y: number): Element | null;\n    elementsFromPoint(x: number, y: number): Element[];\n    getSelection(): Selection | null;\n}\n\ninterface DocumentTimeline extends AnimationTimeline {\n}\n\ndeclare var DocumentTimeline: {\n    prototype: DocumentTimeline;\n    new(options?: DocumentTimelineOptions): DocumentTimeline;\n};\n\ninterface DocumentType extends Node, ChildNode {\n    readonly name: string;\n    readonly publicId: string;\n    readonly systemId: string;\n}\n\ndeclare var DocumentType: {\n    prototype: DocumentType;\n    new(): DocumentType;\n};\n\ninterface DragEvent extends MouseEvent {\n    /**\n     * Returns the DataTransfer object for the event.\n     */\n    readonly dataTransfer: DataTransfer | null;\n}\n\ndeclare var DragEvent: {\n    prototype: DragEvent;\n    new(type: string, eventInitDict?: DragEventInit): DragEvent;\n};\n\ninterface DynamicsCompressorNode extends AudioNode {\n    readonly attack: AudioParam;\n    readonly knee: AudioParam;\n    readonly ratio: AudioParam;\n    readonly reduction: number;\n    readonly release: AudioParam;\n    readonly threshold: AudioParam;\n}\n\ndeclare var DynamicsCompressorNode: {\n    prototype: DynamicsCompressorNode;\n    new(context: BaseAudioContext, options?: DynamicsCompressorOptions): DynamicsCompressorNode;\n};\n\ninterface EXT_blend_minmax {\n    readonly MAX_EXT: GLenum;\n    readonly MIN_EXT: GLenum;\n}\n\ninterface EXT_frag_depth {\n}\n\ninterface EXT_sRGB {\n    readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: GLenum;\n    readonly SRGB8_ALPHA8_EXT: GLenum;\n    readonly SRGB_ALPHA_EXT: GLenum;\n    readonly SRGB_EXT: GLenum;\n}\n\ninterface EXT_shader_texture_lod {\n}\n\ninterface EXT_texture_filter_anisotropic {\n    readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT: GLenum;\n    readonly TEXTURE_MAX_ANISOTROPY_EXT: GLenum;\n}\n\ninterface ElementEventMap {\n    "fullscreenchange": Event;\n    "fullscreenerror": Event;\n}\n\ninterface Element extends Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, Animatable {\n    readonly assignedSlot: HTMLSlotElement | null;\n    readonly attributes: NamedNodeMap;\n    /**\n     * Allows for manipulation of element\'s class content attribute as a\n     * set of whitespace-separated tokens through a DOMTokenList object.\n     */\n    readonly classList: DOMTokenList;\n    /**\n     * Returns the value of element\'s class content attribute. Can be set\n     * to change it.\n     */\n    className: string;\n    readonly clientHeight: number;\n    readonly clientLeft: number;\n    readonly clientTop: number;\n    readonly clientWidth: number;\n    /**\n     * Returns the value of element\'s id content attribute. Can be set to\n     * change it.\n     */\n    id: string;\n    innerHTML: string;\n    /**\n     * Returns the local name.\n     */\n    readonly localName: string;\n    /**\n     * Returns the namespace.\n     */\n    readonly namespaceURI: string | null;\n    onfullscreenchange: ((this: Element, ev: Event) => any) | null;\n    onfullscreenerror: ((this: Element, ev: Event) => any) | null;\n    outerHTML: string;\n    /**\n     * Returns the namespace prefix.\n     */\n    readonly prefix: string | null;\n    readonly scrollHeight: number;\n    scrollLeft: number;\n    scrollTop: number;\n    readonly scrollWidth: number;\n    /**\n     * Returns element\'s shadow root, if any, and if shadow root\'s mode is "open", and null otherwise.\n     */\n    readonly shadowRoot: ShadowRoot | null;\n    /**\n     * Returns the value of element\'s slot content attribute. Can be set to\n     * change it.\n     */\n    slot: string;\n    /**\n     * Returns the HTML-uppercased qualified name.\n     */\n    readonly tagName: string;\n    /**\n     * Creates a shadow root for element and returns it.\n     */\n    attachShadow(shadowRootInitDict: ShadowRootInit): ShadowRoot;\n    /**\n     * Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise.\n     */\n    closest<K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K] | null;\n    closest<K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K] | null;\n    closest(selector: string): Element | null;\n    /**\n     * Returns element\'s first attribute whose qualified name is qualifiedName, and null if there is no such attribute otherwise.\n     */\n    getAttribute(qualifiedName: string): string | null;\n    /**\n     * Returns element\'s attribute whose namespace is namespace and local name is localName, and null if there is\n     * no such attribute otherwise.\n     */\n    getAttributeNS(namespace: string | null, localName: string): string | null;\n    /**\n     * Returns the qualified names of all element\'s attributes.\n     * Can contain duplicates.\n     */\n    getAttributeNames(): string[];\n    getAttributeNode(name: string): Attr | null;\n    getAttributeNodeNS(namespaceURI: string, localName: string): Attr | null;\n    getBoundingClientRect(): ClientRect | DOMRect;\n    getClientRects(): ClientRectList | DOMRectList;\n    getElementsByClassName(classNames: string): HTMLCollectionOf<Element>;\n    getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>;\n    getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<SVGElementTagNameMap[K]>;\n    getElementsByTagName(qualifiedName: string): HTMLCollectionOf<Element>;\n    getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;\n    getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;\n    getElementsByTagNameNS(namespaceURI: string, localName: string): HTMLCollectionOf<Element>;\n    /**\n     * Returns true if element has an attribute whose qualified name is qualifiedName, and false otherwise.\n     */\n    hasAttribute(qualifiedName: string): boolean;\n    /**\n     * Returns true if element has an attribute whose namespace is namespace and local name is localName.\n     */\n    hasAttributeNS(namespace: string | null, localName: string): boolean;\n    /**\n     * Returns true if element has attributes, and false otherwise.\n     */\n    hasAttributes(): boolean;\n    hasPointerCapture(pointerId: number): boolean;\n    insertAdjacentElement(position: InsertPosition, insertedElement: Element): Element | null;\n    insertAdjacentHTML(where: InsertPosition, html: string): void;\n    insertAdjacentText(where: InsertPosition, text: string): void;\n    /**\n     * Returns true if matching selectors against element\'s root yields element, and false otherwise.\n     */\n    matches(selectors: string): boolean;\n    msGetRegionContent(): any;\n    releasePointerCapture(pointerId: number): void;\n    /**\n     * Removes element\'s first attribute whose qualified name is qualifiedName.\n     */\n    removeAttribute(qualifiedName: string): void;\n    /**\n     * Removes element\'s attribute whose namespace is namespace and local name is localName.\n     */\n    removeAttributeNS(namespace: string | null, localName: string): void;\n    removeAttributeNode(attr: Attr): Attr;\n    /**\n     * Displays element fullscreen and resolves promise when done.\n     */\n    requestFullscreen(): Promise<void>;\n    scroll(options?: ScrollToOptions): void;\n    scroll(x: number, y: number): void;\n    scrollBy(options?: ScrollToOptions): void;\n    scrollBy(x: number, y: number): void;\n    scrollIntoView(arg?: boolean | ScrollIntoViewOptions): void;\n    scrollTo(options?: ScrollToOptions): void;\n    scrollTo(x: number, y: number): void;\n    /**\n     * Sets the value of element\'s first attribute whose qualified name is qualifiedName to value.\n     */\n    setAttribute(qualifiedName: string, value: string): void;\n    /**\n     * Sets the value of element\'s attribute whose namespace is namespace and local name is localName to value.\n     */\n    setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void;\n    setAttributeNode(attr: Attr): Attr | null;\n    setAttributeNodeNS(attr: Attr): Attr | null;\n    setPointerCapture(pointerId: number): void;\n    /**\n     * If force is not given, "toggles" qualifiedName, removing it if it is\n     * present and adding it if it is not present. If force is true, adds qualifiedName. If force is false, removes qualifiedName.\n     * Returns true if qualifiedName is now present, and false otherwise.\n     */\n    toggleAttribute(qualifiedName: string, force?: boolean): boolean;\n    webkitMatchesSelector(selectors: string): boolean;\n    addEventListener<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Element: {\n    prototype: Element;\n    new(): Element;\n};\n\ninterface ElementCSSInlineStyle {\n    readonly style: CSSStyleDeclaration;\n}\n\ninterface ElementContentEditable {\n    contentEditable: string;\n    inputMode: string;\n    readonly isContentEditable: boolean;\n}\n\ninterface ElementCreationOptions {\n    is?: string;\n}\n\ninterface ErrorEvent extends Event {\n    readonly colno: number;\n    readonly error: any;\n    readonly filename: string;\n    readonly lineno: number;\n    readonly message: string;\n}\n\ndeclare var ErrorEvent: {\n    prototype: ErrorEvent;\n    new(type: string, eventInitDict?: ErrorEventInit): ErrorEvent;\n};\n\ninterface Event {\n    /**\n     * Returns true or false depending on how event was initialized. True if event goes through its target\'s ancestors in reverse tree order, and false otherwise.\n     */\n    readonly bubbles: boolean;\n    cancelBubble: boolean;\n    readonly cancelable: boolean;\n    /**\n     * Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.\n     */\n    readonly composed: boolean;\n    /**\n     * Returns the object whose event listener\'s callback is currently being\n     * invoked.\n     */\n    readonly currentTarget: EventTarget | null;\n    readonly defaultPrevented: boolean;\n    readonly eventPhase: number;\n    /**\n     * Returns true if event was dispatched by the user agent, and\n     * false otherwise.\n     */\n    readonly isTrusted: boolean;\n    returnValue: boolean;\n    /** @deprecated */\n    readonly srcElement: Element | null;\n    /**\n     * Returns the object to which event is dispatched (its target).\n     */\n    readonly target: EventTarget | null;\n    /**\n     * Returns the event\'s timestamp as the number of milliseconds measured relative to\n     * the time origin.\n     */\n    readonly timeStamp: number;\n    /**\n     * Returns the type of event, e.g.\n     * "click", "hashchange", or\n     * "submit".\n     */\n    readonly type: string;\n    composedPath(): EventTarget[];\n    initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void;\n    preventDefault(): void;\n    /**\n     * Invoking this method prevents event from reaching\n     * any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any\n     * other objects.\n     */\n    stopImmediatePropagation(): void;\n    /**\n     * When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.\n     */\n    stopPropagation(): void;\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n    readonly NONE: number;\n}\n\ndeclare var Event: {\n    prototype: Event;\n    new(type: string, eventInitDict?: EventInit): Event;\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n    readonly NONE: number;\n};\n\ninterface EventListenerObject {\n    handleEvent(evt: Event): void;\n}\n\ninterface EventSource extends EventTarget {\n    readonly CLOSED: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n    onerror: (evt: MessageEvent) => any;\n    onmessage: (evt: MessageEvent) => any;\n    onopen: (evt: MessageEvent) => any;\n    readonly readyState: number;\n    readonly url: string;\n    readonly withCredentials: boolean;\n    close(): void;\n}\n\ndeclare var EventSource: {\n    prototype: EventSource;\n    new(url: string, eventSourceInitDict?: EventSourceInit): EventSource;\n};\n\ninterface EventSourceInit {\n    readonly withCredentials: boolean;\n}\n\ninterface EventTarget {\n    /**\n     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n     * The options argument sets listener-specific options. For compatibility this can be a\n     * boolean, in which case the method behaves exactly as if the value was specified as options\'s capture.\n     * When set to true, options\'s capture prevents callback from being invoked when the event\'s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event\'s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event\'s eventPhase attribute value is AT_TARGET.\n     * When set to true, options\'s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in \xa72.8 Observing event listeners.\n     * When set to true, options\'s once indicates that the callback will only be invoked once after which the event listener will\n     * be removed.\n     * The event listener is appended to target\'s event listener list and is not appended if it has the same type, callback, and capture.\n     */\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void;\n    /**\n     * Dispatches a synthetic event event to target and returns true\n     * if either event\'s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n     */\n    dispatchEvent(event: Event): boolean;\n    /**\n     * Removes the event listener in target\'s event listener list with the same type, callback, and options.\n     */\n    removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;\n}\n\ndeclare var EventTarget: {\n    prototype: EventTarget;\n    new(): EventTarget;\n};\n\ninterface ExtensionScriptApis {\n    extensionIdToShortId(extensionId: string): number;\n    fireExtensionApiTelemetry(functionName: string, isSucceeded: boolean, isSupported: boolean, errorString: string): void;\n    genericFunction(routerAddress: any, parameters?: string, callbackId?: number): void;\n    genericSynchronousFunction(functionId: number, parameters?: string): string;\n    genericWebRuntimeCallout(to: any, from: any, payload: string): void;\n    getExtensionId(): string;\n    registerGenericFunctionCallbackHandler(callbackHandler: Function): void;\n    registerGenericPersistentCallbackHandler(callbackHandler: Function): void;\n    registerWebRuntimeCallbackHandler(handler: Function): any;\n}\n\ndeclare var ExtensionScriptApis: {\n    prototype: ExtensionScriptApis;\n    new(): ExtensionScriptApis;\n};\n\ninterface External {\n    /** @deprecated */\n    AddSearchProvider(): void;\n    /** @deprecated */\n    IsSearchProviderInstalled(): void;\n}\n\ninterface File extends Blob {\n    readonly lastModified: number;\n    readonly name: string;\n}\n\ndeclare var File: {\n    prototype: File;\n    new(fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;\n};\n\ninterface FileList {\n    readonly length: number;\n    item(index: number): File | null;\n    [index: number]: File;\n}\n\ndeclare var FileList: {\n    prototype: FileList;\n    new(): FileList;\n};\n\ninterface FileReaderEventMap {\n    "abort": ProgressEvent;\n    "error": ProgressEvent;\n    "load": ProgressEvent;\n    "loadend": ProgressEvent;\n    "loadstart": ProgressEvent;\n    "progress": ProgressEvent;\n}\n\ninterface FileReader extends EventTarget {\n    readonly error: DOMException | null;\n    onabort: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onerror: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onload: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    readonly readyState: number;\n    readonly result: string | ArrayBuffer | null;\n    abort(): void;\n    readAsArrayBuffer(blob: Blob): void;\n    readAsBinaryString(blob: Blob): void;\n    readAsDataURL(blob: Blob): void;\n    readAsText(blob: Blob, encoding?: string): void;\n    readonly DONE: number;\n    readonly EMPTY: number;\n    readonly LOADING: number;\n    addEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var FileReader: {\n    prototype: FileReader;\n    new(): FileReader;\n    readonly DONE: number;\n    readonly EMPTY: number;\n    readonly LOADING: number;\n};\n\ninterface FocusEvent extends UIEvent {\n    readonly relatedTarget: EventTarget;\n    initFocusEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, relatedTargetArg: EventTarget): void;\n}\n\ndeclare var FocusEvent: {\n    prototype: FocusEvent;\n    new(typeArg: string, eventInitDict?: FocusEventInit): FocusEvent;\n};\n\ninterface FocusNavigationEvent extends Event {\n    readonly navigationReason: NavigationReason;\n    readonly originHeight: number;\n    readonly originLeft: number;\n    readonly originTop: number;\n    readonly originWidth: number;\n    requestFocus(): void;\n}\n\ndeclare var FocusNavigationEvent: {\n    prototype: FocusNavigationEvent;\n    new(type: string, eventInitDict?: FocusNavigationEventInit): FocusNavigationEvent;\n};\n\ninterface FormData {\n    append(name: string, value: string | Blob, fileName?: string): void;\n    delete(name: string): void;\n    get(name: string): FormDataEntryValue | null;\n    getAll(name: string): FormDataEntryValue[];\n    has(name: string): boolean;\n    set(name: string, value: string | Blob, fileName?: string): void;\n    forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData) => void, thisArg?: any): void;\n}\n\ndeclare var FormData: {\n    prototype: FormData;\n    new(form?: HTMLFormElement): FormData;\n};\n\ninterface GainNode extends AudioNode {\n    readonly gain: AudioParam;\n}\n\ndeclare var GainNode: {\n    prototype: GainNode;\n    new(context: BaseAudioContext, options?: GainOptions): GainNode;\n};\n\ninterface Gamepad {\n    readonly axes: number[];\n    readonly buttons: GamepadButton[];\n    readonly connected: boolean;\n    readonly displayId: number;\n    readonly hand: GamepadHand;\n    readonly hapticActuators: GamepadHapticActuator[];\n    readonly id: string;\n    readonly index: number;\n    readonly mapping: GamepadMappingType;\n    readonly pose: GamepadPose | null;\n    readonly timestamp: number;\n}\n\ndeclare var Gamepad: {\n    prototype: Gamepad;\n    new(): Gamepad;\n};\n\ninterface GamepadButton {\n    readonly pressed: boolean;\n    readonly touched: boolean;\n    readonly value: number;\n}\n\ndeclare var GamepadButton: {\n    prototype: GamepadButton;\n    new(): GamepadButton;\n};\n\ninterface GamepadEvent extends Event {\n    readonly gamepad: Gamepad;\n}\n\ndeclare var GamepadEvent: {\n    prototype: GamepadEvent;\n    new(typeArg: string, eventInitDict?: GamepadEventInit): GamepadEvent;\n};\n\ninterface GamepadHapticActuator {\n    readonly type: GamepadHapticActuatorType;\n    pulse(value: number, duration: number): Promise<boolean>;\n}\n\ndeclare var GamepadHapticActuator: {\n    prototype: GamepadHapticActuator;\n    new(): GamepadHapticActuator;\n};\n\ninterface GamepadPose {\n    readonly angularAcceleration: Float32Array | null;\n    readonly angularVelocity: Float32Array | null;\n    readonly hasOrientation: boolean;\n    readonly hasPosition: boolean;\n    readonly linearAcceleration: Float32Array | null;\n    readonly linearVelocity: Float32Array | null;\n    readonly orientation: Float32Array | null;\n    readonly position: Float32Array | null;\n}\n\ndeclare var GamepadPose: {\n    prototype: GamepadPose;\n    new(): GamepadPose;\n};\n\ninterface Geolocation {\n    clearWatch(watchId: number): void;\n    getCurrentPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): void;\n    watchPosition(successCallback: PositionCallback, errorCallback?: PositionErrorCallback, options?: PositionOptions): number;\n}\n\ninterface GetSVGDocument {\n    getSVGDocument(): Document;\n}\n\ninterface GlobalEventHandlersEventMap {\n    "abort": UIEvent;\n    "animationcancel": AnimationEvent;\n    "animationend": AnimationEvent;\n    "animationiteration": AnimationEvent;\n    "animationstart": AnimationEvent;\n    "auxclick": Event;\n    "blur": FocusEvent;\n    "cancel": Event;\n    "canplay": Event;\n    "canplaythrough": Event;\n    "change": Event;\n    "click": MouseEvent;\n    "close": Event;\n    "contextmenu": MouseEvent;\n    "cuechange": Event;\n    "dblclick": MouseEvent;\n    "drag": DragEvent;\n    "dragend": DragEvent;\n    "dragenter": DragEvent;\n    "dragexit": Event;\n    "dragleave": DragEvent;\n    "dragover": DragEvent;\n    "dragstart": DragEvent;\n    "drop": DragEvent;\n    "durationchange": Event;\n    "emptied": Event;\n    "ended": Event;\n    "error": ErrorEvent;\n    "focus": FocusEvent;\n    "gotpointercapture": PointerEvent;\n    "input": Event;\n    "invalid": Event;\n    "keydown": KeyboardEvent;\n    "keypress": KeyboardEvent;\n    "keyup": KeyboardEvent;\n    "load": Event;\n    "loadeddata": Event;\n    "loadedmetadata": Event;\n    "loadend": ProgressEvent;\n    "loadstart": Event;\n    "lostpointercapture": PointerEvent;\n    "mousedown": MouseEvent;\n    "mouseenter": MouseEvent;\n    "mouseleave": MouseEvent;\n    "mousemove": MouseEvent;\n    "mouseout": MouseEvent;\n    "mouseover": MouseEvent;\n    "mouseup": MouseEvent;\n    "pause": Event;\n    "play": Event;\n    "playing": Event;\n    "pointercancel": PointerEvent;\n    "pointerdown": PointerEvent;\n    "pointerenter": PointerEvent;\n    "pointerleave": PointerEvent;\n    "pointermove": PointerEvent;\n    "pointerout": PointerEvent;\n    "pointerover": PointerEvent;\n    "pointerup": PointerEvent;\n    "progress": ProgressEvent;\n    "ratechange": Event;\n    "reset": Event;\n    "resize": UIEvent;\n    "scroll": UIEvent;\n    "securitypolicyviolation": SecurityPolicyViolationEvent;\n    "seeked": Event;\n    "seeking": Event;\n    "select": UIEvent;\n    "stalled": Event;\n    "submit": Event;\n    "suspend": Event;\n    "timeupdate": Event;\n    "toggle": Event;\n    "touchcancel": TouchEvent;\n    "touchend": TouchEvent;\n    "touchmove": TouchEvent;\n    "touchstart": TouchEvent;\n    "transitioncancel": TransitionEvent;\n    "transitionend": TransitionEvent;\n    "transitionrun": TransitionEvent;\n    "transitionstart": TransitionEvent;\n    "volumechange": Event;\n    "waiting": Event;\n    "wheel": WheelEvent;\n}\n\ninterface GlobalEventHandlers {\n    /**\n     * Fires when the user aborts the download.\n     * @param ev The event.\n     */\n    onabort: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n    onanimationcancel: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n    onanimationend: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n    onanimationiteration: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n    onanimationstart: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) | null;\n    onauxclick: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the object loses the input focus.\n     * @param ev The focus event.\n     */\n    onblur: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n    oncancel: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when playback is possible, but would require further buffering.\n     * @param ev The event.\n     */\n    oncanplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    oncanplaythrough: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the contents of the object or selection have changed.\n     * @param ev The event.\n     */\n    onchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the user clicks the left mouse button on the object\n     * @param ev The mouse event.\n     */\n    onclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    onclose: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the user clicks the right mouse button in the client area, opening the context menu.\n     * @param ev The mouse event.\n     */\n    oncontextmenu: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    oncuechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the user double-clicks the object.\n     * @param ev The mouse event.\n     */\n    ondblclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Fires on the source object continuously during a drag operation.\n     * @param ev The event.\n     */\n    ondrag: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    /**\n     * Fires on the source object when the user releases the mouse at the close of a drag operation.\n     * @param ev The event.\n     */\n    ondragend: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    /**\n     * Fires on the target element when the user drags the object to a valid drop target.\n     * @param ev The drag event.\n     */\n    ondragenter: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    ondragexit: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.\n     * @param ev The drag event.\n     */\n    ondragleave: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    /**\n     * Fires on the target element continuously while the user drags the object over a valid drop target.\n     * @param ev The event.\n     */\n    ondragover: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    /**\n     * Fires on the source object when the user starts to drag a text selection or selected object.\n     * @param ev The event.\n     */\n    ondragstart: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    ondrop: ((this: GlobalEventHandlers, ev: DragEvent) => any) | null;\n    /**\n     * Occurs when the duration attribute is updated.\n     * @param ev The event.\n     */\n    ondurationchange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the media element is reset to its initial state.\n     * @param ev The event.\n     */\n    onemptied: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the end of playback is reached.\n     * @param ev The event\n     */\n    onended: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when an error occurs during object loading.\n     * @param ev The event.\n     */\n    onerror: ErrorEventHandler;\n    /**\n     * Fires when the object receives focus.\n     * @param ev The event.\n     */\n    onfocus: ((this: GlobalEventHandlers, ev: FocusEvent) => any) | null;\n    ongotpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    oninput: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    oninvalid: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the user presses a key.\n     * @param ev The keyboard event\n     */\n    onkeydown: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n    /**\n     * Fires when the user presses an alphanumeric key.\n     * @param ev The event.\n     */\n    onkeypress: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n    /**\n     * Fires when the user releases a key.\n     * @param ev The keyboard event\n     */\n    onkeyup: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) | null;\n    /**\n     * Fires immediately after the browser loads the object.\n     * @param ev The event.\n     */\n    onload: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when media data is loaded at the current playback position.\n     * @param ev The event.\n     */\n    onloadeddata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the duration and dimensions of the media have been determined.\n     * @param ev The event.\n     */\n    onloadedmetadata: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onloadend: ((this: GlobalEventHandlers, ev: ProgressEvent) => any) | null;\n    /**\n     * Occurs when Internet Explorer begins looking for media data.\n     * @param ev The event.\n     */\n    onloadstart: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onlostpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    /**\n     * Fires when the user clicks the object with either mouse button.\n     * @param ev The mouse event.\n     */\n    onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    onmouseenter: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    onmouseleave: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Fires when the user moves the mouse over the object.\n     * @param ev The mouse event.\n     */\n    onmousemove: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Fires when the user moves the mouse pointer outside the boundaries of the object.\n     * @param ev The mouse event.\n     */\n    onmouseout: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Fires when the user moves the mouse pointer into the object.\n     * @param ev The mouse event.\n     */\n    onmouseover: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Fires when the user releases a mouse button while the mouse is over the object.\n     * @param ev The mouse event.\n     */\n    onmouseup: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n    /**\n     * Occurs when playback is paused.\n     * @param ev The event.\n     */\n    onpause: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the play method is requested.\n     * @param ev The event.\n     */\n    onplay: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the audio or video has started playing.\n     * @param ev The event.\n     */\n    onplaying: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onpointercancel: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerdown: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerenter: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerleave: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointermove: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerout: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerover: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    onpointerup: ((this: GlobalEventHandlers, ev: PointerEvent) => any) | null;\n    /**\n     * Occurs to indicate progress while downloading media data.\n     * @param ev The event.\n     */\n    onprogress: ((this: GlobalEventHandlers, ev: ProgressEvent) => any) | null;\n    /**\n     * Occurs when the playback rate is increased or decreased.\n     * @param ev The event.\n     */\n    onratechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the user resets a form.\n     * @param ev The event.\n     */\n    onreset: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onresize: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n    /**\n     * Fires when the user repositions the scroll box in the scroll bar on the object.\n     * @param ev The event.\n     */\n    onscroll: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n    onsecuritypolicyviolation: ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) | null;\n    /**\n     * Occurs when the seek operation ends.\n     * @param ev The event.\n     */\n    onseeked: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when the current playback position is moved.\n     * @param ev The event.\n     */\n    onseeking: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Fires when the current selection changes.\n     * @param ev The event.\n     */\n    onselect: ((this: GlobalEventHandlers, ev: UIEvent) => any) | null;\n    /**\n     * Occurs when the download has stopped.\n     * @param ev The event.\n     */\n    onstalled: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onsubmit: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs if the load operation has been intentionally halted.\n     * @param ev The event.\n     */\n    onsuspend: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs to indicate the current playback position.\n     * @param ev The event.\n     */\n    ontimeupdate: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    ontoggle: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    ontouchcancel: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null;\n    ontouchend: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null;\n    ontouchmove: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null;\n    ontouchstart: ((this: GlobalEventHandlers, ev: TouchEvent) => any) | null;\n    ontransitioncancel: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n    ontransitionend: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n    ontransitionrun: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n    ontransitionstart: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) | null;\n    /**\n     * Occurs when the volume is changed, or playback is muted or unmuted.\n     * @param ev The event.\n     */\n    onvolumechange: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    /**\n     * Occurs when playback stops because the next frame of a video resource is not available.\n     * @param ev The event.\n     */\n    onwaiting: ((this: GlobalEventHandlers, ev: Event) => any) | null;\n    onwheel: ((this: GlobalEventHandlers, ev: WheelEvent) => any) | null;\n    addEventListener<K extends keyof GlobalEventHandlersEventMap>(type: K, listener: (this: GlobalEventHandlers, ev: GlobalEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof GlobalEventHandlersEventMap>(type: K, listener: (this: GlobalEventHandlers, ev: GlobalEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface GlobalFetch {\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n}\n\ninterface HTMLAllCollection {\n    /**\n     * Returns the number of elements in the collection.\n     */\n    readonly length: number;\n    /**\n     * element = collection(index)\n     */\n    item(nameOrIndex?: string): HTMLCollection | Element | null;\n    /**\n     * element = collection(name)\n     */\n    namedItem(name: string): HTMLCollection | Element | null;\n    [index: number]: Element;\n}\n\ndeclare var HTMLAllCollection: {\n    prototype: HTMLAllCollection;\n    new(): HTMLAllCollection;\n};\n\ninterface HTMLAnchorElement extends HTMLElement, HTMLHyperlinkElementUtils {\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    /** @deprecated */\n    charset: string;\n    /**\n     * Sets or retrieves the coordinates of the object.\n     */\n    /** @deprecated */\n    coords: string;\n    download: string;\n    /**\n     * Sets or retrieves the language code of the object.\n     */\n    hreflang: string;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    /** @deprecated */\n    name: string;\n    ping: string;\n    referrerPolicy: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rel: string;\n    readonly relList: DOMTokenList;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    /** @deprecated */\n    rev: string;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    /** @deprecated */\n    shape: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAnchorElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAnchorElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLAnchorElement: {\n    prototype: HTMLAnchorElement;\n    new(): HTMLAnchorElement;\n};\n\ninterface HTMLAppletElement extends HTMLElement {\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    /** @deprecated */\n    alt: string;\n    /**\n     * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\n     */\n    /** @deprecated */\n    archive: string;\n    /** @deprecated */\n    code: string;\n    /**\n     * Sets or retrieves the URL of the component.\n     */\n    /** @deprecated */\n    codeBase: string;\n    readonly form: HTMLFormElement | null;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    /** @deprecated */\n    height: string;\n    /** @deprecated */\n    hspace: number;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    /** @deprecated */\n    name: string;\n    /** @deprecated */\n    object: string;\n    /** @deprecated */\n    vspace: number;\n    /** @deprecated */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAppletElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAppletElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLAppletElement: {\n    prototype: HTMLAppletElement;\n    new(): HTMLAppletElement;\n};\n\ninterface HTMLAreaElement extends HTMLElement, HTMLHyperlinkElementUtils {\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Sets or retrieves the coordinates of the object.\n     */\n    coords: string;\n    download: string;\n    /**\n     * Sets or gets whether clicks in this region cause action.\n     */\n    /** @deprecated */\n    noHref: boolean;\n    ping: string;\n    referrerPolicy: string;\n    rel: string;\n    readonly relList: DOMTokenList;\n    /**\n     * Sets or retrieves the shape of the object.\n     */\n    shape: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLAreaElement: {\n    prototype: HTMLAreaElement;\n    new(): HTMLAreaElement;\n};\n\ninterface HTMLAudioElement extends HTMLMediaElement {\n    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLAudioElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLAudioElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLAudioElement: {\n    prototype: HTMLAudioElement;\n    new(): HTMLAudioElement;\n};\n\ninterface HTMLBRElement extends HTMLElement {\n    /**\n     * Sets or retrieves the side on which floating objects are not to be positioned when any IHTMLBlockElement is inserted into the document.\n     */\n    /** @deprecated */\n    clear: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLBRElement: {\n    prototype: HTMLBRElement;\n    new(): HTMLBRElement;\n};\n\ninterface HTMLBaseElement extends HTMLElement {\n    /**\n     * Gets or sets the baseline URL on which relative links are based.\n     */\n    href: string;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLBaseElement: {\n    prototype: HTMLBaseElement;\n    new(): HTMLBaseElement;\n};\n\ninterface HTMLBaseFontElement extends HTMLElement, DOML2DeprecatedColorProperty {\n    /**\n     * Sets or retrieves the current typeface family.\n     */\n    /** @deprecated */\n    face: string;\n    /**\n     * Sets or retrieves the font size of the object.\n     */\n    /** @deprecated */\n    size: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLBaseFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLBaseFontElement: {\n    prototype: HTMLBaseFontElement;\n    new(): HTMLBaseFontElement;\n};\n\ninterface HTMLBodyElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {\n    "orientationchange": Event;\n}\n\ninterface HTMLBodyElement extends HTMLElement, WindowEventHandlers {\n    /** @deprecated */\n    aLink: string;\n    /** @deprecated */\n    background: string;\n    /** @deprecated */\n    bgColor: string;\n    bgProperties: string;\n    /** @deprecated */\n    link: string;\n    /** @deprecated */\n    noWrap: boolean;\n    /** @deprecated */\n    onorientationchange: ((this: HTMLBodyElement, ev: Event) => any) | null;\n    /** @deprecated */\n    text: string;\n    /** @deprecated */\n    vLink: string;\n    addEventListener<K extends keyof HTMLBodyElementEventMap>(type: K, listener: (this: HTMLBodyElement, ev: HTMLBodyElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLBodyElementEventMap>(type: K, listener: (this: HTMLBodyElement, ev: HTMLBodyElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLBodyElement: {\n    prototype: HTMLBodyElement;\n    new(): HTMLBodyElement;\n};\n\ninterface HTMLButtonElement extends HTMLElement {\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Overrides the action attribute (where the data on a form is sent) on the parent form element.\n     */\n    formAction: string;\n    /**\n     * Used to override the encoding (formEnctype attribute) specified on the form element.\n     */\n    formEnctype: string;\n    /**\n     * Overrides the submit method attribute previously specified on a form element.\n     */\n    formMethod: string;\n    /**\n     * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option.\n     */\n    formNoValidate: boolean;\n    /**\n     * Overrides the target attribute on a form element.\n     */\n    formTarget: string;\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Gets the classification and default behavior of the button.\n     */\n    type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Sets or retrieves the default or selected value of the control.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLButtonElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLButtonElement: {\n    prototype: HTMLButtonElement;\n    new(): HTMLButtonElement;\n};\n\ninterface HTMLCanvasElement extends HTMLElement {\n    /**\n     * Gets or sets the height of a canvas element on a document.\n     */\n    height: number;\n    /**\n     * Gets or sets the width of a canvas element on a document.\n     */\n    width: number;\n    /**\n     * Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.\n     * @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext("2d"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext("experimental-webgl");\n     */\n    getContext(contextId: "2d", contextAttributes?: CanvasRenderingContext2DSettings): CanvasRenderingContext2D | null;\n    getContext(contextId: "webgl" | "experimental-webgl", contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | null;\n    getContext(contextId: string, contextAttributes?: {}): CanvasRenderingContext2D | WebGLRenderingContext | null;\n    toBlob(callback: BlobCallback, type?: string, quality?: any): void;\n    /**\n     * Returns the content of the current canvas as an image that you can use as a source for another canvas or an HTML element.\n     * @param type The standard MIME type for the image format to return. If you do not specify this parameter, the default value is a PNG format image.\n     */\n    toDataURL(type?: string, quality?: any): string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLCanvasElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLCanvasElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLCanvasElement: {\n    prototype: HTMLCanvasElement;\n    new(): HTMLCanvasElement;\n};\n\ninterface HTMLCollectionBase {\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    readonly length: number;\n    /**\n     * Retrieves an object from various collections.\n     */\n    item(index: number): Element | null;\n    [index: number]: Element;\n}\n\ninterface HTMLCollection extends HTMLCollectionBase {\n    /**\n     * Retrieves a select object or an object from an options collection.\n     */\n    namedItem(name: string): Element | null;\n}\n\ndeclare var HTMLCollection: {\n    prototype: HTMLCollection;\n    new(): HTMLCollection;\n};\n\ninterface HTMLCollectionOf<T extends Element> extends HTMLCollectionBase {\n    item(index: number): T | null;\n    namedItem(name: string): T | null;\n    [index: number]: T;\n}\n\ninterface HTMLDListElement extends HTMLElement {\n    /** @deprecated */\n    compact: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDListElement: {\n    prototype: HTMLDListElement;\n    new(): HTMLDListElement;\n};\n\ninterface HTMLDataElement extends HTMLElement {\n    value: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDataElement: {\n    prototype: HTMLDataElement;\n    new(): HTMLDataElement;\n};\n\ninterface HTMLDataListElement extends HTMLElement {\n    readonly options: HTMLCollectionOf<HTMLOptionElement>;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDataListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDataListElement: {\n    prototype: HTMLDataListElement;\n    new(): HTMLDataListElement;\n};\n\ninterface HTMLDetailsElement extends HTMLElement {\n    open: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDetailsElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDetailsElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDetailsElement: {\n    prototype: HTMLDetailsElement;\n    new(): HTMLDetailsElement;\n};\n\ninterface HTMLDialogElement extends HTMLElement {\n    open: boolean;\n    returnValue: string;\n    close(returnValue?: string): void;\n    show(): void;\n    showModal(): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDialogElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDialogElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDialogElement: {\n    prototype: HTMLDialogElement;\n    new(): HTMLDialogElement;\n};\n\ninterface HTMLDirectoryElement extends HTMLElement {\n    /** @deprecated */\n    compact: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDirectoryElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDirectoryElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDirectoryElement: {\n    prototype: HTMLDirectoryElement;\n    new(): HTMLDirectoryElement;\n};\n\ninterface HTMLDivElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDivElement: {\n    prototype: HTMLDivElement;\n    new(): HTMLDivElement;\n};\n\ninterface HTMLDocument extends Document {\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: HTMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: HTMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLDocument: {\n    prototype: HTMLDocument;\n    new(): HTMLDocument;\n};\n\ninterface HTMLElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, DocumentAndElementEventHandlersEventMap {\n}\n\ninterface HTMLElement extends Element, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable, HTMLOrSVGElement, ElementCSSInlineStyle {\n    accessKey: string;\n    readonly accessKeyLabel: string;\n    autocapitalize: string;\n    dir: string;\n    draggable: boolean;\n    hidden: boolean;\n    innerText: string;\n    lang: string;\n    readonly offsetHeight: number;\n    readonly offsetLeft: number;\n    readonly offsetParent: Element | null;\n    readonly offsetTop: number;\n    readonly offsetWidth: number;\n    spellcheck: boolean;\n    title: string;\n    translate: boolean;\n    click(): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLElement: {\n    prototype: HTMLElement;\n    new(): HTMLElement;\n};\n\ninterface HTMLEmbedElement extends HTMLElement, GetSVGDocument {\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    hidden: any;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    /** @deprecated */\n    name: string;\n    /**\n     * Retrieves the palette used for the embedded document.\n     */\n    readonly palette: string;\n    /**\n     * Retrieves the URL of the plug-in used to view an embedded document.\n     */\n    readonly pluginspage: string;\n    readonly readyState: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    src: string;\n    /**\n     * Sets or retrieves the height and width units of the embed object.\n     */\n    units: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLEmbedElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLEmbedElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLEmbedElement: {\n    prototype: HTMLEmbedElement;\n    new(): HTMLEmbedElement;\n};\n\ninterface HTMLFieldSetElement extends HTMLElement {\n    disabled: boolean;\n    readonly elements: HTMLCollection;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    name: string;\n    readonly type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFieldSetElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFieldSetElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLFieldSetElement: {\n    prototype: HTMLFieldSetElement;\n    new(): HTMLFieldSetElement;\n};\n\ninterface HTMLFontElement extends HTMLElement {\n    /** @deprecated */\n    color: string;\n    /**\n     * Sets or retrieves the current typeface family.\n     */\n    /** @deprecated */\n    face: string;\n    /** @deprecated */\n    size: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFontElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLFontElement: {\n    prototype: HTMLFontElement;\n    new(): HTMLFontElement;\n};\n\ninterface HTMLFormControlsCollection extends HTMLCollectionBase {\n    /**\n     * element = collection[name]\n     */\n    namedItem(name: string): RadioNodeList | Element | null;\n}\n\ndeclare var HTMLFormControlsCollection: {\n    prototype: HTMLFormControlsCollection;\n    new(): HTMLFormControlsCollection;\n};\n\ninterface HTMLFormElement extends HTMLElement {\n    /**\n     * Sets or retrieves a list of character encodings for input data that must be accepted by the server processing the form.\n     */\n    acceptCharset: string;\n    /**\n     * Sets or retrieves the URL to which the form content is sent for processing.\n     */\n    action: string;\n    /**\n     * Specifies whether autocomplete is applied to an editable text field.\n     */\n    autocomplete: string;\n    /**\n     * Retrieves a collection, in source order, of all controls in a given form.\n     */\n    readonly elements: HTMLFormControlsCollection;\n    /**\n     * Sets or retrieves the MIME encoding for the form.\n     */\n    encoding: string;\n    /**\n     * Sets or retrieves the encoding type for the form.\n     */\n    enctype: string;\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    readonly length: number;\n    /**\n     * Sets or retrieves how to send the form data to the server.\n     */\n    method: string;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Designates a form that is not validated when submitted.\n     */\n    noValidate: boolean;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    target: string;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Fires when the user resets a form.\n     */\n    reset(): void;\n    /**\n     * Fires when a FORM is about to be submitted.\n     */\n    submit(): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFormElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFormElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    [index: number]: Element;\n    [name: string]: any;\n}\n\ndeclare var HTMLFormElement: {\n    prototype: HTMLFormElement;\n    new(): HTMLFormElement;\n};\n\ninterface HTMLFrameElement extends HTMLElement {\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    /** @deprecated */\n    readonly contentDocument: Document | null;\n    /**\n     * Retrieves the object of the specified.\n     */\n    /** @deprecated */\n    readonly contentWindow: WindowProxy | null;\n    /**\n     * Sets or retrieves whether to display a border for the frame.\n     */\n    /** @deprecated */\n    frameBorder: string;\n    /**\n     * Sets or retrieves a URI to a long description of the object.\n     */\n    /** @deprecated */\n    longDesc: string;\n    /**\n     * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\n     */\n    /** @deprecated */\n    marginHeight: string;\n    /**\n     * Sets or retrieves the left and right margin widths before displaying the text in a frame.\n     */\n    /** @deprecated */\n    marginWidth: string;\n    /**\n     * Sets or retrieves the frame name.\n     */\n    /** @deprecated */\n    name: string;\n    /**\n     * Sets or retrieves whether the user can resize the frame.\n     */\n    /** @deprecated */\n    noResize: boolean;\n    /**\n     * Sets or retrieves whether the frame can be scrolled.\n     */\n    /** @deprecated */\n    scrolling: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    /** @deprecated */\n    src: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLFrameElement: {\n    prototype: HTMLFrameElement;\n    new(): HTMLFrameElement;\n};\n\ninterface HTMLFrameSetElementEventMap extends HTMLElementEventMap, WindowEventHandlersEventMap {\n}\n\ninterface HTMLFrameSetElement extends HTMLElement, WindowEventHandlers {\n    /**\n     * Sets or retrieves the frame widths of the object.\n     */\n    /** @deprecated */\n    cols: string;\n    /**\n     * Sets or retrieves the frame heights of the object.\n     */\n    /** @deprecated */\n    rows: string;\n    addEventListener<K extends keyof HTMLFrameSetElementEventMap>(type: K, listener: (this: HTMLFrameSetElement, ev: HTMLFrameSetElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLFrameSetElementEventMap>(type: K, listener: (this: HTMLFrameSetElement, ev: HTMLFrameSetElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLFrameSetElement: {\n    prototype: HTMLFrameSetElement;\n    new(): HTMLFrameSetElement;\n};\n\ninterface HTMLHRElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    /** @deprecated */\n    color: string;\n    /**\n     * Sets or retrieves whether the horizontal rule is drawn with 3-D shading.\n     */\n    /** @deprecated */\n    noShade: boolean;\n    /** @deprecated */\n    size: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    /** @deprecated */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHRElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLHRElement: {\n    prototype: HTMLHRElement;\n    new(): HTMLHRElement;\n};\n\ninterface HTMLHeadElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLHeadElement: {\n    prototype: HTMLHeadElement;\n    new(): HTMLHeadElement;\n};\n\ninterface HTMLHeadingElement extends HTMLElement {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    /** @deprecated */\n    align: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadingElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHeadingElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLHeadingElement: {\n    prototype: HTMLHeadingElement;\n    new(): HTMLHeadingElement;\n};\n\ninterface HTMLHtmlElement extends HTMLElement {\n    /**\n     * Sets or retrieves the DTD version that governs the current document.\n     */\n    /** @deprecated */\n    version: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHtmlElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLHtmlElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLHtmlElement: {\n    prototype: HTMLHtmlElement;\n    new(): HTMLHtmlElement;\n};\n\ninterface HTMLHyperlinkElementUtils {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    username: string;\n}\n\ninterface HTMLIFrameElement extends HTMLElement, GetSVGDocument {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    allowFullscreen: boolean;\n    allowPaymentRequest: boolean;\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    readonly contentDocument: Document | null;\n    /**\n     * Retrieves the object of the specified.\n     */\n    readonly contentWindow: Window | null;\n    /**\n     * Sets or retrieves whether to display a border for the frame.\n     */\n    /** @deprecated */\n    frameBorder: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    /**\n     * Sets or retrieves a URI to a long description of the object.\n     */\n    /** @deprecated */\n    longDesc: string;\n    /**\n     * Sets or retrieves the top and bottom margin heights before displaying the text in a frame.\n     */\n    /** @deprecated */\n    marginHeight: string;\n    /**\n     * Sets or retrieves the left and right margin widths before displaying the text in a frame.\n     */\n    /** @deprecated */\n    marginWidth: string;\n    /**\n     * Sets or retrieves the frame name.\n     */\n    name: string;\n    readonly referrerPolicy: ReferrerPolicy;\n    readonly sandbox: DOMTokenList;\n    /**\n     * Sets or retrieves whether the frame can be scrolled.\n     */\n    /** @deprecated */\n    scrolling: string;\n    /**\n     * Sets or retrieves a URL to be loaded by the object.\n     */\n    src: string;\n    /**\n     * Sets or retrives the content of the page that is to contain.\n     */\n    srcdoc: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLIFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLIFrameElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLIFrameElement: {\n    prototype: HTMLIFrameElement;\n    new(): HTMLIFrameElement;\n};\n\ninterface HTMLImageElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Specifies the properties of a border drawn around an object.\n     */\n    /** @deprecated */\n    border: string;\n    /**\n     * Retrieves whether the object is fully loaded.\n     */\n    readonly complete: boolean;\n    crossOrigin: string | null;\n    readonly currentSrc: string;\n    decoding: "async" | "sync" | "auto";\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: number;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    /** @deprecated */\n    hspace: number;\n    /**\n     * Sets or retrieves whether the image is a server-side image map.\n     */\n    isMap: boolean;\n    /**\n     * Sets or retrieves a Uniform Resource Identifier (URI) to a long description of the object.\n     */\n    /** @deprecated */\n    longDesc: string;\n    /** @deprecated */\n    lowsrc: string;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    /** @deprecated */\n    name: string;\n    /**\n     * The original height of the image resource before sizing.\n     */\n    readonly naturalHeight: number;\n    /**\n     * The original width of the image resource before sizing.\n     */\n    readonly naturalWidth: number;\n    referrerPolicy: string;\n    sizes: string;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcset: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    /**\n     * Sets or retrieves the vertical margin for the object.\n     */\n    /** @deprecated */\n    vspace: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: number;\n    readonly x: number;\n    readonly y: number;\n    decode(): Promise<void>;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLImageElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLImageElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLImageElement: {\n    prototype: HTMLImageElement;\n    new(): HTMLImageElement;\n};\n\ninterface HTMLInputElement extends HTMLElement {\n    /**\n     * Sets or retrieves a comma-separated list of content types.\n     */\n    accept: string;\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves a text alternative to the graphic.\n     */\n    alt: string;\n    /**\n     * Specifies whether autocomplete is applied to an editable text field.\n     */\n    autocomplete: string;\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    /**\n     * Sets or retrieves the state of the check box or radio button.\n     */\n    checked: boolean;\n    /**\n     * Sets or retrieves the state of the check box or radio button.\n     */\n    defaultChecked: boolean;\n    /**\n     * Sets or retrieves the initial contents of the object.\n     */\n    defaultValue: string;\n    dirName: string;\n    disabled: boolean;\n    /**\n     * Returns a FileList object on a file type input object.\n     */\n    files: FileList | null;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Overrides the action attribute (where the data on a form is sent) on the parent form element.\n     */\n    formAction: string;\n    /**\n     * Used to override the encoding (formEnctype attribute) specified on the form element.\n     */\n    formEnctype: string;\n    /**\n     * Overrides the submit method attribute previously specified on a form element.\n     */\n    formMethod: string;\n    /**\n     * Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option.\n     */\n    formNoValidate: boolean;\n    /**\n     * Overrides the target attribute on a form element.\n     */\n    formTarget: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: number;\n    indeterminate: boolean;\n    readonly labels: NodeListOf<HTMLLabelElement> | null;\n    /**\n     * Specifies the ID of a pre-defined datalist of options for an input element.\n     */\n    readonly list: HTMLElement | null;\n    /**\n     * Defines the maximum acceptable value for an input element with type="number".When used with the min and step attributes, lets you control the range and increment (such as only even numbers) that the user can enter into an input field.\n     */\n    max: string;\n    /**\n     * Sets or retrieves the maximum number of characters that the user can enter in a text control.\n     */\n    maxLength: number;\n    /**\n     * Defines the minimum acceptable value for an input element with type="number". When used with the max and step attributes, lets you control the range and increment (such as even numbers only) that the user can enter into an input field.\n     */\n    min: string;\n    minLength: number;\n    /**\n     * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\n     */\n    multiple: boolean;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Gets or sets a string containing a regular expression that the user\'s input must match.\n     */\n    pattern: string;\n    /**\n     * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\n     */\n    placeholder: string;\n    readOnly: boolean;\n    /**\n     * When present, marks an element that can\'t be submitted without a value.\n     */\n    required: boolean;\n    selectionDirection: string | null;\n    /**\n     * Gets or sets the end position or offset of a text selection.\n     */\n    selectionEnd: number | null;\n    /**\n     * Gets or sets the starting position or offset of a text selection.\n     */\n    selectionStart: number | null;\n    size: number;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    /**\n     * Defines an increment or jump between values that you want to allow the user to enter. When used with the max and min attributes, lets you control the range and increment (for example, allow only even numbers) that the user can enter into an input field.\n     */\n    step: string;\n    /**\n     * Returns the content type of the object.\n     */\n    type: string;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    /** @deprecated */\n    useMap: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Returns the value of the data at the cursor\'s current position.\n     */\n    value: string;\n    valueAsDate: any;\n    /**\n     * Returns the input field value as a number.\n     */\n    valueAsNumber: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: number;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Makes the selection equal to the current object.\n     */\n    select(): void;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    setRangeText(replacement: string): void;\n    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;\n    /**\n     * Sets the start and end positions of a selection in a text field.\n     * @param start The offset into the text field for the start of the selection.\n     * @param end The offset into the text field for the end of the selection.\n     * @param direction The direction in which the selection is performed.\n     */\n    setSelectionRange(start: number, end: number, direction?: "forward" | "backward" | "none"): void;\n    /**\n     * Decrements a range input control\'s value by the value given by the Step attribute. If the optional parameter is used, it will decrement the input control\'s step value multiplied by the parameter\'s value.\n     * @param n Value to decrement the value by.\n     */\n    stepDown(n?: number): void;\n    /**\n     * Increments a range input control\'s value by the value given by the Step attribute. If the optional parameter is used, will increment the input control\'s value by that value.\n     * @param n Value to increment the value by.\n     */\n    stepUp(n?: number): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLInputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLInputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLInputElement: {\n    prototype: HTMLInputElement;\n    new(): HTMLInputElement;\n};\n\ninterface HTMLLIElement extends HTMLElement {\n    /** @deprecated */\n    type: string;\n    /**\n     * Sets or retrieves the value of a list item.\n     */\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLIElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLIElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLLIElement: {\n    prototype: HTMLLIElement;\n    new(): HTMLLIElement;\n};\n\ninterface HTMLLabelElement extends HTMLElement {\n    readonly control: HTMLElement | null;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Sets or retrieves the object to which the given label object is assigned.\n     */\n    htmlFor: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLabelElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLabelElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLLabelElement: {\n    prototype: HTMLLabelElement;\n    new(): HTMLLabelElement;\n};\n\ninterface HTMLLegendElement extends HTMLElement {\n    /** @deprecated */\n    align: string;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLegendElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLegendElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLLegendElement: {\n    prototype: HTMLLegendElement;\n    new(): HTMLLegendElement;\n};\n\ninterface HTMLLinkElement extends HTMLElement, LinkStyle {\n    as: string;\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    /** @deprecated */\n    charset: string;\n    crossOrigin: string | null;\n    disabled: boolean;\n    /**\n     * Sets or retrieves a destination URL or an anchor point.\n     */\n    href: string;\n    /**\n     * Sets or retrieves the language code of the object.\n     */\n    hreflang: string;\n    integrity: string;\n    /**\n     * Sets or retrieves the media type.\n     */\n    media: string;\n    referrerPolicy: string;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    rel: string;\n    readonly relList: DOMTokenList;\n    /**\n     * Sets or retrieves the relationship between the object and the destination of the link.\n     */\n    /** @deprecated */\n    rev: string;\n    readonly sizes: DOMTokenList;\n    /**\n     * Sets or retrieves the window or frame at which to target content.\n     */\n    /** @deprecated */\n    target: string;\n    /**\n     * Sets or retrieves the MIME type of the object.\n     */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLinkElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLLinkElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLLinkElement: {\n    prototype: HTMLLinkElement;\n    new(): HTMLLinkElement;\n};\n\ninterface HTMLMainElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMainElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMainElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMainElement: {\n    prototype: HTMLMainElement;\n    new(): HTMLMainElement;\n};\n\ninterface HTMLMapElement extends HTMLElement {\n    /**\n     * Retrieves a collection of the area objects defined for the given map object.\n     */\n    readonly areas: HTMLCollection;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMapElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMapElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMapElement: {\n    prototype: HTMLMapElement;\n    new(): HTMLMapElement;\n};\n\ninterface HTMLMarqueeElementEventMap extends HTMLElementEventMap {\n    "bounce": Event;\n    "finish": Event;\n    "start": Event;\n}\n\ninterface HTMLMarqueeElement extends HTMLElement {\n    /** @deprecated */\n    behavior: string;\n    /** @deprecated */\n    bgColor: string;\n    /** @deprecated */\n    direction: string;\n    /** @deprecated */\n    height: string;\n    /** @deprecated */\n    hspace: number;\n    /** @deprecated */\n    loop: number;\n    /** @deprecated */\n    onbounce: ((this: HTMLMarqueeElement, ev: Event) => any) | null;\n    /** @deprecated */\n    onfinish: ((this: HTMLMarqueeElement, ev: Event) => any) | null;\n    /** @deprecated */\n    onstart: ((this: HTMLMarqueeElement, ev: Event) => any) | null;\n    /** @deprecated */\n    scrollAmount: number;\n    /** @deprecated */\n    scrollDelay: number;\n    /** @deprecated */\n    trueSpeed: boolean;\n    /** @deprecated */\n    vspace: number;\n    /** @deprecated */\n    width: string;\n    /** @deprecated */\n    start(): void;\n    /** @deprecated */\n    stop(): void;\n    addEventListener<K extends keyof HTMLMarqueeElementEventMap>(type: K, listener: (this: HTMLMarqueeElement, ev: HTMLMarqueeElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLMarqueeElementEventMap>(type: K, listener: (this: HTMLMarqueeElement, ev: HTMLMarqueeElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMarqueeElement: {\n    prototype: HTMLMarqueeElement;\n    new(): HTMLMarqueeElement;\n};\n\ninterface HTMLMediaElementEventMap extends HTMLElementEventMap {\n    "encrypted": MediaEncryptedEvent;\n    "msneedkey": Event;\n}\n\ninterface HTMLMediaElement extends HTMLElement {\n    /**\n     * Returns an AudioTrackList object with the audio tracks for a given video element.\n     */\n    readonly audioTracks: AudioTrackList;\n    /**\n     * Gets or sets a value that indicates whether to start playing the media automatically.\n     */\n    autoplay: boolean;\n    /**\n     * Gets a collection of buffered time ranges.\n     */\n    readonly buffered: TimeRanges;\n    /**\n     * Gets or sets a flag that indicates whether the client provides a set of controls for the media (in case the developer does not include controls for the player).\n     */\n    controls: boolean;\n    crossOrigin: string | null;\n    /**\n     * Gets the address or URL of the current media resource that is selected by IHTMLMediaElement.\n     */\n    readonly currentSrc: string;\n    /**\n     * Gets or sets the current playback position, in seconds.\n     */\n    currentTime: number;\n    defaultMuted: boolean;\n    /**\n     * Gets or sets the default playback rate when the user is not using fast forward or reverse for a video or audio resource.\n     */\n    defaultPlaybackRate: number;\n    /**\n     * Returns the duration in seconds of the current media resource. A NaN value is returned if duration is not available, or Infinity if the media resource is streaming.\n     */\n    readonly duration: number;\n    /**\n     * Gets information about whether the playback has ended or not.\n     */\n    readonly ended: boolean;\n    /**\n     * Returns an object representing the current error state of the audio or video element.\n     */\n    readonly error: MediaError | null;\n    /**\n     * Gets or sets a flag to specify whether playback should restart after it completes.\n     */\n    loop: boolean;\n    readonly mediaKeys: MediaKeys | null;\n    /**\n     * Specifies the purpose of the audio or video media, such as background audio or alerts.\n     */\n    msAudioCategory: string;\n    /**\n     * Specifies the output device id that the audio will be sent to.\n     */\n    msAudioDeviceType: string;\n    readonly msGraphicsTrustStatus: MSGraphicsTrust;\n    /**\n     * Gets the MSMediaKeys object, which is used for decrypting media data, that is associated with this media element.\n     */\n    /** @deprecated */\n    readonly msKeys: MSMediaKeys;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Specifies whether or not to enable low-latency playback on the media element.\n     */\n    msRealTime: boolean;\n    /**\n     * Gets or sets a flag that indicates whether the audio (either audio or the audio track on video media) is muted.\n     */\n    muted: boolean;\n    /**\n     * Gets the current network activity for the element.\n     */\n    readonly networkState: number;\n    onencrypted: ((this: HTMLMediaElement, ev: MediaEncryptedEvent) => any) | null;\n    /** @deprecated */\n    onmsneedkey: ((this: HTMLMediaElement, ev: Event) => any) | null;\n    /**\n     * Gets a flag that specifies whether playback is paused.\n     */\n    readonly paused: boolean;\n    /**\n     * Gets or sets the current rate of speed for the media resource to play. This speed is expressed as a multiple of the normal speed of the media resource.\n     */\n    playbackRate: number;\n    /**\n     * Gets TimeRanges for the current media resource that has been played.\n     */\n    readonly played: TimeRanges;\n    /**\n     * Gets or sets the current playback position, in seconds.\n     */\n    preload: string;\n    readonly readyState: number;\n    /**\n     * Returns a TimeRanges object that represents the ranges of the current media resource that can be seeked.\n     */\n    readonly seekable: TimeRanges;\n    /**\n     * Gets a flag that indicates whether the client is currently moving to a new playback position in the media resource.\n     */\n    readonly seeking: boolean;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcObject: MediaStream | MediaSource | Blob | null;\n    readonly textTracks: TextTrackList;\n    readonly videoTracks: VideoTrackList;\n    /**\n     * Gets or sets the volume level for audio portions of the media element.\n     */\n    volume: number;\n    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack;\n    /**\n     * Returns a string that specifies whether the client can play a given media resource type.\n     */\n    canPlayType(type: string): CanPlayTypeResult;\n    /**\n     * Resets the audio or video object and loads a new media resource.\n     */\n    load(): void;\n    /**\n     * Clears all effects from the media pipeline.\n     */\n    msClearEffects(): void;\n    msGetAsCastingSource(): any;\n    /**\n     * Inserts the specified audio effect into media pipeline.\n     */\n    msInsertAudioEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\n    /** @deprecated */\n    msSetMediaKeys(mediaKeys: MSMediaKeys): void;\n    /**\n     * Specifies the media protection manager for a given media pipeline.\n     */\n    msSetMediaProtectionManager(mediaProtectionManager?: any): void;\n    /**\n     * Pauses the current playback and sets paused to TRUE. This can be used to test whether the media is playing or paused. You can also use the pause or play events to tell whether the media is playing or not.\n     */\n    pause(): void;\n    /**\n     * Loads and starts playback of a media resource.\n     */\n    play(): Promise<void>;\n    setMediaKeys(mediaKeys: MediaKeys | null): Promise<void>;\n    readonly HAVE_CURRENT_DATA: number;\n    readonly HAVE_ENOUGH_DATA: number;\n    readonly HAVE_FUTURE_DATA: number;\n    readonly HAVE_METADATA: number;\n    readonly HAVE_NOTHING: number;\n    readonly NETWORK_EMPTY: number;\n    readonly NETWORK_IDLE: number;\n    readonly NETWORK_LOADING: number;\n    readonly NETWORK_NO_SOURCE: number;\n    addEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLMediaElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLMediaElementEventMap>(type: K, listener: (this: HTMLMediaElement, ev: HTMLMediaElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMediaElement: {\n    prototype: HTMLMediaElement;\n    new(): HTMLMediaElement;\n    readonly HAVE_CURRENT_DATA: number;\n    readonly HAVE_ENOUGH_DATA: number;\n    readonly HAVE_FUTURE_DATA: number;\n    readonly HAVE_METADATA: number;\n    readonly HAVE_NOTHING: number;\n    readonly NETWORK_EMPTY: number;\n    readonly NETWORK_IDLE: number;\n    readonly NETWORK_LOADING: number;\n    readonly NETWORK_NO_SOURCE: number;\n};\n\ninterface HTMLMenuElement extends HTMLElement {\n    /** @deprecated */\n    compact: boolean;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMenuElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMenuElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMenuElement: {\n    prototype: HTMLMenuElement;\n    new(): HTMLMenuElement;\n};\n\ninterface HTMLMetaElement extends HTMLElement {\n    /**\n     * Gets or sets meta-information to associate with httpEquiv or name.\n     */\n    content: string;\n    /**\n     * Gets or sets information used to bind the value of a content attribute of a meta element to an HTTP response header.\n     */\n    httpEquiv: string;\n    /**\n     * Sets or retrieves the value specified in the content attribute of the meta object.\n     */\n    name: string;\n    /**\n     * Sets or retrieves a scheme to be used in interpreting the value of a property specified for the object.\n     */\n    /** @deprecated */\n    scheme: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMetaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMetaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMetaElement: {\n    prototype: HTMLMetaElement;\n    new(): HTMLMetaElement;\n};\n\ninterface HTMLMeterElement extends HTMLElement {\n    high: number;\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    low: number;\n    max: number;\n    min: number;\n    optimum: number;\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMeterElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLMeterElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLMeterElement: {\n    prototype: HTMLMeterElement;\n    new(): HTMLMeterElement;\n};\n\ninterface HTMLModElement extends HTMLElement {\n    /**\n     * Sets or retrieves reference information about the object.\n     */\n    cite: string;\n    /**\n     * Sets or retrieves the date and time of a modification to the object.\n     */\n    dateTime: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLModElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLModElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLModElement: {\n    prototype: HTMLModElement;\n    new(): HTMLModElement;\n};\n\ninterface HTMLOListElement extends HTMLElement {\n    /** @deprecated */\n    compact: boolean;\n    reversed: boolean;\n    /**\n     * The starting number.\n     */\n    start: number;\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLOListElement: {\n    prototype: HTMLOListElement;\n    new(): HTMLOListElement;\n};\n\ninterface HTMLObjectElement extends HTMLElement, GetSVGDocument {\n    /**\n     * Retrieves a string of the URL where the object tag can be found. This is often the href of the document that the object is in, or the value set by a base element.\n     */\n    readonly BaseHref: string;\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves a character string that can be used to implement your own archive functionality for the object.\n     */\n    /** @deprecated */\n    archive: string;\n    /** @deprecated */\n    border: string;\n    /**\n     * Sets or retrieves the URL of the file containing the compiled Java class.\n     */\n    /** @deprecated */\n    code: string;\n    /**\n     * Sets or retrieves the URL of the component.\n     */\n    /** @deprecated */\n    codeBase: string;\n    /**\n     * Sets or retrieves the Internet media type for the code associated with the object.\n     */\n    /** @deprecated */\n    codeType: string;\n    /**\n     * Retrieves the document object of the page or frame.\n     */\n    readonly contentDocument: Document | null;\n    /**\n     * Sets or retrieves the URL that references the data of the object.\n     */\n    data: string;\n    /** @deprecated */\n    declare: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    height: string;\n    /** @deprecated */\n    hspace: number;\n    /**\n     * Gets or sets whether the DLNA PlayTo device is available.\n     */\n    msPlayToDisabled: boolean;\n    /**\n     * Gets or sets the path to the preferred media source. This enables the Play To target device to stream the media content, which can be DRM protected, from a different location, such as a cloud media server.\n     */\n    msPlayToPreferredSourceUri: string;\n    /**\n     * Gets or sets the primary DLNA PlayTo device.\n     */\n    msPlayToPrimary: boolean;\n    /**\n     * Gets the source associated with the media element for use by the PlayToManager.\n     */\n    readonly msPlayToSource: any;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    readonly readyState: number;\n    /**\n     * Sets or retrieves a message to be displayed while an object is loading.\n     */\n    /** @deprecated */\n    standby: string;\n    /**\n     * Sets or retrieves the MIME type of the object.\n     */\n    type: string;\n    typemustmatch: boolean;\n    /**\n     * Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.\n     */\n    useMap: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /** @deprecated */\n    vspace: number;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    width: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLObjectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLObjectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLObjectElement: {\n    prototype: HTMLObjectElement;\n    new(): HTMLObjectElement;\n};\n\ninterface HTMLOptGroupElement extends HTMLElement {\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Sets or retrieves a value that you can use to implement your own label functionality for the object.\n     */\n    label: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptGroupElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptGroupElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLOptGroupElement: {\n    prototype: HTMLOptGroupElement;\n    new(): HTMLOptGroupElement;\n};\n\ninterface HTMLOptionElement extends HTMLElement {\n    /**\n     * Sets or retrieves the status of an option.\n     */\n    defaultSelected: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    /**\n     * Sets or retrieves the ordinal position of an option in a list box.\n     */\n    readonly index: number;\n    /**\n     * Sets or retrieves a value that you can use to implement your own label functionality for the object.\n     */\n    label: string;\n    /**\n     * Sets or retrieves whether the option in the list box is the default item.\n     */\n    selected: boolean;\n    /**\n     * Sets or retrieves the text string specified by the option tag.\n     */\n    text: string;\n    /**\n     * Sets or retrieves the value which is returned to the server when the form control is submitted.\n     */\n    value: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLOptionElement: {\n    prototype: HTMLOptionElement;\n    new(): HTMLOptionElement;\n};\n\ninterface HTMLOptionsCollection extends HTMLCollectionOf<HTMLOptionElement> {\n    /**\n     * Returns the number of elements in the collection.\n     * When set to a smaller number, truncates the number of option elements in the corresponding container.\n     * When set to a greater number, adds new blank option elements to that container.\n     */\n    length: number;\n    /**\n     * Returns the index of the first selected item, if any, or \u22121 if there is no selected\n     * item.\n     * Can be set, to change the selection.\n     */\n    selectedIndex: number;\n    /**\n     * Inserts element before the node given by before.\n     * The before argument can be a number, in which case element is inserted before the item with that number, or an element from the\n     * collection, in which case element is inserted before that element.\n     * If before is omitted, null, or a number out of range, then element will be added at the end of the list.\n     * This method will throw a "HierarchyRequestError" DOMException if\n     * element is an ancestor of the element into which it is to be inserted.\n     */\n    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;\n    /**\n     * Removes the item with index index from the collection.\n     */\n    remove(index: number): void;\n}\n\ndeclare var HTMLOptionsCollection: {\n    prototype: HTMLOptionsCollection;\n    new(): HTMLOptionsCollection;\n};\n\ninterface HTMLOrSVGElement {\n    readonly dataset: DOMStringMap;\n    nonce: string;\n    tabIndex: number;\n    blur(): void;\n    focus(options?: FocusOptions): void;\n}\n\ninterface HTMLOutputElement extends HTMLElement {\n    defaultValue: string;\n    readonly form: HTMLFormElement | null;\n    readonly htmlFor: DOMTokenList;\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    name: string;\n    readonly type: string;\n    readonly validationMessage: string;\n    readonly validity: ValidityState;\n    value: string;\n    readonly willValidate: boolean;\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOutputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLOutputElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLOutputElement: {\n    prototype: HTMLOutputElement;\n    new(): HTMLOutputElement;\n};\n\ninterface HTMLParagraphElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParagraphElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParagraphElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLParagraphElement: {\n    prototype: HTMLParagraphElement;\n    new(): HTMLParagraphElement;\n};\n\ninterface HTMLParamElement extends HTMLElement {\n    /**\n     * Sets or retrieves the name of an input parameter for an element.\n     */\n    name: string;\n    /**\n     * Sets or retrieves the content type of the resource designated by the value attribute.\n     */\n    /** @deprecated */\n    type: string;\n    /**\n     * Sets or retrieves the value of an input parameter for an element.\n     */\n    value: string;\n    /**\n     * Sets or retrieves the data type of the value attribute.\n     */\n    /** @deprecated */\n    valueType: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParamElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLParamElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLParamElement: {\n    prototype: HTMLParamElement;\n    new(): HTMLParamElement;\n};\n\ninterface HTMLPictureElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPictureElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPictureElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLPictureElement: {\n    prototype: HTMLPictureElement;\n    new(): HTMLPictureElement;\n};\n\ninterface HTMLPreElement extends HTMLElement {\n    /**\n     * Sets or gets a value that you can use to implement your own width functionality for the object.\n     */\n    /** @deprecated */\n    width: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPreElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLPreElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLPreElement: {\n    prototype: HTMLPreElement;\n    new(): HTMLPreElement;\n};\n\ninterface HTMLProgressElement extends HTMLElement {\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    /**\n     * Defines the maximum, or "done" value for a progress element.\n     */\n    max: number;\n    /**\n     * Returns the quotient of value/max when the value attribute is set (determinate progress bar), or -1 when the value attribute is missing (indeterminate progress bar).\n     */\n    readonly position: number;\n    /**\n     * Sets or gets the current value of a progress element. The value must be a non-negative number between 0 and the max value.\n     */\n    value: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLProgressElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLProgressElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLProgressElement: {\n    prototype: HTMLProgressElement;\n    new(): HTMLProgressElement;\n};\n\ninterface HTMLQuoteElement extends HTMLElement {\n    /**\n     * Sets or retrieves reference information about the object.\n     */\n    cite: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLQuoteElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLQuoteElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLQuoteElement: {\n    prototype: HTMLQuoteElement;\n    new(): HTMLQuoteElement;\n};\n\ninterface HTMLScriptElement extends HTMLElement {\n    async: boolean;\n    /**\n     * Sets or retrieves the character set used to encode the object.\n     */\n    /** @deprecated */\n    charset: string;\n    crossOrigin: string | null;\n    /**\n     * Sets or retrieves the status of the script.\n     */\n    defer: boolean;\n    /**\n     * Sets or retrieves the event for which the script is written.\n     */\n    /** @deprecated */\n    event: string;\n    /**\n     * Sets or retrieves the object that is bound to the event script.\n     */\n    /** @deprecated */\n    htmlFor: string;\n    integrity: string;\n    noModule: boolean;\n    referrerPolicy: string;\n    /**\n     * Retrieves the URL to an external file that contains the source code or data.\n     */\n    src: string;\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    /**\n     * Sets or retrieves the MIME type for the associated scripting engine.\n     */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLScriptElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLScriptElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLScriptElement: {\n    prototype: HTMLScriptElement;\n    new(): HTMLScriptElement;\n};\n\ninterface HTMLSelectElement extends HTMLElement {\n    autocomplete: string;\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    /**\n     * Sets or retrieves the number of objects in a collection.\n     */\n    length: number;\n    /**\n     * Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list.\n     */\n    multiple: boolean;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    readonly options: HTMLOptionsCollection;\n    /**\n     * When present, marks an element that can\'t be submitted without a value.\n     */\n    required: boolean;\n    /**\n     * Sets or retrieves the index of the selected option in a select object.\n     */\n    selectedIndex: number;\n    readonly selectedOptions: HTMLCollectionOf<HTMLOptionElement>;\n    /**\n     * Sets or retrieves the number of rows in the list box.\n     */\n    size: number;\n    /**\n     * Retrieves the type of select control based on the value of the MULTIPLE attribute.\n     */\n    readonly type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Sets or retrieves the value which is returned to the server when the form control is submitted.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Adds an element to the areas, controlRange, or options collection.\n     * @param element Variant of type Number that specifies the index position in the collection where the element is placed. If no value is given, the method places the element at the end of the collection.\n     * @param before Variant of type Object that specifies an element to insert before, or null to append the object to the collection.\n     */\n    add(element: HTMLOptionElement | HTMLOptGroupElement, before?: HTMLElement | number | null): void;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    /**\n     * Retrieves a select object or an object from an options collection.\n     * @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is an integer, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.\n     * @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.\n     */\n    item(index: number): Element | null;\n    /**\n     * Retrieves a select object or an object from an options collection.\n     * @param namedItem A String that specifies the name or id property of the object to retrieve. A collection is returned if more than one match is made.\n     */\n    namedItem(name: string): HTMLOptionElement | null;\n    /**\n     * Removes an element from the collection.\n     * @param index Number that specifies the zero-based index of the element to remove from the collection.\n     */\n    remove(): void;\n    remove(index: number): void;\n    reportValidity(): boolean;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSelectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSelectElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    [name: number]: HTMLOptionElement | HTMLOptGroupElement;\n}\n\ndeclare var HTMLSelectElement: {\n    prototype: HTMLSelectElement;\n    new(): HTMLSelectElement;\n};\n\ninterface HTMLSlotElement extends HTMLElement {\n    name: string;\n    assignedElements(options?: AssignedNodesOptions): Element[];\n    assignedNodes(options?: AssignedNodesOptions): Node[];\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSlotElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSlotElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLSlotElement: {\n    prototype: HTMLSlotElement;\n    new(): HTMLSlotElement;\n};\n\ninterface HTMLSourceElement extends HTMLElement {\n    /**\n     * Gets or sets the intended media type of the media source.\n     */\n    media: string;\n    sizes: string;\n    /**\n     * The address or URL of the a media resource that is to be considered.\n     */\n    src: string;\n    srcset: string;\n    /**\n     * Gets or sets the MIME type of a media resource.\n     */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSourceElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSourceElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLSourceElement: {\n    prototype: HTMLSourceElement;\n    new(): HTMLSourceElement;\n};\n\ninterface HTMLSpanElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSpanElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLSpanElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLSpanElement: {\n    prototype: HTMLSpanElement;\n    new(): HTMLSpanElement;\n};\n\ninterface HTMLStyleElement extends HTMLElement, LinkStyle {\n    /**\n     * Sets or retrieves the media type.\n     */\n    media: string;\n    /**\n     * Retrieves the CSS language in which the style sheet is written.\n     */\n    /** @deprecated */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLStyleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLStyleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLStyleElement: {\n    prototype: HTMLStyleElement;\n    new(): HTMLStyleElement;\n};\n\ninterface HTMLTableCaptionElement extends HTMLElement {\n    /**\n     * Sets or retrieves the alignment of the caption or legend.\n     */\n    /** @deprecated */\n    align: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCaptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCaptionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableCaptionElement: {\n    prototype: HTMLTableCaptionElement;\n    new(): HTMLTableCaptionElement;\n};\n\ninterface HTMLTableCellElement extends HTMLElement {\n    /**\n     * Sets or retrieves abbreviated text for the object.\n     */\n    abbr: string;\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    /**\n     * Sets or retrieves a comma-delimited list of conceptual categories associated with the object.\n     */\n    /** @deprecated */\n    axis: string;\n    /** @deprecated */\n    bgColor: string;\n    /**\n     * Retrieves the position of the object in the cells collection of a row.\n     */\n    readonly cellIndex: number;\n    /** @deprecated */\n    ch: string;\n    /** @deprecated */\n    chOff: string;\n    /**\n     * Sets or retrieves the number columns in the table that the object should span.\n     */\n    colSpan: number;\n    /**\n     * Sets or retrieves a list of header cells that provide information for the object.\n     */\n    headers: string;\n    /**\n     * Sets or retrieves the height of the object.\n     */\n    /** @deprecated */\n    height: string;\n    /**\n     * Sets or retrieves whether the browser automatically performs wordwrap.\n     */\n    /** @deprecated */\n    noWrap: boolean;\n    /**\n     * Sets or retrieves how many rows in a table the cell should span.\n     */\n    rowSpan: number;\n    /**\n     * Sets or retrieves the group of cells in a table to which the object\'s information applies.\n     */\n    scope: string;\n    /** @deprecated */\n    vAlign: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    /** @deprecated */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableCellElement: {\n    prototype: HTMLTableCellElement;\n    new(): HTMLTableCellElement;\n};\n\ninterface HTMLTableColElement extends HTMLElement {\n    /**\n     * Sets or retrieves the alignment of the object relative to the display or table.\n     */\n    /** @deprecated */\n    align: string;\n    /** @deprecated */\n    ch: string;\n    /** @deprecated */\n    chOff: string;\n    /**\n     * Sets or retrieves the number of columns in the group.\n     */\n    span: number;\n    /** @deprecated */\n    vAlign: string;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    /** @deprecated */\n    width: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableColElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableColElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableColElement: {\n    prototype: HTMLTableColElement;\n    new(): HTMLTableColElement;\n};\n\ninterface HTMLTableDataCellElement extends HTMLTableCellElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableDataCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableDataCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableDataCellElement: {\n    prototype: HTMLTableDataCellElement;\n    new(): HTMLTableDataCellElement;\n};\n\ninterface HTMLTableElement extends HTMLElement {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    /** @deprecated */\n    align: string;\n    /** @deprecated */\n    bgColor: string;\n    /**\n     * Sets or retrieves the width of the border to draw around the object.\n     */\n    /** @deprecated */\n    border: string;\n    /**\n     * Retrieves the caption object of a table.\n     */\n    caption: HTMLTableCaptionElement | null;\n    /**\n     * Sets or retrieves the amount of space between the border of the cell and the content of the cell.\n     */\n    /** @deprecated */\n    cellPadding: string;\n    /**\n     * Sets or retrieves the amount of space between cells in a table.\n     */\n    /** @deprecated */\n    cellSpacing: string;\n    /**\n     * Sets or retrieves the way the border frame around the table is displayed.\n     */\n    /** @deprecated */\n    frame: string;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    readonly rows: HTMLCollectionOf<HTMLTableRowElement>;\n    /**\n     * Sets or retrieves which dividing lines (inner borders) are displayed.\n     */\n    /** @deprecated */\n    rules: string;\n    /**\n     * Sets or retrieves a description and/or structure of the object.\n     */\n    /** @deprecated */\n    summary: string;\n    /**\n     * Retrieves a collection of all tBody objects in the table. Objects in this collection are in source order.\n     */\n    readonly tBodies: HTMLCollectionOf<HTMLTableSectionElement>;\n    /**\n     * Retrieves the tFoot object of the table.\n     */\n    tFoot: HTMLTableSectionElement | null;\n    /**\n     * Retrieves the tHead object of the table.\n     */\n    tHead: HTMLTableSectionElement | null;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    /** @deprecated */\n    width: string;\n    /**\n     * Creates an empty caption element in the table.\n     */\n    createCaption(): HTMLTableCaptionElement;\n    /**\n     * Creates an empty tBody element in the table.\n     */\n    createTBody(): HTMLTableSectionElement;\n    /**\n     * Creates an empty tFoot element in the table.\n     */\n    createTFoot(): HTMLTableSectionElement;\n    /**\n     * Returns the tHead element object if successful, or null otherwise.\n     */\n    createTHead(): HTMLTableSectionElement;\n    /**\n     * Deletes the caption element and its contents from the table.\n     */\n    deleteCaption(): void;\n    /**\n     * Removes the specified row (tr) from the element and from the rows collection.\n     * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\n     */\n    deleteRow(index: number): void;\n    /**\n     * Deletes the tFoot element and its contents from the table.\n     */\n    deleteTFoot(): void;\n    /**\n     * Deletes the tHead element and its contents from the table.\n     */\n    deleteTHead(): void;\n    /**\n     * Creates a new row (tr) in the table, and adds the row to the rows collection.\n     * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\n     */\n    insertRow(index?: number): HTMLTableRowElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableElement: {\n    prototype: HTMLTableElement;\n    new(): HTMLTableElement;\n};\n\ninterface HTMLTableHeaderCellElement extends HTMLTableCellElement {\n    scope: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableHeaderCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableHeaderCellElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableHeaderCellElement: {\n    prototype: HTMLTableHeaderCellElement;\n    new(): HTMLTableHeaderCellElement;\n};\n\ninterface HTMLTableRowElement extends HTMLElement {\n    /**\n     * Sets or retrieves how the object is aligned with adjacent text.\n     */\n    /** @deprecated */\n    align: string;\n    /** @deprecated */\n    bgColor: string;\n    /**\n     * Retrieves a collection of all cells in the table row.\n     */\n    readonly cells: HTMLCollectionOf<HTMLTableDataCellElement | HTMLTableHeaderCellElement>;\n    /** @deprecated */\n    ch: string;\n    /** @deprecated */\n    chOff: string;\n    /**\n     * Retrieves the position of the object in the rows collection for the table.\n     */\n    readonly rowIndex: number;\n    /**\n     * Retrieves the position of the object in the collection.\n     */\n    readonly sectionRowIndex: number;\n    /** @deprecated */\n    vAlign: string;\n    /**\n     * Removes the specified cell from the table row, as well as from the cells collection.\n     * @param index Number that specifies the zero-based position of the cell to remove from the table row. If no value is provided, the last cell in the cells collection is deleted.\n     */\n    deleteCell(index: number): void;\n    /**\n     * Creates a new cell in the table row, and adds the cell to the cells collection.\n     * @param index Number that specifies where to insert the cell in the tr. The default value is -1, which appends the new cell to the end of the cells collection.\n     */\n    insertCell(index?: number): HTMLTableDataCellElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableRowElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableRowElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableRowElement: {\n    prototype: HTMLTableRowElement;\n    new(): HTMLTableRowElement;\n};\n\ninterface HTMLTableSectionElement extends HTMLElement {\n    /**\n     * Sets or retrieves a value that indicates the table alignment.\n     */\n    /** @deprecated */\n    align: string;\n    /** @deprecated */\n    ch: string;\n    /** @deprecated */\n    chOff: string;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    readonly rows: HTMLCollectionOf<HTMLTableRowElement>;\n    /** @deprecated */\n    vAlign: string;\n    /**\n     * Removes the specified row (tr) from the element and from the rows collection.\n     * @param index Number that specifies the zero-based position in the rows collection of the row to remove.\n     */\n    deleteRow(index: number): void;\n    /**\n     * Creates a new row (tr) in the table, and adds the row to the rows collection.\n     * @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.\n     */\n    insertRow(index?: number): HTMLTableRowElement;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableSectionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTableSectionElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTableSectionElement: {\n    prototype: HTMLTableSectionElement;\n    new(): HTMLTableSectionElement;\n};\n\ninterface HTMLTemplateElement extends HTMLElement {\n    readonly content: DocumentFragment;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTemplateElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTemplateElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTemplateElement: {\n    prototype: HTMLTemplateElement;\n    new(): HTMLTemplateElement;\n};\n\ninterface HTMLTextAreaElement extends HTMLElement {\n    autocomplete: string;\n    /**\n     * Provides a way to direct a user to a specific field when a document loads. This can provide both direction and convenience for a user, reducing the need to click or tab to a field when a page opens. This attribute is true when present on an element, and false when missing.\n     */\n    autofocus: boolean;\n    /**\n     * Sets or retrieves the width of the object.\n     */\n    cols: number;\n    /**\n     * Sets or retrieves the initial contents of the object.\n     */\n    defaultValue: string;\n    dirName: string;\n    disabled: boolean;\n    /**\n     * Retrieves a reference to the form that the object is embedded in.\n     */\n    readonly form: HTMLFormElement | null;\n    readonly labels: NodeListOf<HTMLLabelElement>;\n    /**\n     * Sets or retrieves the maximum number of characters that the user can enter in a text control.\n     */\n    maxLength: number;\n    minLength: number;\n    /**\n     * Sets or retrieves the name of the object.\n     */\n    name: string;\n    /**\n     * Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field.\n     */\n    placeholder: string;\n    /**\n     * Sets or retrieves the value indicated whether the content of the object is read-only.\n     */\n    readOnly: boolean;\n    /**\n     * When present, marks an element that can\'t be submitted without a value.\n     */\n    required: boolean;\n    /**\n     * Sets or retrieves the number of horizontal rows contained in the object.\n     */\n    rows: number;\n    selectionDirection: string;\n    /**\n     * Gets or sets the end position or offset of a text selection.\n     */\n    selectionEnd: number;\n    /**\n     * Gets or sets the starting position or offset of a text selection.\n     */\n    selectionStart: number;\n    readonly textLength: number;\n    /**\n     * Retrieves the type of control.\n     */\n    readonly type: string;\n    /**\n     * Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting.\n     */\n    readonly validationMessage: string;\n    /**\n     * Returns a  ValidityState object that represents the validity states of an element.\n     */\n    readonly validity: ValidityState;\n    /**\n     * Retrieves or sets the text in the entry field of the textArea element.\n     */\n    value: string;\n    /**\n     * Returns whether an element will successfully validate based on forms validation rules and constraints.\n     */\n    readonly willValidate: boolean;\n    /**\n     * Sets or retrieves how to handle wordwrapping in the object.\n     */\n    wrap: string;\n    /**\n     * Returns whether a form will validate when it is submitted, without having to submit it.\n     */\n    checkValidity(): boolean;\n    reportValidity(): boolean;\n    /**\n     * Highlights the input area of a form element.\n     */\n    select(): void;\n    /**\n     * Sets a custom error message that is displayed when a form is submitted.\n     * @param error Sets a custom error message that is displayed when a form is submitted.\n     */\n    setCustomValidity(error: string): void;\n    setRangeText(replacement: string): void;\n    setRangeText(replacement: string, start: number, end: number, selectionMode?: SelectionMode): void;\n    /**\n     * Sets the start and end positions of a selection in a text field.\n     * @param start The offset into the text field for the start of the selection.\n     * @param end The offset into the text field for the end of the selection.\n     * @param direction The direction in which the selection is performed.\n     */\n    setSelectionRange(start: number, end: number, direction?: "forward" | "backward" | "none"): void;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTextAreaElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTextAreaElement: {\n    prototype: HTMLTextAreaElement;\n    new(): HTMLTextAreaElement;\n};\n\ninterface HTMLTimeElement extends HTMLElement {\n    dateTime: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTimeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTimeElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTimeElement: {\n    prototype: HTMLTimeElement;\n    new(): HTMLTimeElement;\n};\n\ninterface HTMLTitleElement extends HTMLElement {\n    /**\n     * Retrieves or sets the text of the object as a string.\n     */\n    text: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTitleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTitleElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTitleElement: {\n    prototype: HTMLTitleElement;\n    new(): HTMLTitleElement;\n};\n\ninterface HTMLTrackElement extends HTMLElement {\n    default: boolean;\n    kind: string;\n    label: string;\n    readonly readyState: number;\n    src: string;\n    srclang: string;\n    readonly track: TextTrack;\n    readonly ERROR: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTrackElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLTrackElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLTrackElement: {\n    prototype: HTMLTrackElement;\n    new(): HTMLTrackElement;\n    readonly ERROR: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n};\n\ninterface HTMLUListElement extends HTMLElement {\n    /** @deprecated */\n    compact: boolean;\n    /** @deprecated */\n    type: string;\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUListElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLUListElement: {\n    prototype: HTMLUListElement;\n    new(): HTMLUListElement;\n};\n\ninterface HTMLUnknownElement extends HTMLElement {\n    addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUnknownElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLUnknownElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLUnknownElement: {\n    prototype: HTMLUnknownElement;\n    new(): HTMLUnknownElement;\n};\n\ninterface HTMLVideoElementEventMap extends HTMLMediaElementEventMap {\n    "MSVideoFormatChanged": Event;\n    "MSVideoFrameStepCompleted": Event;\n    "MSVideoOptimalLayoutChanged": Event;\n}\n\ninterface HTMLVideoElement extends HTMLMediaElement {\n    /**\n     * Gets or sets the height of the video element.\n     */\n    height: number;\n    msHorizontalMirror: boolean;\n    readonly msIsLayoutOptimalForPlayback: boolean;\n    readonly msIsStereo3D: boolean;\n    msStereo3DPackingMode: string;\n    msStereo3DRenderMode: string;\n    msZoom: boolean;\n    onMSVideoFormatChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;\n    onMSVideoFrameStepCompleted: ((this: HTMLVideoElement, ev: Event) => any) | null;\n    onMSVideoOptimalLayoutChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;\n    /**\n     * Gets or sets a URL of an image to display, for example, like a movie poster. This can be a still frame from the video, or another image if no video data is available.\n     */\n    poster: string;\n    /**\n     * Gets the intrinsic height of a video in CSS pixels, or zero if the dimensions are not known.\n     */\n    readonly videoHeight: number;\n    /**\n     * Gets the intrinsic width of a video in CSS pixels, or zero if the dimensions are not known.\n     */\n    readonly videoWidth: number;\n    readonly webkitDisplayingFullscreen: boolean;\n    readonly webkitSupportsFullscreen: boolean;\n    /**\n     * Gets or sets the width of the video element.\n     */\n    width: number;\n    getVideoPlaybackQuality(): VideoPlaybackQuality;\n    msFrameStep(forward: boolean): void;\n    msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\n    msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;\n    webkitEnterFullScreen(): void;\n    webkitEnterFullscreen(): void;\n    webkitExitFullScreen(): void;\n    webkitExitFullscreen(): void;\n    addEventListener<K extends keyof HTMLVideoElementEventMap>(type: K, listener: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof HTMLVideoElementEventMap>(type: K, listener: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var HTMLVideoElement: {\n    prototype: HTMLVideoElement;\n    new(): HTMLVideoElement;\n};\n\ninterface HashChangeEvent extends Event {\n    readonly newURL: string;\n    readonly oldURL: string;\n}\n\ndeclare var HashChangeEvent: {\n    prototype: HashChangeEvent;\n    new(type: string, eventInitDict?: HashChangeEventInit): HashChangeEvent;\n};\n\ninterface Headers {\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    get(name: string): string | null;\n    has(name: string): boolean;\n    set(name: string, value: string): void;\n    forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: any): void;\n}\n\ndeclare var Headers: {\n    prototype: Headers;\n    new(init?: HeadersInit): Headers;\n};\n\ninterface History {\n    readonly length: number;\n    scrollRestoration: ScrollRestoration;\n    readonly state: any;\n    back(): void;\n    forward(): void;\n    go(delta?: number): void;\n    pushState(data: any, title: string, url?: string | null): void;\n    replaceState(data: any, title: string, url?: string | null): void;\n}\n\ndeclare var History: {\n    prototype: History;\n    new(): History;\n};\n\ninterface HkdfCtrParams extends Algorithm {\n    context: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    hash: string | Algorithm;\n    label: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface IDBArrayKey extends Array<IDBValidKey> {\n}\n\ninterface IDBCursor {\n    /**\n     * Returns the direction ("next", "nextunique", "prev" or "prevunique")\n     * of the cursor.\n     */\n    readonly direction: IDBCursorDirection;\n    /**\n     * Returns the key of the cursor.\n     * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n     */\n    readonly key: IDBValidKey | IDBKeyRange;\n    /**\n     * Returns the effective key of the cursor.\n     * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n     */\n    readonly primaryKey: IDBValidKey | IDBKeyRange;\n    /**\n     * Returns the IDBObjectStore or IDBIndex the cursor was opened from.\n     */\n    readonly source: IDBObjectStore | IDBIndex;\n    /**\n     * Advances the cursor through the next count records in\n     * range.\n     */\n    advance(count: number): void;\n    /**\n     * Advances the cursor to the next record in range matching or\n     * after key.\n     */\n    continue(key?: IDBValidKey | IDBKeyRange): void;\n    /**\n     * Advances the cursor to the next record in range matching\n     * or after key and primaryKey. Throws an "InvalidAccessError" DOMException if the source is not an index.\n     */\n    continuePrimaryKey(key: IDBValidKey | IDBKeyRange, primaryKey: IDBValidKey | IDBKeyRange): void;\n    /**\n     * Delete the record pointed at by the cursor with a new value.\n     * If successful, request\'s result will be undefined.\n     */\n    delete(): IDBRequest<undefined>;\n    /**\n     * Updated the record pointed at by the cursor with a new value.\n     * Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.\n     * If successful, request\'s result will be the record\'s key.\n     */\n    update(value: any): IDBRequest<IDBValidKey>;\n}\n\ndeclare var IDBCursor: {\n    prototype: IDBCursor;\n    new(): IDBCursor;\n};\n\ninterface IDBCursorWithValue extends IDBCursor {\n    /**\n     * Returns the cursor\'s current value.\n     */\n    readonly value: any;\n}\n\ndeclare var IDBCursorWithValue: {\n    prototype: IDBCursorWithValue;\n    new(): IDBCursorWithValue;\n};\n\ninterface IDBDatabaseEventMap {\n    "abort": Event;\n    "close": Event;\n    "error": Event;\n    "versionchange": IDBVersionChangeEvent;\n}\n\ninterface IDBDatabase extends EventTarget {\n    /**\n     * Returns the name of the database.\n     */\n    readonly name: string;\n    /**\n     * Returns a list of the names of object stores in the database.\n     */\n    readonly objectStoreNames: DOMStringList;\n    onabort: ((this: IDBDatabase, ev: Event) => any) | null;\n    onclose: ((this: IDBDatabase, ev: Event) => any) | null;\n    onerror: ((this: IDBDatabase, ev: Event) => any) | null;\n    onversionchange: ((this: IDBDatabase, ev: IDBVersionChangeEvent) => any) | null;\n    /**\n     * Returns the version of the database.\n     */\n    readonly version: number;\n    /**\n     * Closes the connection once all running transactions have finished.\n     */\n    close(): void;\n    /**\n     * Creates a new object store with the given name and options and returns a new IDBObjectStore.\n     * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n     */\n    createObjectStore(name: string, optionalParameters?: IDBObjectStoreParameters): IDBObjectStore;\n    /**\n     * Deletes the object store with the given name.\n     * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n     */\n    deleteObjectStore(name: string): void;\n    /**\n     * Returns a new transaction with the given mode ("readonly" or "readwrite")\n     * and scope which can be a single object store name or an array of names.\n     */\n    transaction(storeNames: string | string[], mode?: IDBTransactionMode): IDBTransaction;\n    addEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBDatabase: {\n    prototype: IDBDatabase;\n    new(): IDBDatabase;\n};\n\ninterface IDBEnvironment {\n    readonly indexedDB: IDBFactory;\n}\n\ninterface IDBFactory {\n    /**\n     * Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if\n     * the keys are equal.\n     * Throws a "DataError" DOMException if either input is not a valid key.\n     */\n    cmp(first: any, second: any): number;\n    /**\n     * Attempts to delete the named database. If the\n     * database already exists and there are open connections that don\'t close in response to a versionchange event, the request will be blocked until all they close. If the request\n     * is successful request\'s result will be null.\n     */\n    deleteDatabase(name: string): IDBOpenDBRequest;\n    /**\n     * Attempts to open a connection to the named database with the specified version. If the database already exists\n     * with a lower version and there are open connections that don\'t close in response to a versionchange event, the request will be blocked until all they close, then an upgrade\n     * will occur. If the database already exists with a higher\n     * version the request will fail. If the request is\n     * successful request\'s result will\n     * be the connection.\n     */\n    open(name: string, version?: number): IDBOpenDBRequest;\n}\n\ndeclare var IDBFactory: {\n    prototype: IDBFactory;\n    new(): IDBFactory;\n};\n\ninterface IDBIndex {\n    readonly keyPath: string | string[];\n    readonly multiEntry: boolean;\n    /**\n     * Updates the name of the store to newName.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    name: string;\n    /**\n     * Returns the IDBObjectStore the index belongs to.\n     */\n    readonly objectStore: IDBObjectStore;\n    readonly unique: boolean;\n    /**\n     * Retrieves the number of records matching the given key or key range in query.\n     * If successful, request\'s result will be the\n     * count.\n     */\n    count(key?: IDBValidKey | IDBKeyRange): IDBRequest<number>;\n    /**\n     * Retrieves the value of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the value, or undefined if there was no matching record.\n     */\n    get(key: IDBValidKey | IDBKeyRange): IDBRequest<any | undefined>;\n    /**\n     * Retrieves the values of the records matching the given key or key range in query (up to count if given).\n     * If successful, request\'s result will be an Array of the values.\n     */\n    getAll(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<any[]>;\n    /**\n     * Retrieves the keys of records matching the given key or key range in query (up to count if given).\n     * If successful, request\'s result will be an Array of the keys.\n     */\n    getAllKeys(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<IDBValidKey[]>;\n    /**\n     * Retrieves the key of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the key, or undefined if there was no matching record.\n     */\n    getKey(key: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined>;\n    /**\n     * Opens a cursor over the records matching query,\n     * ordered by direction. If query is null, all records in index are matched.\n     * If successful, request\'s result will be an IDBCursorWithValue, or null if there were no matching records.\n     */\n    openCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursorWithValue | null>;\n    /**\n     * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in index are matched.\n     * If successful, request\'s result will be an IDBCursor, or null if there were no matching records.\n     */\n    openKeyCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursor | null>;\n}\n\ndeclare var IDBIndex: {\n    prototype: IDBIndex;\n    new(): IDBIndex;\n};\n\ninterface IDBKeyRange {\n    /**\n     * Returns lower bound, or undefined if none.\n     */\n    readonly lower: any;\n    /**\n     * Returns true if the lower open flag is set, and false otherwise.\n     */\n    readonly lowerOpen: boolean;\n    /**\n     * Returns upper bound, or undefined if none.\n     */\n    readonly upper: any;\n    /**\n     * Returns true if the upper open flag is set, and false otherwise.\n     */\n    readonly upperOpen: boolean;\n    /**\n     * Returns true if key is included in the range, and false otherwise.\n     */\n    includes(key: any): boolean;\n}\n\ndeclare var IDBKeyRange: {\n    prototype: IDBKeyRange;\n    new(): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange spanning from lower to upper.\n     * If lowerOpen is true, lower is not included in the range.\n     * If upperOpen is true, upper is not included in the range.\n     */\n    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange starting at key with no\n     * upper bound. If open is true, key is not included in the\n     * range.\n     */\n    lowerBound(lower: any, open?: boolean): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange spanning only key.\n     */\n    only(value: any): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range.\n     */\n    upperBound(upper: any, open?: boolean): IDBKeyRange;\n};\n\ninterface IDBObjectStore {\n    /**\n     * Returns true if the store has a key generator, and false otherwise.\n     */\n    readonly autoIncrement: boolean;\n    /**\n     * Returns a list of the names of indexes in the store.\n     */\n    readonly indexNames: DOMStringList;\n    /**\n     * Returns the key path of the store, or null if none.\n     */\n    readonly keyPath: string | string[];\n    /**\n     * Updates the name of the store to newName.\n     * Throws "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    name: string;\n    /**\n     * Returns the associated transaction.\n     */\n    readonly transaction: IDBTransaction;\n    add(value: any, key?: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;\n    /**\n     * Deletes all records in store.\n     * If successful, request\'s result will\n     * be undefined.\n     */\n    clear(): IDBRequest<undefined>;\n    /**\n     * Retrieves the number of records matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the count.\n     */\n    count(key?: IDBValidKey | IDBKeyRange): IDBRequest<number>;\n    /**\n     * Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be\n     * satisfied with the data already in store the upgrade\n     * transaction will abort with\n     * a "ConstraintError" DOMException.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    createIndex(name: string, keyPath: string | string[], options?: IDBIndexParameters): IDBIndex;\n    /**\n     * Deletes records in store with the given key or in the given key range in query.\n     * If successful, request\'s result will\n     * be undefined.\n     */\n    delete(key: IDBValidKey | IDBKeyRange): IDBRequest<undefined>;\n    /**\n     * Deletes the index in store with the given name.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    deleteIndex(name: string): void;\n    /**\n     * Retrieves the value of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the value, or undefined if there was no matching record.\n     */\n    get(query: IDBValidKey | IDBKeyRange): IDBRequest<any | undefined>;\n    /**\n     * Retrieves the values of the records matching the\n     * given key or key range in query (up to count if given).\n     * If successful, request\'s result will\n     * be an Array of the values.\n     */\n    getAll(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<any[]>;\n    /**\n     * Retrieves the keys of records matching the\n     * given key or key range in query (up to count if given).\n     * If successful, request\'s result will\n     * be an Array of the keys.\n     */\n    getAllKeys(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<IDBValidKey[]>;\n    /**\n     * Retrieves the key of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the key, or undefined if there was no matching record.\n     */\n    getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined>;\n    index(name: string): IDBIndex;\n    /**\n     * Opens a cursor over the records matching query,\n     * ordered by direction. If query is null, all records in store are matched.\n     * If successful, request\'s result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.\n     */\n    openCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursorWithValue | null>;\n    /**\n     * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in store are matched.\n     * If successful, request\'s result will be an IDBCursor pointing at the first matching record, or\n     * null if there were no matching records.\n     */\n    openKeyCursor(query?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursor | null>;\n    put(value: any, key?: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;\n}\n\ndeclare var IDBObjectStore: {\n    prototype: IDBObjectStore;\n    new(): IDBObjectStore;\n};\n\ninterface IDBOpenDBRequestEventMap extends IDBRequestEventMap {\n    "blocked": Event;\n    "upgradeneeded": IDBVersionChangeEvent;\n}\n\ninterface IDBOpenDBRequest extends IDBRequest<IDBDatabase> {\n    onblocked: ((this: IDBOpenDBRequest, ev: Event) => any) | null;\n    onupgradeneeded: ((this: IDBOpenDBRequest, ev: IDBVersionChangeEvent) => any) | null;\n    addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBOpenDBRequest: {\n    prototype: IDBOpenDBRequest;\n    new(): IDBOpenDBRequest;\n};\n\ninterface IDBRequestEventMap {\n    "error": Event;\n    "success": Event;\n}\n\ninterface IDBRequest<T = any> extends EventTarget {\n    /**\n     * When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws\n     * a "InvalidStateError" DOMException if the request is still pending.\n     */\n    readonly error: DOMException | null;\n    onerror: ((this: IDBRequest<T>, ev: Event) => any) | null;\n    onsuccess: ((this: IDBRequest<T>, ev: Event) => any) | null;\n    /**\n     * Returns "pending" until a request is complete,\n     * then returns "done".\n     */\n    readonly readyState: IDBRequestReadyState;\n    /**\n     * When a request is completed, returns the result,\n     * or undefined if the request failed. Throws a\n     * "InvalidStateError" DOMException if the request is still pending.\n     */\n    readonly result: T;\n    /**\n     * Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if is was an open\n     * request.\n     */\n    readonly source: IDBObjectStore | IDBIndex | IDBCursor;\n    /**\n     * Returns the IDBTransaction the request was made within.\n     * If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise.\n     */\n    readonly transaction: IDBTransaction | null;\n    addEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest<T>, ev: IDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest<T>, ev: IDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBRequest: {\n    prototype: IDBRequest;\n    new(): IDBRequest;\n};\n\ninterface IDBTransactionEventMap {\n    "abort": Event;\n    "complete": Event;\n    "error": Event;\n}\n\ninterface IDBTransaction extends EventTarget {\n    /**\n     * Returns the transaction\'s connection.\n     */\n    readonly db: IDBDatabase;\n    /**\n     * If the transaction was aborted, returns the\n     * error (a DOMException) providing the reason.\n     */\n    readonly error: DOMException;\n    /**\n     * Returns the mode the transaction was created with\n     * ("readonly" or "readwrite"), or "versionchange" for\n     * an upgrade transaction.\n     */\n    readonly mode: IDBTransactionMode;\n    /**\n     * Returns a list of the names of object stores in the\n     * transaction\'s scope. For an upgrade transaction this is all object stores in the database.\n     */\n    readonly objectStoreNames: DOMStringList;\n    onabort: ((this: IDBTransaction, ev: Event) => any) | null;\n    oncomplete: ((this: IDBTransaction, ev: Event) => any) | null;\n    onerror: ((this: IDBTransaction, ev: Event) => any) | null;\n    /**\n     * Aborts the transaction. All pending requests will fail with\n     * a "AbortError" DOMException and all changes made to the database will be\n     * reverted.\n     */\n    abort(): void;\n    /**\n     * Returns an IDBObjectStore in the transaction\'s scope.\n     */\n    objectStore(name: string): IDBObjectStore;\n    addEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBTransaction: {\n    prototype: IDBTransaction;\n    new(): IDBTransaction;\n};\n\ninterface IDBVersionChangeEvent extends Event {\n    readonly newVersion: number | null;\n    readonly oldVersion: number;\n}\n\ndeclare var IDBVersionChangeEvent: {\n    prototype: IDBVersionChangeEvent;\n    new(type: string, eventInitDict?: IDBVersionChangeEventInit): IDBVersionChangeEvent;\n};\n\ninterface IIRFilterNode extends AudioNode {\n    getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void;\n}\n\ndeclare var IIRFilterNode: {\n    prototype: IIRFilterNode;\n    new(context: BaseAudioContext, options: IIRFilterOptions): IIRFilterNode;\n};\n\ninterface ImageBitmap {\n    /**\n     * Returns the intrinsic height of the image, in CSS\n     * pixels.\n     */\n    readonly height: number;\n    /**\n     * Returns the intrinsic width of the image, in CSS\n     * pixels.\n     */\n    readonly width: number;\n    /**\n     * Releases imageBitmap\'s underlying bitmap data.\n     */\n    close(): void;\n}\n\ndeclare var ImageBitmap: {\n    prototype: ImageBitmap;\n    new(): ImageBitmap;\n};\n\ninterface ImageBitmapOptions {\n    colorSpaceConversion?: "none" | "default";\n    imageOrientation?: "none" | "flipY";\n    premultiplyAlpha?: "none" | "premultiply" | "default";\n    resizeHeight?: number;\n    resizeQuality?: "pixelated" | "low" | "medium" | "high";\n    resizeWidth?: number;\n}\n\ninterface ImageBitmapRenderingContext {\n    /**\n     * Returns the canvas element that the context is bound to.\n     */\n    readonly canvas: HTMLCanvasElement;\n    /**\n     * Replaces contents of the canvas element to which context\n     * is bound with a transparent black bitmap whose size corresponds to the width and height\n     * content attributes of the canvas element.\n     */\n    transferFromImageBitmap(bitmap: ImageBitmap | null): void;\n}\n\ndeclare var ImageBitmapRenderingContext: {\n    prototype: ImageBitmapRenderingContext;\n    new(): ImageBitmapRenderingContext;\n};\n\ninterface ImageData {\n    /**\n     * Returns the one-dimensional array containing the data in RGBA order, as integers in the\n     * range 0 to 255.\n     */\n    readonly data: Uint8ClampedArray;\n    /**\n     * Returns the actual dimensions of the data in the ImageData object, in\n     * pixels.\n     */\n    readonly height: number;\n    readonly width: number;\n}\n\ndeclare var ImageData: {\n    prototype: ImageData;\n    new(width: number, height: number): ImageData;\n    new(array: Uint8ClampedArray, width: number, height: number): ImageData;\n};\n\ninterface IntersectionObserver {\n    readonly root: Element | null;\n    readonly rootMargin: string;\n    readonly thresholds: number[];\n    disconnect(): void;\n    observe(target: Element): void;\n    takeRecords(): IntersectionObserverEntry[];\n    unobserve(target: Element): void;\n}\n\ndeclare var IntersectionObserver: {\n    prototype: IntersectionObserver;\n    new(callback: IntersectionObserverCallback, options?: IntersectionObserverInit): IntersectionObserver;\n};\n\ninterface IntersectionObserverEntry {\n    readonly boundingClientRect: ClientRect | DOMRect;\n    readonly intersectionRatio: number;\n    readonly intersectionRect: ClientRect | DOMRect;\n    readonly isIntersecting: boolean;\n    readonly rootBounds: ClientRect | DOMRect;\n    readonly target: Element;\n    readonly time: number;\n}\n\ndeclare var IntersectionObserverEntry: {\n    prototype: IntersectionObserverEntry;\n    new(intersectionObserverEntryInit: IntersectionObserverEntryInit): IntersectionObserverEntry;\n};\n\ninterface KeyboardEvent extends UIEvent {\n    readonly altKey: boolean;\n    /** @deprecated */\n    char: string;\n    /** @deprecated */\n    readonly charCode: number;\n    readonly code: string;\n    readonly ctrlKey: boolean;\n    readonly key: string;\n    /** @deprecated */\n    readonly keyCode: number;\n    readonly location: number;\n    readonly metaKey: boolean;\n    readonly repeat: boolean;\n    readonly shiftKey: boolean;\n    /** @deprecated */\n    readonly which: number;\n    getModifierState(keyArg: string): boolean;\n    /** @deprecated */\n    initKeyboardEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, keyArg: string, locationArg: number, modifiersListArg: string, repeat: boolean, locale: string): void;\n    readonly DOM_KEY_LOCATION_JOYSTICK: number;\n    readonly DOM_KEY_LOCATION_LEFT: number;\n    readonly DOM_KEY_LOCATION_MOBILE: number;\n    readonly DOM_KEY_LOCATION_NUMPAD: number;\n    readonly DOM_KEY_LOCATION_RIGHT: number;\n    readonly DOM_KEY_LOCATION_STANDARD: number;\n}\n\ndeclare var KeyboardEvent: {\n    prototype: KeyboardEvent;\n    new(typeArg: string, eventInitDict?: KeyboardEventInit): KeyboardEvent;\n    readonly DOM_KEY_LOCATION_JOYSTICK: number;\n    readonly DOM_KEY_LOCATION_LEFT: number;\n    readonly DOM_KEY_LOCATION_MOBILE: number;\n    readonly DOM_KEY_LOCATION_NUMPAD: number;\n    readonly DOM_KEY_LOCATION_RIGHT: number;\n    readonly DOM_KEY_LOCATION_STANDARD: number;\n};\n\ninterface KeyframeEffect extends AnimationEffect {\n    composite: CompositeOperation;\n    iterationComposite: IterationCompositeOperation;\n    target: Element | null;\n    getKeyframes(): ComputedKeyframe[];\n    setKeyframes(keyframes: Keyframe[] | PropertyIndexedKeyframes | null): void;\n}\n\ndeclare var KeyframeEffect: {\n    prototype: KeyframeEffect;\n    new(target: Element | null, keyframes: Keyframe[] | PropertyIndexedKeyframes | null, options?: number | KeyframeEffectOptions): KeyframeEffect;\n    new(source: KeyframeEffect): KeyframeEffect;\n};\n\ninterface LinkStyle {\n    readonly sheet: StyleSheet | null;\n}\n\ninterface ListeningStateChangedEvent extends Event {\n    readonly label: string;\n    readonly state: ListeningState;\n}\n\ndeclare var ListeningStateChangedEvent: {\n    prototype: ListeningStateChangedEvent;\n    new(): ListeningStateChangedEvent;\n};\n\ninterface Location {\n    /**\n     * Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing\n     * context to the top-level browsing context.\n     */\n    readonly ancestorOrigins: DOMStringList;\n    /**\n     * Returns the Location object\'s URL\'s fragment (includes leading "#" if non-empty).\n     * Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").\n     */\n    hash: string;\n    /**\n     * Returns the Location object\'s URL\'s host and port (if different from the default\n     * port for the scheme).\n     * Can be set, to navigate to the same URL with a changed host and port.\n     */\n    host: string;\n    /**\n     * Returns the Location object\'s URL\'s host.\n     * Can be set, to navigate to the same URL with a changed host.\n     */\n    hostname: string;\n    /**\n     * Returns the Location object\'s URL.\n     * Can be set, to navigate to the given URL.\n     */\n    href: string;\n    /**\n     * Returns the Location object\'s URL\'s origin.\n     */\n    readonly origin: string;\n    /**\n     * Returns the Location object\'s URL\'s path.\n     * Can be set, to navigate to the same URL with a changed path.\n     */\n    pathname: string;\n    /**\n     * Returns the Location object\'s URL\'s port.\n     * Can be set, to navigate to the same URL with a changed port.\n     */\n    port: string;\n    /**\n     * Returns the Location object\'s URL\'s scheme.\n     * Can be set, to navigate to the same URL with a changed scheme.\n     */\n    protocol: string;\n    /**\n     * Returns the Location object\'s URL\'s query (includes leading "?" if non-empty).\n     * Can be set, to navigate to the same URL with a changed query (ignores leading "?").\n     */\n    search: string;\n    /**\n     * Navigates to the given URL.\n     */\n    assign(url: string): void;\n    /**\n     * Reloads the current page.\n     */\n    reload(): void;\n    /** @deprecated */\n    reload(forcedReload: boolean): void;\n    /**\n     * Removes the current page from the session history and navigates to the given URL.\n     */\n    replace(url: string): void;\n}\n\ndeclare var Location: {\n    prototype: Location;\n    new(): Location;\n};\n\ninterface MSAssertion {\n    readonly id: string;\n    readonly type: MSCredentialType;\n}\n\ndeclare var MSAssertion: {\n    prototype: MSAssertion;\n    new(): MSAssertion;\n};\n\ninterface MSBlobBuilder {\n    append(data: any, endings?: string): void;\n    getBlob(contentType?: string): Blob;\n}\n\ndeclare var MSBlobBuilder: {\n    prototype: MSBlobBuilder;\n    new(): MSBlobBuilder;\n};\n\ninterface MSFIDOCredentialAssertion extends MSAssertion {\n    readonly algorithm: string | Algorithm;\n    readonly attestation: any;\n    readonly publicKey: string;\n    readonly transportHints: MSTransportType[];\n}\n\ndeclare var MSFIDOCredentialAssertion: {\n    prototype: MSFIDOCredentialAssertion;\n    new(): MSFIDOCredentialAssertion;\n};\n\ninterface MSFIDOSignature {\n    readonly authnrData: string;\n    readonly clientData: string;\n    readonly signature: string;\n}\n\ndeclare var MSFIDOSignature: {\n    prototype: MSFIDOSignature;\n    new(): MSFIDOSignature;\n};\n\ninterface MSFIDOSignatureAssertion extends MSAssertion {\n    readonly signature: MSFIDOSignature;\n}\n\ndeclare var MSFIDOSignatureAssertion: {\n    prototype: MSFIDOSignatureAssertion;\n    new(): MSFIDOSignatureAssertion;\n};\n\ninterface MSFileSaver {\n    msSaveBlob(blob: any, defaultName?: string): boolean;\n    msSaveOrOpenBlob(blob: any, defaultName?: string): boolean;\n}\n\ninterface MSGesture {\n    target: Element;\n    addPointer(pointerId: number): void;\n    stop(): void;\n}\n\ndeclare var MSGesture: {\n    prototype: MSGesture;\n    new(): MSGesture;\n};\n\ninterface MSGestureEvent extends UIEvent {\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly expansion: number;\n    readonly gestureObject: any;\n    readonly hwTimestamp: number;\n    readonly offsetX: number;\n    readonly offsetY: number;\n    readonly rotation: number;\n    readonly scale: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly translationX: number;\n    readonly translationY: number;\n    readonly velocityAngular: number;\n    readonly velocityExpansion: number;\n    readonly velocityX: number;\n    readonly velocityY: number;\n    initGestureEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, offsetXArg: number, offsetYArg: number, translationXArg: number, translationYArg: number, scaleArg: number, expansionArg: number, rotationArg: number, velocityXArg: number, velocityYArg: number, velocityExpansionArg: number, velocityAngularArg: number, hwTimestampArg: number): void;\n    readonly MSGESTURE_FLAG_BEGIN: number;\n    readonly MSGESTURE_FLAG_CANCEL: number;\n    readonly MSGESTURE_FLAG_END: number;\n    readonly MSGESTURE_FLAG_INERTIA: number;\n    readonly MSGESTURE_FLAG_NONE: number;\n}\n\ndeclare var MSGestureEvent: {\n    prototype: MSGestureEvent;\n    new(): MSGestureEvent;\n    readonly MSGESTURE_FLAG_BEGIN: number;\n    readonly MSGESTURE_FLAG_CANCEL: number;\n    readonly MSGESTURE_FLAG_END: number;\n    readonly MSGESTURE_FLAG_INERTIA: number;\n    readonly MSGESTURE_FLAG_NONE: number;\n};\n\ninterface MSGraphicsTrust {\n    readonly constrictionActive: boolean;\n    readonly status: string;\n}\n\ndeclare var MSGraphicsTrust: {\n    prototype: MSGraphicsTrust;\n    new(): MSGraphicsTrust;\n};\n\ninterface MSInputMethodContextEventMap {\n    "MSCandidateWindowHide": Event;\n    "MSCandidateWindowShow": Event;\n    "MSCandidateWindowUpdate": Event;\n}\n\ninterface MSInputMethodContext extends EventTarget {\n    readonly compositionEndOffset: number;\n    readonly compositionStartOffset: number;\n    oncandidatewindowhide: ((this: MSInputMethodContext, ev: Event) => any) | null;\n    oncandidatewindowshow: ((this: MSInputMethodContext, ev: Event) => any) | null;\n    oncandidatewindowupdate: ((this: MSInputMethodContext, ev: Event) => any) | null;\n    readonly target: HTMLElement;\n    getCandidateWindowClientRect(): ClientRect;\n    getCompositionAlternatives(): string[];\n    hasComposition(): boolean;\n    isCandidateWindowVisible(): boolean;\n    addEventListener<K extends keyof MSInputMethodContextEventMap>(type: K, listener: (this: MSInputMethodContext, ev: MSInputMethodContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MSInputMethodContextEventMap>(type: K, listener: (this: MSInputMethodContext, ev: MSInputMethodContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MSInputMethodContext: {\n    prototype: MSInputMethodContext;\n    new(): MSInputMethodContext;\n};\n\ninterface MSMediaKeyError {\n    readonly code: number;\n    readonly systemCode: number;\n    readonly MS_MEDIA_KEYERR_CLIENT: number;\n    readonly MS_MEDIA_KEYERR_DOMAIN: number;\n    readonly MS_MEDIA_KEYERR_HARDWARECHANGE: number;\n    readonly MS_MEDIA_KEYERR_OUTPUT: number;\n    readonly MS_MEDIA_KEYERR_SERVICE: number;\n    readonly MS_MEDIA_KEYERR_UNKNOWN: number;\n}\n\ndeclare var MSMediaKeyError: {\n    prototype: MSMediaKeyError;\n    new(): MSMediaKeyError;\n    readonly MS_MEDIA_KEYERR_CLIENT: number;\n    readonly MS_MEDIA_KEYERR_DOMAIN: number;\n    readonly MS_MEDIA_KEYERR_HARDWARECHANGE: number;\n    readonly MS_MEDIA_KEYERR_OUTPUT: number;\n    readonly MS_MEDIA_KEYERR_SERVICE: number;\n    readonly MS_MEDIA_KEYERR_UNKNOWN: number;\n};\n\ninterface MSMediaKeyMessageEvent extends Event {\n    readonly destinationURL: string | null;\n    readonly message: Uint8Array;\n}\n\ndeclare var MSMediaKeyMessageEvent: {\n    prototype: MSMediaKeyMessageEvent;\n    new(): MSMediaKeyMessageEvent;\n};\n\ninterface MSMediaKeyNeededEvent extends Event {\n    readonly initData: Uint8Array | null;\n}\n\ndeclare var MSMediaKeyNeededEvent: {\n    prototype: MSMediaKeyNeededEvent;\n    new(): MSMediaKeyNeededEvent;\n};\n\ninterface MSMediaKeySession extends EventTarget {\n    readonly error: MSMediaKeyError | null;\n    readonly keySystem: string;\n    readonly sessionId: string;\n    close(): void;\n    update(key: Uint8Array): void;\n}\n\ndeclare var MSMediaKeySession: {\n    prototype: MSMediaKeySession;\n    new(): MSMediaKeySession;\n};\n\ninterface MSMediaKeys {\n    readonly keySystem: string;\n    createSession(type: string, initData: Uint8Array, cdmData?: Uint8Array | null): MSMediaKeySession;\n}\n\ndeclare var MSMediaKeys: {\n    prototype: MSMediaKeys;\n    new(keySystem: string): MSMediaKeys;\n    isTypeSupported(keySystem: string, type?: string | null): boolean;\n    isTypeSupportedWithFeatures(keySystem: string, type?: string | null): string;\n};\n\ninterface MSNavigatorDoNotTrack {\n    confirmSiteSpecificTrackingException(args: ConfirmSiteSpecificExceptionsInformation): boolean;\n    confirmWebWideTrackingException(args: ExceptionInformation): boolean;\n    removeSiteSpecificTrackingException(args: ExceptionInformation): void;\n    removeWebWideTrackingException(args: ExceptionInformation): void;\n    storeSiteSpecificTrackingException(args: StoreSiteSpecificExceptionsInformation): void;\n    storeWebWideTrackingException(args: StoreExceptionsInformation): void;\n}\n\ninterface MSPointerEvent extends MouseEvent {\n    readonly currentPoint: any;\n    readonly height: number;\n    readonly hwTimestamp: number;\n    readonly intermediatePoints: any;\n    readonly isPrimary: boolean;\n    readonly pointerId: number;\n    readonly pointerType: any;\n    readonly pressure: number;\n    readonly rotation: number;\n    readonly tiltX: number;\n    readonly tiltY: number;\n    readonly width: number;\n    getCurrentPoint(element: Element): void;\n    getIntermediatePoints(element: Element): void;\n    initPointerEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget, offsetXArg: number, offsetYArg: number, widthArg: number, heightArg: number, pressure: number, rotation: number, tiltX: number, tiltY: number, pointerIdArg: number, pointerType: any, hwTimestampArg: number, isPrimary: boolean): void;\n}\n\ndeclare var MSPointerEvent: {\n    prototype: MSPointerEvent;\n    new(typeArg: string, eventInitDict?: PointerEventInit): MSPointerEvent;\n};\n\ninterface MSStream {\n    readonly type: string;\n    msClose(): void;\n    msDetachStream(): any;\n}\n\ndeclare var MSStream: {\n    prototype: MSStream;\n    new(): MSStream;\n};\n\ninterface MediaDeviceInfo {\n    readonly deviceId: string;\n    readonly groupId: string;\n    readonly kind: MediaDeviceKind;\n    readonly label: string;\n}\n\ndeclare var MediaDeviceInfo: {\n    prototype: MediaDeviceInfo;\n    new(): MediaDeviceInfo;\n};\n\ninterface MediaDevicesEventMap {\n    "devicechange": Event;\n}\n\ninterface MediaDevices extends EventTarget {\n    ondevicechange: ((this: MediaDevices, ev: Event) => any) | null;\n    enumerateDevices(): Promise<MediaDeviceInfo[]>;\n    getSupportedConstraints(): MediaTrackSupportedConstraints;\n    getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream>;\n    addEventListener<K extends keyof MediaDevicesEventMap>(type: K, listener: (this: MediaDevices, ev: MediaDevicesEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MediaDevicesEventMap>(type: K, listener: (this: MediaDevices, ev: MediaDevicesEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MediaDevices: {\n    prototype: MediaDevices;\n    new(): MediaDevices;\n};\n\ninterface MediaElementAudioSourceNode extends AudioNode {\n    readonly mediaElement: HTMLMediaElement;\n}\n\ndeclare var MediaElementAudioSourceNode: {\n    prototype: MediaElementAudioSourceNode;\n    new(context: AudioContext, options: MediaElementAudioSourceOptions): MediaElementAudioSourceNode;\n};\n\ninterface MediaEncryptedEvent extends Event {\n    readonly initData: ArrayBuffer | null;\n    readonly initDataType: string;\n}\n\ndeclare var MediaEncryptedEvent: {\n    prototype: MediaEncryptedEvent;\n    new(type: string, eventInitDict?: MediaEncryptedEventInit): MediaEncryptedEvent;\n};\n\ninterface MediaError {\n    readonly code: number;\n    readonly message: string;\n    readonly msExtendedCode: number;\n    readonly MEDIA_ERR_ABORTED: number;\n    readonly MEDIA_ERR_DECODE: number;\n    readonly MEDIA_ERR_NETWORK: number;\n    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: number;\n    readonly MS_MEDIA_ERR_ENCRYPTED: number;\n}\n\ndeclare var MediaError: {\n    prototype: MediaError;\n    new(): MediaError;\n    readonly MEDIA_ERR_ABORTED: number;\n    readonly MEDIA_ERR_DECODE: number;\n    readonly MEDIA_ERR_NETWORK: number;\n    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: number;\n    readonly MS_MEDIA_ERR_ENCRYPTED: number;\n};\n\ninterface MediaKeyMessageEvent extends Event {\n    readonly message: ArrayBuffer;\n    readonly messageType: MediaKeyMessageType;\n}\n\ndeclare var MediaKeyMessageEvent: {\n    prototype: MediaKeyMessageEvent;\n    new(type: string, eventInitDict?: MediaKeyMessageEventInit): MediaKeyMessageEvent;\n};\n\ninterface MediaKeySession extends EventTarget {\n    readonly closed: Promise<void>;\n    readonly expiration: number;\n    readonly keyStatuses: MediaKeyStatusMap;\n    readonly sessionId: string;\n    close(): Promise<void>;\n    generateRequest(initDataType: string, initData: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null): Promise<void>;\n    load(sessionId: string): Promise<boolean>;\n    remove(): Promise<void>;\n    update(response: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null): Promise<void>;\n}\n\ndeclare var MediaKeySession: {\n    prototype: MediaKeySession;\n    new(): MediaKeySession;\n};\n\ninterface MediaKeyStatusMap {\n    readonly size: number;\n    forEach(callback: Function, thisArg?: any): void;\n    get(keyId: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null): MediaKeyStatus;\n    has(keyId: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null): boolean;\n}\n\ndeclare var MediaKeyStatusMap: {\n    prototype: MediaKeyStatusMap;\n    new(): MediaKeyStatusMap;\n};\n\ninterface MediaKeySystemAccess {\n    readonly keySystem: string;\n    createMediaKeys(): Promise<MediaKeys>;\n    getConfiguration(): MediaKeySystemConfiguration;\n}\n\ndeclare var MediaKeySystemAccess: {\n    prototype: MediaKeySystemAccess;\n    new(): MediaKeySystemAccess;\n};\n\ninterface MediaKeys {\n    createSession(sessionType?: MediaKeySessionType): MediaKeySession;\n    setServerCertificate(serverCertificate: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null): Promise<void>;\n}\n\ndeclare var MediaKeys: {\n    prototype: MediaKeys;\n    new(): MediaKeys;\n};\n\ninterface MediaList {\n    readonly length: number;\n    mediaText: string;\n    appendMedium(medium: string): void;\n    deleteMedium(medium: string): void;\n    item(index: number): string | null;\n    toString(): number;\n    [index: number]: string;\n}\n\ndeclare var MediaList: {\n    prototype: MediaList;\n    new(): MediaList;\n};\n\ninterface MediaQueryListEventMap {\n    "change": MediaQueryListEvent;\n}\n\ninterface MediaQueryList extends EventTarget {\n    readonly matches: boolean;\n    readonly media: string;\n    onchange: ((this: MediaQueryList, ev: MediaQueryListEvent) => any) | null;\n    /** @deprecated */\n    addListener(listener: ((this: MediaQueryList, ev: MediaQueryListEvent) => any) | null): void;\n    /** @deprecated */\n    removeListener(listener: ((this: MediaQueryList, ev: MediaQueryListEvent) => any) | null): void;\n    addEventListener<K extends keyof MediaQueryListEventMap>(type: K, listener: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MediaQueryListEventMap>(type: K, listener: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MediaQueryList: {\n    prototype: MediaQueryList;\n    new(): MediaQueryList;\n};\n\ninterface MediaQueryListEvent extends Event {\n    readonly matches: boolean;\n    readonly media: string;\n}\n\ndeclare var MediaQueryListEvent: {\n    prototype: MediaQueryListEvent;\n    new(type: string, eventInitDict?: MediaQueryListEventInit): MediaQueryListEvent;\n};\n\ninterface MediaSource extends EventTarget {\n    readonly activeSourceBuffers: SourceBufferList;\n    duration: number;\n    readonly readyState: ReadyState;\n    readonly sourceBuffers: SourceBufferList;\n    addSourceBuffer(type: string): SourceBuffer;\n    endOfStream(error?: EndOfStreamError): void;\n    removeSourceBuffer(sourceBuffer: SourceBuffer): void;\n}\n\ndeclare var MediaSource: {\n    prototype: MediaSource;\n    new(): MediaSource;\n    isTypeSupported(type: string): boolean;\n};\n\ninterface MediaStreamEventMap {\n    "active": Event;\n    "addtrack": MediaStreamTrackEvent;\n    "inactive": Event;\n    "removetrack": MediaStreamTrackEvent;\n}\n\ninterface MediaStream extends EventTarget {\n    readonly active: boolean;\n    readonly id: string;\n    onactive: ((this: MediaStream, ev: Event) => any) | null;\n    onaddtrack: ((this: MediaStream, ev: MediaStreamTrackEvent) => any) | null;\n    oninactive: ((this: MediaStream, ev: Event) => any) | null;\n    onremovetrack: ((this: MediaStream, ev: MediaStreamTrackEvent) => any) | null;\n    addTrack(track: MediaStreamTrack): void;\n    clone(): MediaStream;\n    getAudioTracks(): MediaStreamTrack[];\n    getTrackById(trackId: string): MediaStreamTrack | null;\n    getTracks(): MediaStreamTrack[];\n    getVideoTracks(): MediaStreamTrack[];\n    removeTrack(track: MediaStreamTrack): void;\n    stop(): void;\n    addEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: MediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MediaStreamEventMap>(type: K, listener: (this: MediaStream, ev: MediaStreamEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MediaStream: {\n    prototype: MediaStream;\n    new(): MediaStream;\n    new(stream: MediaStream): MediaStream;\n    new(tracks: MediaStreamTrack[]): MediaStream;\n};\n\ninterface MediaStreamAudioDestinationNode extends AudioNode {\n    readonly stream: MediaStream;\n}\n\ndeclare var MediaStreamAudioDestinationNode: {\n    prototype: MediaStreamAudioDestinationNode;\n    new(context: AudioContext, options?: AudioNodeOptions): MediaStreamAudioDestinationNode;\n};\n\ninterface MediaStreamAudioSourceNode extends AudioNode {\n    readonly mediaStream: MediaStream;\n}\n\ndeclare var MediaStreamAudioSourceNode: {\n    prototype: MediaStreamAudioSourceNode;\n    new(context: AudioContext, options: MediaStreamAudioSourceOptions): MediaStreamAudioSourceNode;\n};\n\ninterface MediaStreamError {\n    readonly constraintName: string | null;\n    readonly message: string | null;\n    readonly name: string;\n}\n\ndeclare var MediaStreamError: {\n    prototype: MediaStreamError;\n    new(): MediaStreamError;\n};\n\ninterface MediaStreamErrorEvent extends Event {\n    readonly error: MediaStreamError | null;\n}\n\ndeclare var MediaStreamErrorEvent: {\n    prototype: MediaStreamErrorEvent;\n    new(typeArg: string, eventInitDict?: MediaStreamErrorEventInit): MediaStreamErrorEvent;\n};\n\ninterface MediaStreamEvent extends Event {\n    readonly stream: MediaStream | null;\n}\n\ndeclare var MediaStreamEvent: {\n    prototype: MediaStreamEvent;\n    new(type: string, eventInitDict: MediaStreamEventInit): MediaStreamEvent;\n};\n\ninterface MediaStreamTrackEventMap {\n    "ended": MediaStreamErrorEvent;\n    "isolationchange": Event;\n    "mute": Event;\n    "overconstrained": MediaStreamErrorEvent;\n    "unmute": Event;\n}\n\ninterface MediaStreamTrack extends EventTarget {\n    enabled: boolean;\n    readonly id: string;\n    readonly isolated: boolean;\n    readonly kind: string;\n    readonly label: string;\n    readonly muted: boolean;\n    onended: ((this: MediaStreamTrack, ev: MediaStreamErrorEvent) => any) | null;\n    onisolationchange: ((this: MediaStreamTrack, ev: Event) => any) | null;\n    onmute: ((this: MediaStreamTrack, ev: Event) => any) | null;\n    onoverconstrained: ((this: MediaStreamTrack, ev: MediaStreamErrorEvent) => any) | null;\n    onunmute: ((this: MediaStreamTrack, ev: Event) => any) | null;\n    readonly readonly: boolean;\n    readonly readyState: MediaStreamTrackState;\n    readonly remote: boolean;\n    applyConstraints(constraints: MediaTrackConstraints): Promise<void>;\n    clone(): MediaStreamTrack;\n    getCapabilities(): MediaTrackCapabilities;\n    getConstraints(): MediaTrackConstraints;\n    getSettings(): MediaTrackSettings;\n    stop(): void;\n    addEventListener<K extends keyof MediaStreamTrackEventMap>(type: K, listener: (this: MediaStreamTrack, ev: MediaStreamTrackEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MediaStreamTrackEventMap>(type: K, listener: (this: MediaStreamTrack, ev: MediaStreamTrackEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MediaStreamTrack: {\n    prototype: MediaStreamTrack;\n    new(): MediaStreamTrack;\n};\n\ninterface MediaStreamTrackAudioSourceNode extends AudioNode {\n}\n\ndeclare var MediaStreamTrackAudioSourceNode: {\n    prototype: MediaStreamTrackAudioSourceNode;\n    new(context: AudioContext, options: MediaStreamTrackAudioSourceOptions): MediaStreamTrackAudioSourceNode;\n};\n\ninterface MediaStreamTrackEvent extends Event {\n    readonly track: MediaStreamTrack;\n}\n\ndeclare var MediaStreamTrackEvent: {\n    prototype: MediaStreamTrackEvent;\n    new(typeArg: string, eventInitDict?: MediaStreamTrackEventInit): MediaStreamTrackEvent;\n};\n\ninterface MessageChannel {\n    readonly port1: MessagePort;\n    readonly port2: MessagePort;\n}\n\ndeclare var MessageChannel: {\n    prototype: MessageChannel;\n    new(): MessageChannel;\n};\n\ninterface MessageEvent extends Event {\n    /**\n     * Returns the data of the message.\n     */\n    readonly data: any;\n    /**\n     * Returns the last event ID string, for\n     * server-sent events.\n     */\n    readonly lastEventId: string;\n    /**\n     * Returns the origin of the message, for server-sent events and\n     * cross-document messaging.\n     */\n    readonly origin: string;\n    /**\n     * Returns the MessagePort array sent with the message, for cross-document\n     * messaging and channel messaging.\n     */\n    readonly ports: ReadonlyArray<MessagePort>;\n    /**\n     * Returns the WindowProxy of the source window, for cross-document\n     * messaging, and the MessagePort being attached, in the connect event fired at\n     * SharedWorkerGlobalScope objects.\n     */\n    readonly source: MessageEventSource | null;\n}\n\ndeclare var MessageEvent: {\n    prototype: MessageEvent;\n    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;\n};\n\ninterface MessagePortEventMap {\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface MessagePort extends EventTarget {\n    onmessage: ((this: MessagePort, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: MessagePort, ev: MessageEvent) => any) | null;\n    /**\n     * Disconnects the port, so that it is no longer active.\n     */\n    close(): void;\n    /**\n     * Posts a message through the channel. Objects listed in transfer are\n     * transferred, not just cloned, meaning that they are no longer usable on the sending side.\n     * Throws a "DataCloneError" DOMException if\n     * transfer contains duplicate objects or port, or if message\n     * could not be cloned.\n     */\n    postMessage(message: any, transfer?: Transferable[]): void;\n    /**\n     * Begins dispatching messages received on the port.\n     */\n    start(): void;\n    addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MessagePort: {\n    prototype: MessagePort;\n    new(): MessagePort;\n};\n\ninterface MimeType {\n    readonly description: string;\n    readonly enabledPlugin: Plugin;\n    readonly suffixes: string;\n    readonly type: string;\n}\n\ndeclare var MimeType: {\n    prototype: MimeType;\n    new(): MimeType;\n};\n\ninterface MimeTypeArray {\n    readonly length: number;\n    item(index: number): Plugin;\n    namedItem(type: string): Plugin;\n    [index: number]: Plugin;\n}\n\ndeclare var MimeTypeArray: {\n    prototype: MimeTypeArray;\n    new(): MimeTypeArray;\n};\n\ninterface MouseEvent extends UIEvent {\n    readonly altKey: boolean;\n    readonly button: number;\n    readonly buttons: number;\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly ctrlKey: boolean;\n    /** @deprecated */\n    readonly fromElement: Element;\n    readonly layerX: number;\n    readonly layerY: number;\n    readonly metaKey: boolean;\n    readonly movementX: number;\n    readonly movementY: number;\n    readonly offsetX: number;\n    readonly offsetY: number;\n    readonly pageX: number;\n    readonly pageY: number;\n    readonly relatedTarget: EventTarget;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly shiftKey: boolean;\n    /** @deprecated */\n    readonly toElement: Element;\n    /** @deprecated */\n    readonly which: number;\n    readonly x: number;\n    readonly y: number;\n    getModifierState(keyArg: string): boolean;\n    initMouseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, ctrlKeyArg: boolean, altKeyArg: boolean, shiftKeyArg: boolean, metaKeyArg: boolean, buttonArg: number, relatedTargetArg: EventTarget | null): void;\n}\n\ndeclare var MouseEvent: {\n    prototype: MouseEvent;\n    new(typeArg: string, eventInitDict?: MouseEventInit): MouseEvent;\n};\n\ninterface MutationEvent extends Event {\n    readonly attrChange: number;\n    readonly attrName: string;\n    readonly newValue: string;\n    readonly prevValue: string;\n    readonly relatedNode: Node;\n    initMutationEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, relatedNodeArg: Node, prevValueArg: string, newValueArg: string, attrNameArg: string, attrChangeArg: number): void;\n    readonly ADDITION: number;\n    readonly MODIFICATION: number;\n    readonly REMOVAL: number;\n}\n\ndeclare var MutationEvent: {\n    prototype: MutationEvent;\n    new(): MutationEvent;\n    readonly ADDITION: number;\n    readonly MODIFICATION: number;\n    readonly REMOVAL: number;\n};\n\ninterface MutationObserver {\n    disconnect(): void;\n    /**\n     * Instructs the user agent to observe a given target (a node) and report any mutations based on\n     * the criteria given by options (an object).\n     * The options argument allows for setting mutation\n     * observation options via object members. These are the object members that\n     * can be used:\n     * childList\n     * Set to true if mutations to target\'s children are to be observed.\n     * attributes\n     * Set to true if mutations to target\'s attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is\n     * specified.\n     * characterData\n     * Set to true if mutations to target\'s data are to be observed. Can be omitted if characterDataOldValue is specified.\n     * subtree\n     * Set to true if mutations to not just target, but\n     * also target\'s descendants are to be\n     * observed.\n     * attributeOldValue\n     * Set to true if attributes is true or omitted\n     * and target\'s attribute value before the mutation\n     * needs to be recorded.\n     * characterDataOldValue\n     * Set to true if characterData is set to true or omitted and target\'s data before the mutation\n     * needs to be recorded.\n     * attributeFilter\n     * Set to a list of attribute local names (without namespace) if not all attribute mutations need to be\n     * observed and attributes is true\n     * or omitted.\n     */\n    observe(target: Node, options?: MutationObserverInit): void;\n    /**\n     * Empties the record queue and\n     * returns what was in there.\n     */\n    takeRecords(): MutationRecord[];\n}\n\ndeclare var MutationObserver: {\n    prototype: MutationObserver;\n    new(callback: MutationCallback): MutationObserver;\n};\n\ninterface MutationRecord {\n    readonly addedNodes: NodeList;\n    /**\n     * Returns the local name of the\n     * changed attribute, and null otherwise.\n     */\n    readonly attributeName: string | null;\n    /**\n     * Returns the namespace of the\n     * changed attribute, and null otherwise.\n     */\n    readonly attributeNamespace: string | null;\n    /**\n     * Return the previous and next sibling respectively\n     * of the added or removed nodes, and null otherwise.\n     */\n    readonly nextSibling: Node | null;\n    /**\n     * The return value depends on type. For\n     * "attributes", it is the value of the\n     * changed attribute before the change.\n     * For "characterData", it is the data of the changed node before the change. For\n     * "childList", it is null.\n     */\n    readonly oldValue: string | null;\n    readonly previousSibling: Node | null;\n    /**\n     * Return the nodes added and removed\n     * respectively.\n     */\n    readonly removedNodes: NodeList;\n    readonly target: Node;\n    /**\n     * Returns "attributes" if it was an attribute mutation.\n     * "characterData" if it was a mutation to a CharacterData node. And\n     * "childList" if it was a mutation to the tree of nodes.\n     */\n    readonly type: MutationRecordType;\n}\n\ndeclare var MutationRecord: {\n    prototype: MutationRecord;\n    new(): MutationRecord;\n};\n\ninterface NamedNodeMap {\n    readonly length: number;\n    getNamedItem(qualifiedName: string): Attr | null;\n    getNamedItemNS(namespace: string | null, localName: string): Attr | null;\n    item(index: number): Attr | null;\n    removeNamedItem(qualifiedName: string): Attr;\n    removeNamedItemNS(namespace: string | null, localName: string): Attr;\n    setNamedItem(attr: Attr): Attr | null;\n    setNamedItemNS(attr: Attr): Attr | null;\n    [index: number]: Attr;\n}\n\ndeclare var NamedNodeMap: {\n    prototype: NamedNodeMap;\n    new(): NamedNodeMap;\n};\n\ninterface NavigationPreloadManager {\n    disable(): Promise<void>;\n    enable(): Promise<void>;\n    getState(): Promise<NavigationPreloadState>;\n    setHeaderValue(value: string): Promise<void>;\n}\n\ndeclare var NavigationPreloadManager: {\n    prototype: NavigationPreloadManager;\n    new(): NavigationPreloadManager;\n};\n\ninterface Navigator extends NavigatorID, NavigatorOnLine, NavigatorContentUtils, NavigatorStorageUtils, MSNavigatorDoNotTrack, MSFileSaver, NavigatorBeacon, NavigatorConcurrentHardware, NavigatorUserMedia, NavigatorLanguage, NavigatorStorage, NavigatorAutomationInformation {\n    readonly activeVRDisplays: ReadonlyArray<VRDisplay>;\n    readonly authentication: WebAuthentication;\n    readonly cookieEnabled: boolean;\n    readonly doNotTrack: string | null;\n    gamepadInputEmulation: GamepadInputEmulationType;\n    readonly geolocation: Geolocation;\n    readonly maxTouchPoints: number;\n    readonly mimeTypes: MimeTypeArray;\n    readonly msManipulationViewsEnabled: boolean;\n    readonly msMaxTouchPoints: number;\n    readonly msPointerEnabled: boolean;\n    readonly plugins: PluginArray;\n    readonly pointerEnabled: boolean;\n    readonly serviceWorker: ServiceWorkerContainer;\n    readonly webdriver: boolean;\n    getGamepads(): (Gamepad | null)[];\n    getVRDisplays(): Promise<VRDisplay[]>;\n    javaEnabled(): boolean;\n    msLaunchUri(uri: string, successCallback?: MSLaunchUriCallback, noHandlerCallback?: MSLaunchUriCallback): void;\n    requestMediaKeySystemAccess(keySystem: string, supportedConfigurations: MediaKeySystemConfiguration[]): Promise<MediaKeySystemAccess>;\n    vibrate(pattern: number | number[]): boolean;\n}\n\ndeclare var Navigator: {\n    prototype: Navigator;\n    new(): Navigator;\n};\n\ninterface NavigatorAutomationInformation {\n    readonly webdriver: boolean;\n}\n\ninterface NavigatorBeacon {\n    sendBeacon(url: string, data?: Blob | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | FormData | string | null): boolean;\n}\n\ninterface NavigatorConcurrentHardware {\n    readonly hardwareConcurrency: number;\n}\n\ninterface NavigatorContentUtils {\n}\n\ninterface NavigatorID {\n    readonly appCodeName: string;\n    readonly appName: string;\n    readonly appVersion: string;\n    readonly platform: string;\n    readonly product: string;\n    readonly productSub: string;\n    readonly userAgent: string;\n    readonly vendor: string;\n    readonly vendorSub: string;\n}\n\ninterface NavigatorLanguage {\n    readonly language: string;\n    readonly languages: ReadonlyArray<string>;\n}\n\ninterface NavigatorOnLine {\n    readonly onLine: boolean;\n}\n\ninterface NavigatorStorage {\n    readonly storage: StorageManager;\n}\n\ninterface NavigatorStorageUtils {\n}\n\ninterface NavigatorUserMedia {\n    readonly mediaDevices: MediaDevices;\n    getDisplayMedia(constraints: MediaStreamConstraints): Promise<MediaStream>;\n    getUserMedia(constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void;\n}\n\ninterface Node extends EventTarget {\n    /**\n     * Returns node\'s node document\'s document base URL.\n     */\n    readonly baseURI: string;\n    /**\n     * Returns the children.\n     */\n    readonly childNodes: NodeListOf<ChildNode>;\n    /**\n     * Returns the first child.\n     */\n    readonly firstChild: ChildNode | null;\n    /**\n     * Returns true if node is connected and false otherwise.\n     */\n    readonly isConnected: boolean;\n    /**\n     * Returns the last child.\n     */\n    readonly lastChild: ChildNode | null;\n    /** @deprecated */\n    readonly namespaceURI: string | null;\n    /**\n     * Returns the next sibling.\n     */\n    readonly nextSibling: Node | null;\n    /**\n     * Returns a string appropriate for the type of node, as\n     * follows:\n     * Element\n     * Its HTML-uppercased qualified name.\n     * Attr\n     * Its qualified name.\n     * Text\n     * "#text".\n     * CDATASection\n     * "#cdata-section".\n     * ProcessingInstruction\n     * Its target.\n     * Comment\n     * "#comment".\n     * Document\n     * "#document".\n     * DocumentType\n     * Its name.\n     * DocumentFragment\n     * "#document-fragment".\n     */\n    readonly nodeName: string;\n    readonly nodeType: number;\n    nodeValue: string | null;\n    /**\n     * Returns the node document.\n     * Returns null for documents.\n     */\n    readonly ownerDocument: Document | null;\n    /**\n     * Returns the parent element.\n     */\n    readonly parentElement: HTMLElement | null;\n    /**\n     * Returns the parent.\n     */\n    readonly parentNode: Node & ParentNode | null;\n    /**\n     * Returns the previous sibling.\n     */\n    readonly previousSibling: Node | null;\n    textContent: string | null;\n    appendChild<T extends Node>(newChild: T): T;\n    /**\n     * Returns a copy of node. If deep is true, the copy also includes the node\'s descendants.\n     */\n    cloneNode(deep?: boolean): Node;\n    compareDocumentPosition(other: Node): number;\n    /**\n     * Returns true if other is an inclusive descendant of node, and false otherwise.\n     */\n    contains(other: Node | null): boolean;\n    /**\n     * Returns node\'s shadow-including root.\n     */\n    getRootNode(options?: GetRootNodeOptions): Node;\n    /**\n     * Returns whether node has children.\n     */\n    hasChildNodes(): boolean;\n    insertBefore<T extends Node>(newChild: T, refChild: Node | null): T;\n    isDefaultNamespace(namespace: string | null): boolean;\n    /**\n     * Returns whether node and otherNode have the same properties.\n     */\n    isEqualNode(otherNode: Node | null): boolean;\n    isSameNode(otherNode: Node | null): boolean;\n    lookupNamespaceURI(prefix: string | null): string | null;\n    lookupPrefix(namespace: string | null): string | null;\n    /**\n     * Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes.\n     */\n    normalize(): void;\n    removeChild<T extends Node>(oldChild: T): T;\n    replaceChild<T extends Node>(newChild: Node, oldChild: T): T;\n    readonly ATTRIBUTE_NODE: number;\n    readonly CDATA_SECTION_NODE: number;\n    readonly COMMENT_NODE: number;\n    readonly DOCUMENT_FRAGMENT_NODE: number;\n    readonly DOCUMENT_NODE: number;\n    readonly DOCUMENT_POSITION_CONTAINED_BY: number;\n    readonly DOCUMENT_POSITION_CONTAINS: number;\n    readonly DOCUMENT_POSITION_DISCONNECTED: number;\n    readonly DOCUMENT_POSITION_FOLLOWING: number;\n    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\n    readonly DOCUMENT_POSITION_PRECEDING: number;\n    readonly DOCUMENT_TYPE_NODE: number;\n    readonly ELEMENT_NODE: number;\n    readonly ENTITY_NODE: number;\n    readonly ENTITY_REFERENCE_NODE: number;\n    readonly NOTATION_NODE: number;\n    readonly PROCESSING_INSTRUCTION_NODE: number;\n    readonly TEXT_NODE: number;\n}\n\ndeclare var Node: {\n    prototype: Node;\n    new(): Node;\n    readonly ATTRIBUTE_NODE: number;\n    readonly CDATA_SECTION_NODE: number;\n    readonly COMMENT_NODE: number;\n    readonly DOCUMENT_FRAGMENT_NODE: number;\n    readonly DOCUMENT_NODE: number;\n    readonly DOCUMENT_POSITION_CONTAINED_BY: number;\n    readonly DOCUMENT_POSITION_CONTAINS: number;\n    readonly DOCUMENT_POSITION_DISCONNECTED: number;\n    readonly DOCUMENT_POSITION_FOLLOWING: number;\n    readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: number;\n    readonly DOCUMENT_POSITION_PRECEDING: number;\n    readonly DOCUMENT_TYPE_NODE: number;\n    readonly ELEMENT_NODE: number;\n    readonly ENTITY_NODE: number;\n    readonly ENTITY_REFERENCE_NODE: number;\n    readonly NOTATION_NODE: number;\n    readonly PROCESSING_INSTRUCTION_NODE: number;\n    readonly TEXT_NODE: number;\n};\n\ninterface NodeFilter {\n    acceptNode(node: Node): number;\n}\n\ndeclare var NodeFilter: {\n    readonly FILTER_ACCEPT: number;\n    readonly FILTER_REJECT: number;\n    readonly FILTER_SKIP: number;\n    readonly SHOW_ALL: number;\n    readonly SHOW_ATTRIBUTE: number;\n    readonly SHOW_CDATA_SECTION: number;\n    readonly SHOW_COMMENT: number;\n    readonly SHOW_DOCUMENT: number;\n    readonly SHOW_DOCUMENT_FRAGMENT: number;\n    readonly SHOW_DOCUMENT_TYPE: number;\n    readonly SHOW_ELEMENT: number;\n    readonly SHOW_ENTITY: number;\n    readonly SHOW_ENTITY_REFERENCE: number;\n    readonly SHOW_NOTATION: number;\n    readonly SHOW_PROCESSING_INSTRUCTION: number;\n    readonly SHOW_TEXT: number;\n};\n\ninterface NodeIterator {\n    readonly filter: NodeFilter | null;\n    readonly pointerBeforeReferenceNode: boolean;\n    readonly referenceNode: Node;\n    readonly root: Node;\n    readonly whatToShow: number;\n    detach(): void;\n    nextNode(): Node | null;\n    previousNode(): Node | null;\n}\n\ndeclare var NodeIterator: {\n    prototype: NodeIterator;\n    new(): NodeIterator;\n};\n\ninterface NodeList {\n    /**\n     * Returns the number of nodes in the collection.\n     */\n    readonly length: number;\n    /**\n     * element = collection[index]\n     */\n    item(index: number): Node | null;\n    /**\n     * Performs the specified action for each node in an list.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the list.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: Node, key: number, parent: NodeList) => void, thisArg?: any): void;\n    [index: number]: Node;\n}\n\ndeclare var NodeList: {\n    prototype: NodeList;\n    new(): NodeList;\n};\n\ninterface NodeListOf<TNode extends Node> extends NodeList {\n    length: number;\n    item(index: number): TNode;\n    /**\n     * Performs the specified action for each node in an list.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the list.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: TNode, key: number, parent: NodeListOf<TNode>) => void, thisArg?: any): void;\n    [index: number]: TNode;\n}\n\ninterface NodeSelector {\n    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n    querySelector<E extends Element = Element>(selectors: string): E | null;\n    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;\n    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;\n    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;\n}\n\ninterface NonDocumentTypeChildNode {\n    /**\n     * Returns the first following sibling that\n     * is an element, and null otherwise.\n     */\n    readonly nextElementSibling: Element | null;\n    /**\n     * Returns the first preceding sibling that\n     * is an element, and null otherwise.\n     */\n    readonly previousElementSibling: Element | null;\n}\n\ninterface NonElementParentNode {\n    /**\n     * Returns the first element within node\'s descendants whose ID is elementId.\n     */\n    getElementById(elementId: string): Element | null;\n}\n\ninterface NotificationEventMap {\n    "click": Event;\n    "close": Event;\n    "error": Event;\n    "show": Event;\n}\n\ninterface Notification extends EventTarget {\n    readonly actions: ReadonlyArray<NotificationAction>;\n    readonly badge: string;\n    readonly body: string;\n    readonly data: any;\n    readonly dir: NotificationDirection;\n    readonly icon: string;\n    readonly image: string;\n    readonly lang: string;\n    onclick: ((this: Notification, ev: Event) => any) | null;\n    onclose: ((this: Notification, ev: Event) => any) | null;\n    onerror: ((this: Notification, ev: Event) => any) | null;\n    onshow: ((this: Notification, ev: Event) => any) | null;\n    readonly renotify: boolean;\n    readonly requireInteraction: boolean;\n    readonly silent: boolean;\n    readonly tag: string;\n    readonly timestamp: number;\n    readonly title: string;\n    readonly vibrate: ReadonlyArray<number>;\n    close(): void;\n    addEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Notification: {\n    prototype: Notification;\n    new(title: string, options?: NotificationOptions): Notification;\n    readonly maxActions: number;\n    readonly permission: NotificationPermission;\n    requestPermission(deprecatedCallback?: NotificationPermissionCallback): Promise<NotificationPermission>;\n};\n\ninterface OES_element_index_uint {\n}\n\ninterface OES_standard_derivatives {\n    readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES: GLenum;\n}\n\ninterface OES_texture_float {\n}\n\ninterface OES_texture_float_linear {\n}\n\ninterface OES_texture_half_float {\n    readonly HALF_FLOAT_OES: GLenum;\n}\n\ninterface OES_texture_half_float_linear {\n}\n\ninterface OES_vertex_array_object {\n    bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): void;\n    createVertexArrayOES(): WebGLVertexArrayObjectOES | null;\n    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): void;\n    isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): GLboolean;\n    readonly VERTEX_ARRAY_BINDING_OES: GLenum;\n}\n\ninterface OfflineAudioCompletionEvent extends Event {\n    readonly renderedBuffer: AudioBuffer;\n}\n\ndeclare var OfflineAudioCompletionEvent: {\n    prototype: OfflineAudioCompletionEvent;\n    new(type: string, eventInitDict: OfflineAudioCompletionEventInit): OfflineAudioCompletionEvent;\n};\n\ninterface OfflineAudioContextEventMap extends BaseAudioContextEventMap {\n    "complete": OfflineAudioCompletionEvent;\n}\n\ninterface OfflineAudioContext extends BaseAudioContext {\n    readonly length: number;\n    oncomplete: ((this: OfflineAudioContext, ev: OfflineAudioCompletionEvent) => any) | null;\n    startRendering(): Promise<AudioBuffer>;\n    suspend(suspendTime: number): Promise<void>;\n    addEventListener<K extends keyof OfflineAudioContextEventMap>(type: K, listener: (this: OfflineAudioContext, ev: OfflineAudioContextEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof OfflineAudioContextEventMap>(type: K, listener: (this: OfflineAudioContext, ev: OfflineAudioContextEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var OfflineAudioContext: {\n    prototype: OfflineAudioContext;\n    new(contextOptions: OfflineAudioContextOptions): OfflineAudioContext;\n    new(numberOfChannels: number, length: number, sampleRate: number): OfflineAudioContext;\n};\n\ninterface OscillatorNode extends AudioScheduledSourceNode {\n    readonly detune: AudioParam;\n    readonly frequency: AudioParam;\n    type: OscillatorType;\n    setPeriodicWave(periodicWave: PeriodicWave): void;\n    addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: OscillatorNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type: K, listener: (this: OscillatorNode, ev: AudioScheduledSourceNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var OscillatorNode: {\n    prototype: OscillatorNode;\n    new(context: BaseAudioContext, options?: OscillatorOptions): OscillatorNode;\n};\n\ninterface OverflowEvent extends UIEvent {\n    readonly horizontalOverflow: boolean;\n    readonly orient: number;\n    readonly verticalOverflow: boolean;\n    readonly BOTH: number;\n    readonly HORIZONTAL: number;\n    readonly VERTICAL: number;\n}\n\ndeclare var OverflowEvent: {\n    prototype: OverflowEvent;\n    new(): OverflowEvent;\n    readonly BOTH: number;\n    readonly HORIZONTAL: number;\n    readonly VERTICAL: number;\n};\n\ninterface PageTransitionEvent extends Event {\n    readonly persisted: boolean;\n}\n\ndeclare var PageTransitionEvent: {\n    prototype: PageTransitionEvent;\n    new(): PageTransitionEvent;\n};\n\ninterface PannerNode extends AudioNode {\n    coneInnerAngle: number;\n    coneOuterAngle: number;\n    coneOuterGain: number;\n    distanceModel: DistanceModelType;\n    maxDistance: number;\n    readonly orientationX: AudioParam;\n    readonly orientationY: AudioParam;\n    readonly orientationZ: AudioParam;\n    panningModel: PanningModelType;\n    readonly positionX: AudioParam;\n    readonly positionY: AudioParam;\n    readonly positionZ: AudioParam;\n    refDistance: number;\n    rolloffFactor: number;\n    /** @deprecated */\n    setOrientation(x: number, y: number, z: number): void;\n    /** @deprecated */\n    setPosition(x: number, y: number, z: number): void;\n}\n\ndeclare var PannerNode: {\n    prototype: PannerNode;\n    new(context: BaseAudioContext, options?: PannerOptions): PannerNode;\n};\n\ninterface ParentNode {\n    readonly childElementCount: number;\n    /**\n     * Returns the child elements.\n     */\n    readonly children: HTMLCollection;\n    /**\n     * Returns the first child that is an element, and null otherwise.\n     */\n    readonly firstElementChild: Element | null;\n    /**\n     * Returns the last child that is an element, and null otherwise.\n     */\n    readonly lastElementChild: Element | null;\n    /**\n     * Inserts nodes after the last child of node, while replacing\n     * strings in nodes with equivalent Text nodes.\n     * Throws a "HierarchyRequestError" DOMException if the constraints of\n     * the node tree are violated.\n     */\n    append(...nodes: (Node | string)[]): void;\n    /**\n     * Inserts nodes before the first child of node, while\n     * replacing strings in nodes with equivalent Text nodes.\n     * Throws a "HierarchyRequestError" DOMException if the constraints of\n     * the node tree are violated.\n     */\n    prepend(...nodes: (Node | string)[]): void;\n    /**\n     * Returns the first element that is a descendant of node that\n     * matches selectors.\n     */\n    querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n    querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n    querySelector<E extends Element = Element>(selectors: string): E | null;\n    /**\n     * Returns all element descendants of node that\n     * match selectors.\n     */\n    querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;\n    querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;\n    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;\n}\n\ninterface Path2D extends CanvasPath {\n    addPath(path: Path2D, transform?: DOMMatrix2DInit): void;\n}\n\ndeclare var Path2D: {\n    prototype: Path2D;\n    new(path?: Path2D | string): Path2D;\n};\n\ninterface PaymentAddress {\n    readonly addressLine: string[];\n    readonly city: string;\n    readonly country: string;\n    readonly dependentLocality: string;\n    readonly languageCode: string;\n    readonly organization: string;\n    readonly phone: string;\n    readonly postalCode: string;\n    readonly recipient: string;\n    readonly region: string;\n    readonly sortingCode: string;\n    toJSON(): any;\n}\n\ndeclare var PaymentAddress: {\n    prototype: PaymentAddress;\n    new(): PaymentAddress;\n};\n\ninterface PaymentRequestEventMap {\n    "shippingaddresschange": Event;\n    "shippingoptionchange": Event;\n}\n\ninterface PaymentRequest extends EventTarget {\n    readonly id: string;\n    onshippingaddresschange: ((this: PaymentRequest, ev: Event) => any) | null;\n    onshippingoptionchange: ((this: PaymentRequest, ev: Event) => any) | null;\n    readonly shippingAddress: PaymentAddress | null;\n    readonly shippingOption: string | null;\n    readonly shippingType: PaymentShippingType | null;\n    abort(): Promise<void>;\n    canMakePayment(): Promise<boolean>;\n    show(): Promise<PaymentResponse>;\n    addEventListener<K extends keyof PaymentRequestEventMap>(type: K, listener: (this: PaymentRequest, ev: PaymentRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof PaymentRequestEventMap>(type: K, listener: (this: PaymentRequest, ev: PaymentRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var PaymentRequest: {\n    prototype: PaymentRequest;\n    new(methodData: PaymentMethodData[], details: PaymentDetailsInit, options?: PaymentOptions): PaymentRequest;\n};\n\ninterface PaymentRequestUpdateEvent extends Event {\n    updateWith(detailsPromise: Promise<PaymentDetailsUpdate>): void;\n}\n\ndeclare var PaymentRequestUpdateEvent: {\n    prototype: PaymentRequestUpdateEvent;\n    new(type: string, eventInitDict?: PaymentRequestUpdateEventInit): PaymentRequestUpdateEvent;\n};\n\ninterface PaymentResponse {\n    readonly details: any;\n    readonly methodName: string;\n    readonly payerEmail: string | null;\n    readonly payerName: string | null;\n    readonly payerPhone: string | null;\n    readonly requestId: string;\n    readonly shippingAddress: PaymentAddress | null;\n    readonly shippingOption: string | null;\n    complete(result?: PaymentComplete): Promise<void>;\n    toJSON(): any;\n}\n\ndeclare var PaymentResponse: {\n    prototype: PaymentResponse;\n    new(): PaymentResponse;\n};\n\ninterface PerfWidgetExternal {\n    readonly activeNetworkRequestCount: number;\n    readonly averageFrameTime: number;\n    readonly averagePaintTime: number;\n    readonly extraInformationEnabled: boolean;\n    readonly independentRenderingEnabled: boolean;\n    readonly irDisablingContentString: string;\n    readonly irStatusAvailable: boolean;\n    readonly maxCpuSpeed: number;\n    readonly paintRequestsPerSecond: number;\n    readonly performanceCounter: number;\n    readonly performanceCounterFrequency: number;\n    addEventListener(eventType: string, callback: Function): void;\n    getMemoryUsage(): number;\n    getProcessCpuUsage(): number;\n    getRecentCpuUsage(last: number | null): any;\n    getRecentFrames(last: number | null): any;\n    getRecentMemoryUsage(last: number | null): any;\n    getRecentPaintRequests(last: number | null): any;\n    removeEventListener(eventType: string, callback: Function): void;\n    repositionWindow(x: number, y: number): void;\n    resizeWindow(width: number, height: number): void;\n}\n\ndeclare var PerfWidgetExternal: {\n    prototype: PerfWidgetExternal;\n    new(): PerfWidgetExternal;\n};\n\ninterface PerformanceEventMap {\n    "resourcetimingbufferfull": Event;\n}\n\ninterface Performance extends EventTarget {\n    /** @deprecated */\n    readonly navigation: PerformanceNavigation;\n    onresourcetimingbufferfull: ((this: Performance, ev: Event) => any) | null;\n    readonly timeOrigin: number;\n    /** @deprecated */\n    readonly timing: PerformanceTiming;\n    clearMarks(markName?: string): void;\n    clearMeasures(measureName?: string): void;\n    clearResourceTimings(): void;\n    getEntries(): PerformanceEntryList;\n    getEntriesByName(name: string, type?: string): PerformanceEntryList;\n    getEntriesByType(type: string): PerformanceEntryList;\n    mark(markName: string): void;\n    measure(measureName: string, startMark?: string, endMark?: string): void;\n    now(): number;\n    setResourceTimingBufferSize(maxSize: number): void;\n    toJSON(): any;\n    addEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Performance: {\n    prototype: Performance;\n    new(): Performance;\n};\n\ninterface PerformanceEntry {\n    readonly duration: number;\n    readonly entryType: string;\n    readonly name: string;\n    readonly startTime: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceEntry: {\n    prototype: PerformanceEntry;\n    new(): PerformanceEntry;\n};\n\ninterface PerformanceMark extends PerformanceEntry {\n}\n\ndeclare var PerformanceMark: {\n    prototype: PerformanceMark;\n    new(): PerformanceMark;\n};\n\ninterface PerformanceMeasure extends PerformanceEntry {\n}\n\ndeclare var PerformanceMeasure: {\n    prototype: PerformanceMeasure;\n    new(): PerformanceMeasure;\n};\n\ninterface PerformanceNavigation {\n    readonly redirectCount: number;\n    readonly type: number;\n    toJSON(): any;\n    readonly TYPE_BACK_FORWARD: number;\n    readonly TYPE_NAVIGATE: number;\n    readonly TYPE_RELOAD: number;\n    readonly TYPE_RESERVED: number;\n}\n\ndeclare var PerformanceNavigation: {\n    prototype: PerformanceNavigation;\n    new(): PerformanceNavigation;\n    readonly TYPE_BACK_FORWARD: number;\n    readonly TYPE_NAVIGATE: number;\n    readonly TYPE_RELOAD: number;\n    readonly TYPE_RESERVED: number;\n};\n\ninterface PerformanceNavigationTiming extends PerformanceResourceTiming {\n    readonly domComplete: number;\n    readonly domContentLoadedEventEnd: number;\n    readonly domContentLoadedEventStart: number;\n    readonly domInteractive: number;\n    readonly loadEventEnd: number;\n    readonly loadEventStart: number;\n    readonly redirectCount: number;\n    readonly type: NavigationType;\n    readonly unloadEventEnd: number;\n    readonly unloadEventStart: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceNavigationTiming: {\n    prototype: PerformanceNavigationTiming;\n    new(): PerformanceNavigationTiming;\n};\n\ninterface PerformanceObserver {\n    disconnect(): void;\n    observe(options: PerformanceObserverInit): void;\n    takeRecords(): PerformanceEntryList;\n}\n\ndeclare var PerformanceObserver: {\n    prototype: PerformanceObserver;\n    new(callback: PerformanceObserverCallback): PerformanceObserver;\n};\n\ninterface PerformanceObserverEntryList {\n    getEntries(): PerformanceEntryList;\n    getEntriesByName(name: string, type?: string): PerformanceEntryList;\n    getEntriesByType(type: string): PerformanceEntryList;\n}\n\ndeclare var PerformanceObserverEntryList: {\n    prototype: PerformanceObserverEntryList;\n    new(): PerformanceObserverEntryList;\n};\n\ninterface PerformanceResourceTiming extends PerformanceEntry {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly decodedBodySize: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly encodedBodySize: number;\n    readonly fetchStart: number;\n    readonly initiatorType: string;\n    readonly nextHopProtocol: string;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly secureConnectionStart: number;\n    readonly transferSize: number;\n    readonly workerStart: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceResourceTiming: {\n    prototype: PerformanceResourceTiming;\n    new(): PerformanceResourceTiming;\n};\n\ninterface PerformanceTiming {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly domComplete: number;\n    readonly domContentLoadedEventEnd: number;\n    readonly domContentLoadedEventStart: number;\n    readonly domInteractive: number;\n    readonly domLoading: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly fetchStart: number;\n    readonly loadEventEnd: number;\n    readonly loadEventStart: number;\n    readonly navigationStart: number;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly secureConnectionStart: number;\n    readonly unloadEventEnd: number;\n    readonly unloadEventStart: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceTiming: {\n    prototype: PerformanceTiming;\n    new(): PerformanceTiming;\n};\n\ninterface PeriodicWave {\n}\n\ndeclare var PeriodicWave: {\n    prototype: PeriodicWave;\n    new(context: BaseAudioContext, options?: PeriodicWaveOptions): PeriodicWave;\n};\n\ninterface PermissionRequest extends DeferredPermissionRequest {\n    readonly state: MSWebViewPermissionState;\n    defer(): void;\n}\n\ndeclare var PermissionRequest: {\n    prototype: PermissionRequest;\n    new(): PermissionRequest;\n};\n\ninterface PermissionRequestedEvent extends Event {\n    readonly permissionRequest: PermissionRequest;\n}\n\ndeclare var PermissionRequestedEvent: {\n    prototype: PermissionRequestedEvent;\n    new(): PermissionRequestedEvent;\n};\n\ninterface Plugin {\n    readonly description: string;\n    readonly filename: string;\n    readonly length: number;\n    readonly name: string;\n    readonly version: string;\n    item(index: number): MimeType;\n    namedItem(type: string): MimeType;\n    [index: number]: MimeType;\n}\n\ndeclare var Plugin: {\n    prototype: Plugin;\n    new(): Plugin;\n};\n\ninterface PluginArray {\n    readonly length: number;\n    item(index: number): Plugin;\n    namedItem(name: string): Plugin;\n    refresh(reload?: boolean): void;\n    [index: number]: Plugin;\n}\n\ndeclare var PluginArray: {\n    prototype: PluginArray;\n    new(): PluginArray;\n};\n\ninterface PointerEvent extends MouseEvent {\n    readonly height: number;\n    readonly isPrimary: boolean;\n    readonly pointerId: number;\n    readonly pointerType: string;\n    readonly pressure: number;\n    readonly tangentialPressure: number;\n    readonly tiltX: number;\n    readonly tiltY: number;\n    readonly twist: number;\n    readonly width: number;\n}\n\ndeclare var PointerEvent: {\n    prototype: PointerEvent;\n    new(type: string, eventInitDict?: PointerEventInit): PointerEvent;\n};\n\ninterface PopStateEvent extends Event {\n    readonly state: any;\n}\n\ndeclare var PopStateEvent: {\n    prototype: PopStateEvent;\n    new(type: string, eventInitDict?: PopStateEventInit): PopStateEvent;\n};\n\ninterface Position {\n    readonly coords: Coordinates;\n    readonly timestamp: number;\n}\n\ninterface PositionError {\n    readonly code: number;\n    readonly message: string;\n    readonly PERMISSION_DENIED: number;\n    readonly POSITION_UNAVAILABLE: number;\n    readonly TIMEOUT: number;\n}\n\ninterface ProcessingInstruction extends CharacterData {\n    readonly target: string;\n}\n\ndeclare var ProcessingInstruction: {\n    prototype: ProcessingInstruction;\n    new(): ProcessingInstruction;\n};\n\ninterface ProgressEvent extends Event {\n    readonly lengthComputable: boolean;\n    readonly loaded: number;\n    readonly total: number;\n}\n\ndeclare var ProgressEvent: {\n    prototype: ProgressEvent;\n    new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;\n};\n\ninterface PromiseRejectionEvent extends Event {\n    readonly promise: Promise<any>;\n    readonly reason: any;\n}\n\ndeclare var PromiseRejectionEvent: {\n    prototype: PromiseRejectionEvent;\n    new(type: string, eventInitDict: PromiseRejectionEventInit): PromiseRejectionEvent;\n};\n\ninterface PushManager {\n    getSubscription(): Promise<PushSubscription | null>;\n    permissionState(options?: PushSubscriptionOptionsInit): Promise<PushPermissionState>;\n    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;\n}\n\ndeclare var PushManager: {\n    prototype: PushManager;\n    new(): PushManager;\n    readonly supportedContentEncodings: ReadonlyArray<string>;\n};\n\ninterface PushSubscription {\n    readonly endpoint: string;\n    readonly expirationTime: number | null;\n    readonly options: PushSubscriptionOptions;\n    getKey(name: PushEncryptionKeyName): ArrayBuffer | null;\n    toJSON(): PushSubscriptionJSON;\n    unsubscribe(): Promise<boolean>;\n}\n\ndeclare var PushSubscription: {\n    prototype: PushSubscription;\n    new(): PushSubscription;\n};\n\ninterface PushSubscriptionOptions {\n    readonly applicationServerKey: ArrayBuffer | null;\n    readonly userVisibleOnly: boolean;\n}\n\ndeclare var PushSubscriptionOptions: {\n    prototype: PushSubscriptionOptions;\n    new(): PushSubscriptionOptions;\n};\n\ninterface RTCCertificate {\n    readonly expires: number;\n    getFingerprints(): RTCDtlsFingerprint[];\n}\n\ndeclare var RTCCertificate: {\n    prototype: RTCCertificate;\n    new(): RTCCertificate;\n    getSupportedAlgorithms(): AlgorithmIdentifier[];\n};\n\ninterface RTCDTMFSenderEventMap {\n    "tonechange": RTCDTMFToneChangeEvent;\n}\n\ninterface RTCDTMFSender extends EventTarget {\n    readonly canInsertDTMF: boolean;\n    ontonechange: ((this: RTCDTMFSender, ev: RTCDTMFToneChangeEvent) => any) | null;\n    readonly toneBuffer: string;\n    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;\n    addEventListener<K extends keyof RTCDTMFSenderEventMap>(type: K, listener: (this: RTCDTMFSender, ev: RTCDTMFSenderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCDTMFSenderEventMap>(type: K, listener: (this: RTCDTMFSender, ev: RTCDTMFSenderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCDTMFSender: {\n    prototype: RTCDTMFSender;\n    new(): RTCDTMFSender;\n};\n\ninterface RTCDTMFToneChangeEvent extends Event {\n    readonly tone: string;\n}\n\ndeclare var RTCDTMFToneChangeEvent: {\n    prototype: RTCDTMFToneChangeEvent;\n    new(type: string, eventInitDict: RTCDTMFToneChangeEventInit): RTCDTMFToneChangeEvent;\n};\n\ninterface RTCDataChannelEventMap {\n    "bufferedamountlow": Event;\n    "close": Event;\n    "error": RTCErrorEvent;\n    "message": MessageEvent;\n    "open": Event;\n}\n\ninterface RTCDataChannel extends EventTarget {\n    binaryType: string;\n    readonly bufferedAmount: number;\n    bufferedAmountLowThreshold: number;\n    readonly id: number | null;\n    readonly label: string;\n    readonly maxPacketLifeTime: number | null;\n    readonly maxRetransmits: number | null;\n    readonly negotiated: boolean;\n    onbufferedamountlow: ((this: RTCDataChannel, ev: Event) => any) | null;\n    onclose: ((this: RTCDataChannel, ev: Event) => any) | null;\n    onerror: ((this: RTCDataChannel, ev: RTCErrorEvent) => any) | null;\n    onmessage: ((this: RTCDataChannel, ev: MessageEvent) => any) | null;\n    onopen: ((this: RTCDataChannel, ev: Event) => any) | null;\n    readonly ordered: boolean;\n    readonly priority: RTCPriorityType;\n    readonly protocol: string;\n    readonly readyState: RTCDataChannelState;\n    close(): void;\n    send(data: string): void;\n    send(data: Blob): void;\n    send(data: ArrayBuffer): void;\n    send(data: ArrayBufferView): void;\n    addEventListener<K extends keyof RTCDataChannelEventMap>(type: K, listener: (this: RTCDataChannel, ev: RTCDataChannelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCDataChannelEventMap>(type: K, listener: (this: RTCDataChannel, ev: RTCDataChannelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCDataChannel: {\n    prototype: RTCDataChannel;\n    new(): RTCDataChannel;\n};\n\ninterface RTCDataChannelEvent extends Event {\n    readonly channel: RTCDataChannel;\n}\n\ndeclare var RTCDataChannelEvent: {\n    prototype: RTCDataChannelEvent;\n    new(type: string, eventInitDict: RTCDataChannelEventInit): RTCDataChannelEvent;\n};\n\ninterface RTCDtlsTransportEventMap {\n    "error": RTCErrorEvent;\n    "statechange": Event;\n}\n\ninterface RTCDtlsTransport extends EventTarget {\n    onerror: ((this: RTCDtlsTransport, ev: RTCErrorEvent) => any) | null;\n    onstatechange: ((this: RTCDtlsTransport, ev: Event) => any) | null;\n    readonly state: RTCDtlsTransportState;\n    readonly transport: RTCIceTransport;\n    getRemoteCertificates(): ArrayBuffer[];\n    addEventListener<K extends keyof RTCDtlsTransportEventMap>(type: K, listener: (this: RTCDtlsTransport, ev: RTCDtlsTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCDtlsTransportEventMap>(type: K, listener: (this: RTCDtlsTransport, ev: RTCDtlsTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCDtlsTransport: {\n    prototype: RTCDtlsTransport;\n    new(): RTCDtlsTransport;\n};\n\ninterface RTCDtlsTransportStateChangedEvent extends Event {\n    readonly state: RTCDtlsTransportState;\n}\n\ndeclare var RTCDtlsTransportStateChangedEvent: {\n    prototype: RTCDtlsTransportStateChangedEvent;\n    new(): RTCDtlsTransportStateChangedEvent;\n};\n\ninterface RTCDtmfSenderEventMap {\n    "tonechange": RTCDTMFToneChangeEvent;\n}\n\ninterface RTCDtmfSender extends EventTarget {\n    readonly canInsertDTMF: boolean;\n    readonly duration: number;\n    readonly interToneGap: number;\n    ontonechange: ((this: RTCDtmfSender, ev: RTCDTMFToneChangeEvent) => any) | null;\n    readonly sender: RTCRtpSender;\n    readonly toneBuffer: string;\n    insertDTMF(tones: string, duration?: number, interToneGap?: number): void;\n    addEventListener<K extends keyof RTCDtmfSenderEventMap>(type: K, listener: (this: RTCDtmfSender, ev: RTCDtmfSenderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCDtmfSenderEventMap>(type: K, listener: (this: RTCDtmfSender, ev: RTCDtmfSenderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCDtmfSender: {\n    prototype: RTCDtmfSender;\n    new(sender: RTCRtpSender): RTCDtmfSender;\n};\n\ninterface RTCError extends Error {\n    errorDetail: string;\n    httpRequestStatusCode: number;\n    message: string;\n    name: string;\n    receivedAlert: number | null;\n    sctpCauseCode: number;\n    sdpLineNumber: number;\n    sentAlert: number | null;\n}\n\ndeclare var RTCError: {\n    prototype: RTCError;\n    new(errorDetail?: string, message?: string): RTCError;\n};\n\ninterface RTCErrorEvent extends Event {\n    readonly error: RTCError | null;\n}\n\ndeclare var RTCErrorEvent: {\n    prototype: RTCErrorEvent;\n    new(type: string, eventInitDict: RTCErrorEventInit): RTCErrorEvent;\n};\n\ninterface RTCIceCandidate {\n    readonly candidate: string;\n    readonly component: RTCIceComponent | null;\n    readonly foundation: string | null;\n    readonly ip: string | null;\n    readonly port: number | null;\n    readonly priority: number | null;\n    readonly protocol: RTCIceProtocol | null;\n    readonly relatedAddress: string | null;\n    readonly relatedPort: number | null;\n    readonly sdpMLineIndex: number | null;\n    readonly sdpMid: string | null;\n    readonly tcpType: RTCIceTcpCandidateType | null;\n    readonly type: RTCIceCandidateType | null;\n    readonly usernameFragment: string | null;\n    toJSON(): RTCIceCandidateInit;\n}\n\ndeclare var RTCIceCandidate: {\n    prototype: RTCIceCandidate;\n    new(candidateInitDict?: RTCIceCandidateInit): RTCIceCandidate;\n};\n\ninterface RTCIceCandidatePairChangedEvent extends Event {\n    readonly pair: RTCIceCandidatePair;\n}\n\ndeclare var RTCIceCandidatePairChangedEvent: {\n    prototype: RTCIceCandidatePairChangedEvent;\n    new(): RTCIceCandidatePairChangedEvent;\n};\n\ninterface RTCIceGathererEventMap {\n    "error": Event;\n    "localcandidate": RTCIceGathererEvent;\n}\n\ninterface RTCIceGatherer extends RTCStatsProvider {\n    readonly component: RTCIceComponent;\n    onerror: ((this: RTCIceGatherer, ev: Event) => any) | null;\n    onlocalcandidate: ((this: RTCIceGatherer, ev: RTCIceGathererEvent) => any) | null;\n    createAssociatedGatherer(): RTCIceGatherer;\n    getLocalCandidates(): RTCIceCandidateDictionary[];\n    getLocalParameters(): RTCIceParameters;\n    addEventListener<K extends keyof RTCIceGathererEventMap>(type: K, listener: (this: RTCIceGatherer, ev: RTCIceGathererEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCIceGathererEventMap>(type: K, listener: (this: RTCIceGatherer, ev: RTCIceGathererEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCIceGatherer: {\n    prototype: RTCIceGatherer;\n    new(options: RTCIceGatherOptions): RTCIceGatherer;\n};\n\ninterface RTCIceGathererEvent extends Event {\n    readonly candidate: RTCIceCandidateDictionary | RTCIceCandidateComplete;\n}\n\ndeclare var RTCIceGathererEvent: {\n    prototype: RTCIceGathererEvent;\n    new(): RTCIceGathererEvent;\n};\n\ninterface RTCIceTransportEventMap {\n    "gatheringstatechange": Event;\n    "selectedcandidatepairchange": Event;\n    "statechange": Event;\n}\n\ninterface RTCIceTransport extends EventTarget {\n    readonly component: RTCIceComponent;\n    readonly gatheringState: RTCIceGathererState;\n    ongatheringstatechange: ((this: RTCIceTransport, ev: Event) => any) | null;\n    onselectedcandidatepairchange: ((this: RTCIceTransport, ev: Event) => any) | null;\n    onstatechange: ((this: RTCIceTransport, ev: Event) => any) | null;\n    readonly role: RTCIceRole;\n    readonly state: RTCIceTransportState;\n    getLocalCandidates(): RTCIceCandidate[];\n    getLocalParameters(): RTCIceParameters | null;\n    getRemoteCandidates(): RTCIceCandidate[];\n    getRemoteParameters(): RTCIceParameters | null;\n    getSelectedCandidatePair(): RTCIceCandidatePair | null;\n    addEventListener<K extends keyof RTCIceTransportEventMap>(type: K, listener: (this: RTCIceTransport, ev: RTCIceTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCIceTransportEventMap>(type: K, listener: (this: RTCIceTransport, ev: RTCIceTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCIceTransport: {\n    prototype: RTCIceTransport;\n    new(): RTCIceTransport;\n};\n\ninterface RTCIceTransportStateChangedEvent extends Event {\n    readonly state: RTCIceTransportState;\n}\n\ndeclare var RTCIceTransportStateChangedEvent: {\n    prototype: RTCIceTransportStateChangedEvent;\n    new(): RTCIceTransportStateChangedEvent;\n};\n\ninterface RTCIdentityAssertion {\n    idp: string;\n    name: string;\n}\n\ndeclare var RTCIdentityAssertion: {\n    prototype: RTCIdentityAssertion;\n    new(idp: string, name: string): RTCIdentityAssertion;\n};\n\ninterface RTCPeerConnectionEventMap {\n    "connectionstatechange": Event;\n    "datachannel": RTCDataChannelEvent;\n    "icecandidate": RTCPeerConnectionIceEvent;\n    "icecandidateerror": RTCPeerConnectionIceErrorEvent;\n    "iceconnectionstatechange": Event;\n    "icegatheringstatechange": Event;\n    "negotiationneeded": Event;\n    "signalingstatechange": Event;\n    "statsended": RTCStatsEvent;\n    "track": RTCTrackEvent;\n}\n\ninterface RTCPeerConnection extends EventTarget {\n    readonly canTrickleIceCandidates: boolean | null;\n    readonly connectionState: RTCPeerConnectionState;\n    readonly currentLocalDescription: RTCSessionDescription | null;\n    readonly currentRemoteDescription: RTCSessionDescription | null;\n    readonly iceConnectionState: RTCIceConnectionState;\n    readonly iceGatheringState: RTCIceGatheringState;\n    readonly idpErrorInfo: string | null;\n    readonly idpLoginUrl: string | null;\n    readonly localDescription: RTCSessionDescription | null;\n    onconnectionstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;\n    ondatachannel: ((this: RTCPeerConnection, ev: RTCDataChannelEvent) => any) | null;\n    onicecandidate: ((this: RTCPeerConnection, ev: RTCPeerConnectionIceEvent) => any) | null;\n    onicecandidateerror: ((this: RTCPeerConnection, ev: RTCPeerConnectionIceErrorEvent) => any) | null;\n    oniceconnectionstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;\n    onicegatheringstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;\n    onnegotiationneeded: ((this: RTCPeerConnection, ev: Event) => any) | null;\n    onsignalingstatechange: ((this: RTCPeerConnection, ev: Event) => any) | null;\n    onstatsended: ((this: RTCPeerConnection, ev: RTCStatsEvent) => any) | null;\n    ontrack: ((this: RTCPeerConnection, ev: RTCTrackEvent) => any) | null;\n    readonly peerIdentity: Promise<RTCIdentityAssertion>;\n    readonly pendingLocalDescription: RTCSessionDescription | null;\n    readonly pendingRemoteDescription: RTCSessionDescription | null;\n    readonly remoteDescription: RTCSessionDescription | null;\n    readonly sctp: RTCSctpTransport | null;\n    readonly signalingState: RTCSignalingState;\n    addIceCandidate(candidate: RTCIceCandidateInit | RTCIceCandidate): Promise<void>;\n    addTrack(track: MediaStreamTrack, ...streams: MediaStream[]): RTCRtpSender;\n    addTransceiver(trackOrKind: MediaStreamTrack | string, init?: RTCRtpTransceiverInit): RTCRtpTransceiver;\n    close(): void;\n    createAnswer(options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit>;\n    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit): RTCDataChannel;\n    createOffer(options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit>;\n    getConfiguration(): RTCConfiguration;\n    getIdentityAssertion(): Promise<string>;\n    getReceivers(): RTCRtpReceiver[];\n    getSenders(): RTCRtpSender[];\n    getStats(selector?: MediaStreamTrack | null): Promise<RTCStatsReport>;\n    getTransceivers(): RTCRtpTransceiver[];\n    removeTrack(sender: RTCRtpSender): void;\n    setConfiguration(configuration: RTCConfiguration): void;\n    setIdentityProvider(provider: string, options?: RTCIdentityProviderOptions): void;\n    setLocalDescription(description: RTCSessionDescriptionInit): Promise<void>;\n    setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void>;\n    addEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: RTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: RTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCPeerConnection: {\n    prototype: RTCPeerConnection;\n    new(configuration?: RTCConfiguration): RTCPeerConnection;\n    generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate>;\n    getDefaultIceServers(): RTCIceServer[];\n};\n\ninterface RTCPeerConnectionIceErrorEvent extends Event {\n    readonly errorCode: number;\n    readonly errorText: string;\n    readonly hostCandidate: string;\n    readonly url: string;\n}\n\ndeclare var RTCPeerConnectionIceErrorEvent: {\n    prototype: RTCPeerConnectionIceErrorEvent;\n    new(type: string, eventInitDict: RTCPeerConnectionIceErrorEventInit): RTCPeerConnectionIceErrorEvent;\n};\n\ninterface RTCPeerConnectionIceEvent extends Event {\n    readonly candidate: RTCIceCandidate | null;\n    readonly url: string | null;\n}\n\ndeclare var RTCPeerConnectionIceEvent: {\n    prototype: RTCPeerConnectionIceEvent;\n    new(type: string, eventInitDict?: RTCPeerConnectionIceEventInit): RTCPeerConnectionIceEvent;\n};\n\ninterface RTCRtpReceiver {\n    readonly rtcpTransport: RTCDtlsTransport | null;\n    readonly track: MediaStreamTrack;\n    readonly transport: RTCDtlsTransport | null;\n    getContributingSources(): RTCRtpContributingSource[];\n    getParameters(): RTCRtpReceiveParameters;\n    getStats(): Promise<RTCStatsReport>;\n    getSynchronizationSources(): RTCRtpSynchronizationSource[];\n}\n\ndeclare var RTCRtpReceiver: {\n    prototype: RTCRtpReceiver;\n    new(): RTCRtpReceiver;\n    getCapabilities(kind: string): RTCRtpCapabilities | null;\n};\n\ninterface RTCRtpSender {\n    readonly dtmf: RTCDTMFSender | null;\n    readonly rtcpTransport: RTCDtlsTransport | null;\n    readonly track: MediaStreamTrack | null;\n    readonly transport: RTCDtlsTransport | null;\n    getParameters(): RTCRtpSendParameters;\n    getStats(): Promise<RTCStatsReport>;\n    replaceTrack(withTrack: MediaStreamTrack | null): Promise<void>;\n    setParameters(parameters: RTCRtpSendParameters): Promise<void>;\n    setStreams(...streams: MediaStream[]): void;\n}\n\ndeclare var RTCRtpSender: {\n    prototype: RTCRtpSender;\n    new(): RTCRtpSender;\n    getCapabilities(kind: string): RTCRtpCapabilities | null;\n};\n\ninterface RTCRtpTransceiver {\n    readonly currentDirection: RTCRtpTransceiverDirection | null;\n    direction: RTCRtpTransceiverDirection;\n    readonly mid: string | null;\n    readonly receiver: RTCRtpReceiver;\n    readonly sender: RTCRtpSender;\n    readonly stopped: boolean;\n    setCodecPreferences(codecs: RTCRtpCodecCapability[]): void;\n    stop(): void;\n}\n\ndeclare var RTCRtpTransceiver: {\n    prototype: RTCRtpTransceiver;\n    new(): RTCRtpTransceiver;\n};\n\ninterface RTCSctpTransportEventMap {\n    "statechange": Event;\n}\n\ninterface RTCSctpTransport {\n    readonly maxChannels: number | null;\n    readonly maxMessageSize: number;\n    onstatechange: ((this: RTCSctpTransport, ev: Event) => any) | null;\n    readonly state: RTCSctpTransportState;\n    readonly transport: RTCDtlsTransport;\n    addEventListener<K extends keyof RTCSctpTransportEventMap>(type: K, listener: (this: RTCSctpTransport, ev: RTCSctpTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCSctpTransportEventMap>(type: K, listener: (this: RTCSctpTransport, ev: RTCSctpTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCSctpTransport: {\n    prototype: RTCSctpTransport;\n    new(): RTCSctpTransport;\n};\n\ninterface RTCSessionDescription {\n    readonly sdp: string;\n    readonly type: RTCSdpType;\n    toJSON(): any;\n}\n\ndeclare var RTCSessionDescription: {\n    prototype: RTCSessionDescription;\n    new(descriptionInitDict: RTCSessionDescriptionInit): RTCSessionDescription;\n};\n\ninterface RTCSrtpSdesTransportEventMap {\n    "error": Event;\n}\n\ninterface RTCSrtpSdesTransport extends EventTarget {\n    onerror: ((this: RTCSrtpSdesTransport, ev: Event) => any) | null;\n    readonly transport: RTCIceTransport;\n    addEventListener<K extends keyof RTCSrtpSdesTransportEventMap>(type: K, listener: (this: RTCSrtpSdesTransport, ev: RTCSrtpSdesTransportEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCSrtpSdesTransportEventMap>(type: K, listener: (this: RTCSrtpSdesTransport, ev: RTCSrtpSdesTransportEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var RTCSrtpSdesTransport: {\n    prototype: RTCSrtpSdesTransport;\n    new(transport: RTCIceTransport, encryptParameters: RTCSrtpSdesParameters, decryptParameters: RTCSrtpSdesParameters): RTCSrtpSdesTransport;\n    getLocalParameters(): RTCSrtpSdesParameters[];\n};\n\ninterface RTCSsrcConflictEvent extends Event {\n    readonly ssrc: number;\n}\n\ndeclare var RTCSsrcConflictEvent: {\n    prototype: RTCSsrcConflictEvent;\n    new(): RTCSsrcConflictEvent;\n};\n\ninterface RTCStatsEvent extends Event {\n    readonly report: RTCStatsReport;\n}\n\ndeclare var RTCStatsEvent: {\n    prototype: RTCStatsEvent;\n    new(type: string, eventInitDict: RTCStatsEventInit): RTCStatsEvent;\n};\n\ninterface RTCStatsProvider extends EventTarget {\n    getStats(): Promise<RTCStatsReport>;\n    msGetStats(): Promise<RTCStatsReport>;\n}\n\ndeclare var RTCStatsProvider: {\n    prototype: RTCStatsProvider;\n    new(): RTCStatsProvider;\n};\n\ninterface RTCStatsReport {\n    forEach(callbackfn: (value: any, key: string, parent: RTCStatsReport) => void, thisArg?: any): void;\n}\n\ndeclare var RTCStatsReport: {\n    prototype: RTCStatsReport;\n    new(): RTCStatsReport;\n};\n\ninterface RTCTrackEvent extends Event {\n    readonly receiver: RTCRtpReceiver;\n    readonly streams: ReadonlyArray<MediaStream>;\n    readonly track: MediaStreamTrack;\n    readonly transceiver: RTCRtpTransceiver;\n}\n\ndeclare var RTCTrackEvent: {\n    prototype: RTCTrackEvent;\n    new(type: string, eventInitDict: RTCTrackEventInit): RTCTrackEvent;\n};\n\ninterface RadioNodeList extends NodeList {\n    value: string;\n}\n\ndeclare var RadioNodeList: {\n    prototype: RadioNodeList;\n    new(): RadioNodeList;\n};\n\ninterface RandomSource {\n    getRandomValues<T extends Int8Array | Uint8ClampedArray | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array>(array: T): T;\n}\n\ndeclare var RandomSource: {\n    prototype: RandomSource;\n    new(): RandomSource;\n};\n\ninterface Range extends AbstractRange {\n    /**\n     * Returns the node, furthest away from\n     * the document, that is an ancestor of both range\'s start node and end node.\n     */\n    readonly commonAncestorContainer: Node;\n    cloneContents(): DocumentFragment;\n    cloneRange(): Range;\n    collapse(toStart?: boolean): void;\n    compareBoundaryPoints(how: number, sourceRange: Range): number;\n    /**\n     * Returns \u22121 if the point is before the range, 0 if the point is\n     * in the range, and 1 if the point is after the range.\n     */\n    comparePoint(node: Node, offset: number): number;\n    createContextualFragment(fragment: string): DocumentFragment;\n    deleteContents(): void;\n    detach(): void;\n    extractContents(): DocumentFragment;\n    getBoundingClientRect(): ClientRect | DOMRect;\n    getClientRects(): ClientRectList | DOMRectList;\n    insertNode(node: Node): void;\n    /**\n     * Returns whether range intersects node.\n     */\n    intersectsNode(node: Node): boolean;\n    isPointInRange(node: Node, offset: number): boolean;\n    selectNode(node: Node): void;\n    selectNodeContents(node: Node): void;\n    setEnd(node: Node, offset: number): void;\n    setEndAfter(node: Node): void;\n    setEndBefore(node: Node): void;\n    setStart(node: Node, offset: number): void;\n    setStartAfter(node: Node): void;\n    setStartBefore(node: Node): void;\n    surroundContents(newParent: Node): void;\n    readonly END_TO_END: number;\n    readonly END_TO_START: number;\n    readonly START_TO_END: number;\n    readonly START_TO_START: number;\n}\n\ndeclare var Range: {\n    prototype: Range;\n    new(): Range;\n    readonly END_TO_END: number;\n    readonly END_TO_START: number;\n    readonly START_TO_END: number;\n    readonly START_TO_START: number;\n};\n\ninterface ReadableByteStreamController {\n    readonly byobRequest: ReadableStreamBYOBRequest | undefined;\n    readonly desiredSize: number | null;\n    close(): void;\n    enqueue(chunk: ArrayBufferView): void;\n    error(error?: any): void;\n}\n\ninterface ReadableStream<R = any> {\n    readonly locked: boolean;\n    cancel(reason?: any): Promise<void>;\n    getReader(options: { mode: "byob" }): ReadableStreamBYOBReader;\n    getReader(): ReadableStreamDefaultReader<R>;\n    pipeThrough<T>({ writable, readable }: { writable: WritableStream<R>, readable: ReadableStream<T> }, options?: PipeOptions): ReadableStream<T>;\n    pipeTo(dest: WritableStream<R>, options?: PipeOptions): Promise<void>;\n    tee(): [ReadableStream<R>, ReadableStream<R>];\n}\n\ndeclare var ReadableStream: {\n    prototype: ReadableStream;\n    new(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number, size?: undefined }): ReadableStream<Uint8Array>;\n    new<R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;\n};\n\ninterface ReadableStreamBYOBReader {\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n    read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>;\n    releaseLock(): void;\n}\n\ndeclare var ReadableStreamBYOBReader: {\n    prototype: ReadableStreamBYOBReader;\n    new(stream: ReadableStream<Uint8Array>): ReadableStreamBYOBReader;\n};\n\ninterface ReadableStreamBYOBRequest {\n    readonly view: ArrayBufferView;\n    respond(bytesWritten: number): void;\n    respondWithNewView(view: ArrayBufferView): void;\n}\n\ninterface ReadableStreamDefaultController<R = any> {\n    readonly desiredSize: number | null;\n    close(): void;\n    enqueue(chunk: R): void;\n    error(error?: any): void;\n}\n\ninterface ReadableStreamDefaultReader<R = any> {\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n    read(): Promise<ReadableStreamReadResult<R>>;\n    releaseLock(): void;\n}\n\ninterface ReadableStreamReadResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface ReadableStreamReader<R = any> {\n    cancel(): Promise<void>;\n    read(): Promise<ReadableStreamReadResult<R>>;\n    releaseLock(): void;\n}\n\ndeclare var ReadableStreamReader: {\n    prototype: ReadableStreamReader;\n    new(): ReadableStreamReader;\n};\n\ninterface Request extends Body {\n    /**\n     * Returns the cache mode associated with request, which is a string indicating\n     * how the request will interact with the browser\'s cache when fetching.\n     */\n    readonly cache: RequestCache;\n    /**\n     * Returns the credentials mode associated with request, which is a string\n     * indicating whether credentials will be sent with the request always, never, or only when sent to a\n     * same-origin URL.\n     */\n    readonly credentials: RequestCredentials;\n    /**\n     * Returns the kind of resource requested by request, e.g., "document" or\n     * "script".\n     */\n    readonly destination: RequestDestination;\n    /**\n     * Returns a Headers object consisting of the headers associated with request.\n     * Note that headers added in the network layer by the user agent will not be accounted for in this\n     * object, e.g., the "Host" header.\n     */\n    readonly headers: Headers;\n    /**\n     * Returns request\'s subresource integrity metadata, which is a cryptographic hash of\n     * the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]\n     */\n    readonly integrity: string;\n    /**\n     * Returns a boolean indicating whether or not request is for a history\n     * navigation (a.k.a. back-foward navigation).\n     */\n    readonly isHistoryNavigation: boolean;\n    /**\n     * Returns a boolean indicating whether or not request is for a reload navigation.\n     */\n    readonly isReloadNavigation: boolean;\n    /**\n     * Returns a boolean indicating whether or not request can outlive the global in which\n     * it was created.\n     */\n    readonly keepalive: boolean;\n    /**\n     * Returns request\'s HTTP method, which is "GET" by default.\n     */\n    readonly method: string;\n    /**\n     * Returns the mode associated with request, which is a string indicating\n     * whether the request will use CORS, or will be restricted to same-origin URLs.\n     */\n    readonly mode: RequestMode;\n    /**\n     * Returns the redirect mode associated with request, which is a string\n     * indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.\n     */\n    readonly redirect: RequestRedirect;\n    /**\n     * Returns the referrer of request. Its value can be a same-origin URL if\n     * explicitly set in init, the empty string to indicate no referrer, and\n     * "about:client" when defaulting to the global\'s default. This is used during\n     * fetching to determine the value of the `Referer` header of the request being made.\n     */\n    readonly referrer: string;\n    /**\n     * Returns the referrer policy associated with request. This is used during\n     * fetching to compute the value of the request\'s referrer.\n     */\n    readonly referrerPolicy: ReferrerPolicy;\n    /**\n     * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort\n     * event handler.\n     */\n    readonly signal: AbortSignal;\n    /**\n     * Returns the URL of request as a string.\n     */\n    readonly url: string;\n    clone(): Request;\n}\n\ndeclare var Request: {\n    prototype: Request;\n    new(input: RequestInfo, init?: RequestInit): Request;\n};\n\ninterface Response extends Body {\n    readonly headers: Headers;\n    readonly ok: boolean;\n    readonly redirected: boolean;\n    readonly status: number;\n    readonly statusText: string;\n    readonly trailer: Promise<Headers>;\n    readonly type: ResponseType;\n    readonly url: string;\n    clone(): Response;\n}\n\ndeclare var Response: {\n    prototype: Response;\n    new(body?: BodyInit | null, init?: ResponseInit): Response;\n    error(): Response;\n    redirect(url: string, status?: number): Response;\n};\n\ninterface SVGAElement extends SVGGraphicsElement, SVGURIReference {\n    readonly target: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGAElement: {\n    prototype: SVGAElement;\n    new(): SVGAElement;\n};\n\ninterface SVGAngle {\n    readonly unitType: number;\n    value: number;\n    valueAsString: string;\n    valueInSpecifiedUnits: number;\n    convertToSpecifiedUnits(unitType: number): void;\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\n    readonly SVG_ANGLETYPE_DEG: number;\n    readonly SVG_ANGLETYPE_GRAD: number;\n    readonly SVG_ANGLETYPE_RAD: number;\n    readonly SVG_ANGLETYPE_UNKNOWN: number;\n    readonly SVG_ANGLETYPE_UNSPECIFIED: number;\n}\n\ndeclare var SVGAngle: {\n    prototype: SVGAngle;\n    new(): SVGAngle;\n    readonly SVG_ANGLETYPE_DEG: number;\n    readonly SVG_ANGLETYPE_GRAD: number;\n    readonly SVG_ANGLETYPE_RAD: number;\n    readonly SVG_ANGLETYPE_UNKNOWN: number;\n    readonly SVG_ANGLETYPE_UNSPECIFIED: number;\n};\n\ninterface SVGAnimateElement extends SVGAnimationElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGAnimateElement: {\n    prototype: SVGAnimateElement;\n    new(): SVGAnimateElement;\n};\n\ninterface SVGAnimateMotionElement extends SVGAnimationElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateMotionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateMotionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGAnimateMotionElement: {\n    prototype: SVGAnimateMotionElement;\n    new(): SVGAnimateMotionElement;\n};\n\ninterface SVGAnimateTransformElement extends SVGAnimationElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateTransformElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimateTransformElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGAnimateTransformElement: {\n    prototype: SVGAnimateTransformElement;\n    new(): SVGAnimateTransformElement;\n};\n\ninterface SVGAnimatedAngle {\n    readonly animVal: SVGAngle;\n    readonly baseVal: SVGAngle;\n}\n\ndeclare var SVGAnimatedAngle: {\n    prototype: SVGAnimatedAngle;\n    new(): SVGAnimatedAngle;\n};\n\ninterface SVGAnimatedBoolean {\n    readonly animVal: boolean;\n    baseVal: boolean;\n}\n\ndeclare var SVGAnimatedBoolean: {\n    prototype: SVGAnimatedBoolean;\n    new(): SVGAnimatedBoolean;\n};\n\ninterface SVGAnimatedEnumeration {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedEnumeration: {\n    prototype: SVGAnimatedEnumeration;\n    new(): SVGAnimatedEnumeration;\n};\n\ninterface SVGAnimatedInteger {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedInteger: {\n    prototype: SVGAnimatedInteger;\n    new(): SVGAnimatedInteger;\n};\n\ninterface SVGAnimatedLength {\n    readonly animVal: SVGLength;\n    readonly baseVal: SVGLength;\n}\n\ndeclare var SVGAnimatedLength: {\n    prototype: SVGAnimatedLength;\n    new(): SVGAnimatedLength;\n};\n\ninterface SVGAnimatedLengthList {\n    readonly animVal: SVGLengthList;\n    readonly baseVal: SVGLengthList;\n}\n\ndeclare var SVGAnimatedLengthList: {\n    prototype: SVGAnimatedLengthList;\n    new(): SVGAnimatedLengthList;\n};\n\ninterface SVGAnimatedNumber {\n    readonly animVal: number;\n    baseVal: number;\n}\n\ndeclare var SVGAnimatedNumber: {\n    prototype: SVGAnimatedNumber;\n    new(): SVGAnimatedNumber;\n};\n\ninterface SVGAnimatedNumberList {\n    readonly animVal: SVGNumberList;\n    readonly baseVal: SVGNumberList;\n}\n\ndeclare var SVGAnimatedNumberList: {\n    prototype: SVGAnimatedNumberList;\n    new(): SVGAnimatedNumberList;\n};\n\ninterface SVGAnimatedPoints {\n    readonly animatedPoints: SVGPointList;\n    readonly points: SVGPointList;\n}\n\ninterface SVGAnimatedPreserveAspectRatio {\n    readonly animVal: SVGPreserveAspectRatio;\n    readonly baseVal: SVGPreserveAspectRatio;\n}\n\ndeclare var SVGAnimatedPreserveAspectRatio: {\n    prototype: SVGAnimatedPreserveAspectRatio;\n    new(): SVGAnimatedPreserveAspectRatio;\n};\n\ninterface SVGAnimatedRect {\n    readonly animVal: DOMRectReadOnly;\n    readonly baseVal: DOMRect;\n}\n\ndeclare var SVGAnimatedRect: {\n    prototype: SVGAnimatedRect;\n    new(): SVGAnimatedRect;\n};\n\ninterface SVGAnimatedString {\n    readonly animVal: string;\n    baseVal: string;\n}\n\ndeclare var SVGAnimatedString: {\n    prototype: SVGAnimatedString;\n    new(): SVGAnimatedString;\n};\n\ninterface SVGAnimatedTransformList {\n    readonly animVal: SVGTransformList;\n    readonly baseVal: SVGTransformList;\n}\n\ndeclare var SVGAnimatedTransformList: {\n    prototype: SVGAnimatedTransformList;\n    new(): SVGAnimatedTransformList;\n};\n\ninterface SVGAnimationElement extends SVGElement {\n    readonly targetElement: SVGElement;\n    getCurrentTime(): number;\n    getSimpleDuration(): number;\n    getStartTime(): number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimationElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGAnimationElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGAnimationElement: {\n    prototype: SVGAnimationElement;\n    new(): SVGAnimationElement;\n};\n\ninterface SVGCircleElement extends SVGGraphicsElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly r: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCircleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCircleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGCircleElement: {\n    prototype: SVGCircleElement;\n    new(): SVGCircleElement;\n};\n\ninterface SVGClipPathElement extends SVGGraphicsElement {\n    readonly clipPathUnits: SVGAnimatedEnumeration;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGClipPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGClipPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGClipPathElement: {\n    prototype: SVGClipPathElement;\n    new(): SVGClipPathElement;\n};\n\ninterface SVGComponentTransferFunctionElement extends SVGElement {\n    readonly amplitude: SVGAnimatedNumber;\n    readonly exponent: SVGAnimatedNumber;\n    readonly intercept: SVGAnimatedNumber;\n    readonly offset: SVGAnimatedNumber;\n    readonly slope: SVGAnimatedNumber;\n    readonly tableValues: SVGAnimatedNumberList;\n    readonly type: SVGAnimatedEnumeration;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGComponentTransferFunctionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGComponentTransferFunctionElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGComponentTransferFunctionElement: {\n    prototype: SVGComponentTransferFunctionElement;\n    new(): SVGComponentTransferFunctionElement;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE: number;\n    readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: number;\n};\n\ninterface SVGCursorElement extends SVGElement {\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCursorElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGCursorElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGCursorElement: {\n    prototype: SVGCursorElement;\n    new(): SVGCursorElement;\n};\n\ninterface SVGDefsElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDefsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDefsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGDefsElement: {\n    prototype: SVGDefsElement;\n    new(): SVGDefsElement;\n};\n\ninterface SVGDescElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDescElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGDescElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGDescElement: {\n    prototype: SVGDescElement;\n    new(): SVGDescElement;\n};\n\ninterface SVGElementEventMap extends ElementEventMap, GlobalEventHandlersEventMap, DocumentAndElementEventHandlersEventMap {\n}\n\ninterface SVGElement extends Element, GlobalEventHandlers, DocumentAndElementEventHandlers, SVGElementInstance, HTMLOrSVGElement, ElementCSSInlineStyle {\n    /** @deprecated */\n    readonly className: any;\n    readonly ownerSVGElement: SVGSVGElement | null;\n    readonly viewportElement: SVGElement | null;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGElement: {\n    prototype: SVGElement;\n    new(): SVGElement;\n};\n\ninterface SVGElementInstance extends EventTarget {\n    readonly correspondingElement: SVGElement;\n    readonly correspondingUseElement: SVGUseElement;\n}\n\ndeclare var SVGElementInstance: {\n    prototype: SVGElementInstance;\n    new(): SVGElementInstance;\n};\n\ninterface SVGElementInstanceList {\n    /** @deprecated */\n    readonly length: number;\n    /** @deprecated */\n    item(index: number): SVGElementInstance;\n}\n\ndeclare var SVGElementInstanceList: {\n    prototype: SVGElementInstanceList;\n    new(): SVGElementInstanceList;\n};\n\ninterface SVGEllipseElement extends SVGGraphicsElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly rx: SVGAnimatedLength;\n    readonly ry: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGEllipseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGEllipseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGEllipseElement: {\n    prototype: SVGEllipseElement;\n    new(): SVGEllipseElement;\n};\n\ninterface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly mode: SVGAnimatedEnumeration;\n    readonly SVG_FEBLEND_MODE_COLOR: number;\n    readonly SVG_FEBLEND_MODE_COLOR_BURN: number;\n    readonly SVG_FEBLEND_MODE_COLOR_DODGE: number;\n    readonly SVG_FEBLEND_MODE_DARKEN: number;\n    readonly SVG_FEBLEND_MODE_DIFFERENCE: number;\n    readonly SVG_FEBLEND_MODE_EXCLUSION: number;\n    readonly SVG_FEBLEND_MODE_HARD_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_HUE: number;\n    readonly SVG_FEBLEND_MODE_LIGHTEN: number;\n    readonly SVG_FEBLEND_MODE_LUMINOSITY: number;\n    readonly SVG_FEBLEND_MODE_MULTIPLY: number;\n    readonly SVG_FEBLEND_MODE_NORMAL: number;\n    readonly SVG_FEBLEND_MODE_OVERLAY: number;\n    readonly SVG_FEBLEND_MODE_SATURATION: number;\n    readonly SVG_FEBLEND_MODE_SCREEN: number;\n    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEBlendElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEBlendElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEBlendElement: {\n    prototype: SVGFEBlendElement;\n    new(): SVGFEBlendElement;\n    readonly SVG_FEBLEND_MODE_COLOR: number;\n    readonly SVG_FEBLEND_MODE_COLOR_BURN: number;\n    readonly SVG_FEBLEND_MODE_COLOR_DODGE: number;\n    readonly SVG_FEBLEND_MODE_DARKEN: number;\n    readonly SVG_FEBLEND_MODE_DIFFERENCE: number;\n    readonly SVG_FEBLEND_MODE_EXCLUSION: number;\n    readonly SVG_FEBLEND_MODE_HARD_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_HUE: number;\n    readonly SVG_FEBLEND_MODE_LIGHTEN: number;\n    readonly SVG_FEBLEND_MODE_LUMINOSITY: number;\n    readonly SVG_FEBLEND_MODE_MULTIPLY: number;\n    readonly SVG_FEBLEND_MODE_NORMAL: number;\n    readonly SVG_FEBLEND_MODE_OVERLAY: number;\n    readonly SVG_FEBLEND_MODE_SATURATION: number;\n    readonly SVG_FEBLEND_MODE_SCREEN: number;\n    readonly SVG_FEBLEND_MODE_SOFT_LIGHT: number;\n    readonly SVG_FEBLEND_MODE_UNKNOWN: number;\n};\n\ninterface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly type: SVGAnimatedEnumeration;\n    readonly values: SVGAnimatedNumberList;\n    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\n    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: number;\n    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEColorMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEColorMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEColorMatrixElement: {\n    prototype: SVGFEColorMatrixElement;\n    new(): SVGFEColorMatrixElement;\n    readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: number;\n    readonly SVG_FECOLORMATRIX_TYPE_MATRIX: number;\n    readonly SVG_FECOLORMATRIX_TYPE_SATURATE: number;\n    readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN: number;\n};\n\ninterface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEComponentTransferElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEComponentTransferElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEComponentTransferElement: {\n    prototype: SVGFEComponentTransferElement;\n    new(): SVGFEComponentTransferElement;\n};\n\ninterface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly k1: SVGAnimatedNumber;\n    readonly k2: SVGAnimatedNumber;\n    readonly k3: SVGAnimatedNumber;\n    readonly k4: SVGAnimatedNumber;\n    readonly operator: SVGAnimatedEnumeration;\n    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_IN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OUT: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OVER: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_XOR: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFECompositeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFECompositeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFECompositeElement: {\n    prototype: SVGFECompositeElement;\n    new(): SVGFECompositeElement;\n    readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_ATOP: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_IN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OUT: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_OVER: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN: number;\n    readonly SVG_FECOMPOSITE_OPERATOR_XOR: number;\n};\n\ninterface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly bias: SVGAnimatedNumber;\n    readonly divisor: SVGAnimatedNumber;\n    readonly edgeMode: SVGAnimatedEnumeration;\n    readonly in1: SVGAnimatedString;\n    readonly kernelMatrix: SVGAnimatedNumberList;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly orderX: SVGAnimatedInteger;\n    readonly orderY: SVGAnimatedInteger;\n    readonly preserveAlpha: SVGAnimatedBoolean;\n    readonly targetX: SVGAnimatedInteger;\n    readonly targetY: SVGAnimatedInteger;\n    readonly SVG_EDGEMODE_DUPLICATE: number;\n    readonly SVG_EDGEMODE_NONE: number;\n    readonly SVG_EDGEMODE_UNKNOWN: number;\n    readonly SVG_EDGEMODE_WRAP: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEConvolveMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEConvolveMatrixElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEConvolveMatrixElement: {\n    prototype: SVGFEConvolveMatrixElement;\n    new(): SVGFEConvolveMatrixElement;\n    readonly SVG_EDGEMODE_DUPLICATE: number;\n    readonly SVG_EDGEMODE_NONE: number;\n    readonly SVG_EDGEMODE_UNKNOWN: number;\n    readonly SVG_EDGEMODE_WRAP: number;\n};\n\ninterface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly diffuseConstant: SVGAnimatedNumber;\n    readonly in1: SVGAnimatedString;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly surfaceScale: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDiffuseLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDiffuseLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEDiffuseLightingElement: {\n    prototype: SVGFEDiffuseLightingElement;\n    new(): SVGFEDiffuseLightingElement;\n};\n\ninterface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly in2: SVGAnimatedString;\n    readonly scale: SVGAnimatedNumber;\n    readonly xChannelSelector: SVGAnimatedEnumeration;\n    readonly yChannelSelector: SVGAnimatedEnumeration;\n    readonly SVG_CHANNEL_A: number;\n    readonly SVG_CHANNEL_B: number;\n    readonly SVG_CHANNEL_G: number;\n    readonly SVG_CHANNEL_R: number;\n    readonly SVG_CHANNEL_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDisplacementMapElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDisplacementMapElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEDisplacementMapElement: {\n    prototype: SVGFEDisplacementMapElement;\n    new(): SVGFEDisplacementMapElement;\n    readonly SVG_CHANNEL_A: number;\n    readonly SVG_CHANNEL_B: number;\n    readonly SVG_CHANNEL_G: number;\n    readonly SVG_CHANNEL_R: number;\n    readonly SVG_CHANNEL_UNKNOWN: number;\n};\n\ninterface SVGFEDistantLightElement extends SVGElement {\n    readonly azimuth: SVGAnimatedNumber;\n    readonly elevation: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDistantLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEDistantLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEDistantLightElement: {\n    prototype: SVGFEDistantLightElement;\n    new(): SVGFEDistantLightElement;\n};\n\ninterface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFloodElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFloodElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEFloodElement: {\n    prototype: SVGFEFloodElement;\n    new(): SVGFEFloodElement;\n};\n\ninterface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncAElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEFuncAElement: {\n    prototype: SVGFEFuncAElement;\n    new(): SVGFEFuncAElement;\n};\n\ninterface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncBElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncBElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEFuncBElement: {\n    prototype: SVGFEFuncBElement;\n    new(): SVGFEFuncBElement;\n};\n\ninterface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEFuncGElement: {\n    prototype: SVGFEFuncGElement;\n    new(): SVGFEFuncGElement;\n};\n\ninterface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncRElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEFuncRElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEFuncRElement: {\n    prototype: SVGFEFuncRElement;\n    new(): SVGFEFuncRElement;\n};\n\ninterface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly stdDeviationX: SVGAnimatedNumber;\n    readonly stdDeviationY: SVGAnimatedNumber;\n    setStdDeviation(stdDeviationX: number, stdDeviationY: number): void;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEGaussianBlurElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEGaussianBlurElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEGaussianBlurElement: {\n    prototype: SVGFEGaussianBlurElement;\n    new(): SVGFEGaussianBlurElement;\n};\n\ninterface SVGFEImageElement extends SVGElement, SVGFilterPrimitiveStandardAttributes, SVGURIReference {\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEImageElement: {\n    prototype: SVGFEImageElement;\n    new(): SVGFEImageElement;\n};\n\ninterface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEMergeElement: {\n    prototype: SVGFEMergeElement;\n    new(): SVGFEMergeElement;\n};\n\ninterface SVGFEMergeNodeElement extends SVGElement {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeNodeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMergeNodeElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEMergeNodeElement: {\n    prototype: SVGFEMergeNodeElement;\n    new(): SVGFEMergeNodeElement;\n};\n\ninterface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly operator: SVGAnimatedEnumeration;\n    readonly radiusX: SVGAnimatedNumber;\n    readonly radiusY: SVGAnimatedNumber;\n    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMorphologyElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEMorphologyElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEMorphologyElement: {\n    prototype: SVGFEMorphologyElement;\n    new(): SVGFEMorphologyElement;\n    readonly SVG_MORPHOLOGY_OPERATOR_DILATE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_ERODE: number;\n    readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN: number;\n};\n\ninterface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly dx: SVGAnimatedNumber;\n    readonly dy: SVGAnimatedNumber;\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEOffsetElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEOffsetElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEOffsetElement: {\n    prototype: SVGFEOffsetElement;\n    new(): SVGFEOffsetElement;\n};\n\ninterface SVGFEPointLightElement extends SVGElement {\n    readonly x: SVGAnimatedNumber;\n    readonly y: SVGAnimatedNumber;\n    readonly z: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEPointLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFEPointLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFEPointLightElement: {\n    prototype: SVGFEPointLightElement;\n    new(): SVGFEPointLightElement;\n};\n\ninterface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    readonly kernelUnitLengthX: SVGAnimatedNumber;\n    readonly kernelUnitLengthY: SVGAnimatedNumber;\n    readonly specularConstant: SVGAnimatedNumber;\n    readonly specularExponent: SVGAnimatedNumber;\n    readonly surfaceScale: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpecularLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpecularLightingElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFESpecularLightingElement: {\n    prototype: SVGFESpecularLightingElement;\n    new(): SVGFESpecularLightingElement;\n};\n\ninterface SVGFESpotLightElement extends SVGElement {\n    readonly limitingConeAngle: SVGAnimatedNumber;\n    readonly pointsAtX: SVGAnimatedNumber;\n    readonly pointsAtY: SVGAnimatedNumber;\n    readonly pointsAtZ: SVGAnimatedNumber;\n    readonly specularExponent: SVGAnimatedNumber;\n    readonly x: SVGAnimatedNumber;\n    readonly y: SVGAnimatedNumber;\n    readonly z: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpotLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFESpotLightElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFESpotLightElement: {\n    prototype: SVGFESpotLightElement;\n    new(): SVGFESpotLightElement;\n};\n\ninterface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly in1: SVGAnimatedString;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETileElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETileElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFETileElement: {\n    prototype: SVGFETileElement;\n    new(): SVGFETileElement;\n};\n\ninterface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {\n    readonly baseFrequencyX: SVGAnimatedNumber;\n    readonly baseFrequencyY: SVGAnimatedNumber;\n    readonly numOctaves: SVGAnimatedInteger;\n    readonly seed: SVGAnimatedNumber;\n    readonly stitchTiles: SVGAnimatedEnumeration;\n    readonly type: SVGAnimatedEnumeration;\n    readonly SVG_STITCHTYPE_NOSTITCH: number;\n    readonly SVG_STITCHTYPE_STITCH: number;\n    readonly SVG_STITCHTYPE_UNKNOWN: number;\n    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\n    readonly SVG_TURBULENCE_TYPE_TURBULENCE: number;\n    readonly SVG_TURBULENCE_TYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETurbulenceElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFETurbulenceElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFETurbulenceElement: {\n    prototype: SVGFETurbulenceElement;\n    new(): SVGFETurbulenceElement;\n    readonly SVG_STITCHTYPE_NOSTITCH: number;\n    readonly SVG_STITCHTYPE_STITCH: number;\n    readonly SVG_STITCHTYPE_UNKNOWN: number;\n    readonly SVG_TURBULENCE_TYPE_FRACTALNOISE: number;\n    readonly SVG_TURBULENCE_TYPE_TURBULENCE: number;\n    readonly SVG_TURBULENCE_TYPE_UNKNOWN: number;\n};\n\ninterface SVGFilterElement extends SVGElement, SVGURIReference {\n    /** @deprecated */\n    readonly filterResX: SVGAnimatedInteger;\n    /** @deprecated */\n    readonly filterResY: SVGAnimatedInteger;\n    readonly filterUnits: SVGAnimatedEnumeration;\n    readonly height: SVGAnimatedLength;\n    readonly primitiveUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    /** @deprecated */\n    setFilterRes(filterResX: number, filterResY: number): void;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFilterElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGFilterElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGFilterElement: {\n    prototype: SVGFilterElement;\n    new(): SVGFilterElement;\n};\n\ninterface SVGFilterPrimitiveStandardAttributes {\n    readonly height: SVGAnimatedLength;\n    readonly result: SVGAnimatedString;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n}\n\ninterface SVGFitToViewBox {\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    readonly viewBox: SVGAnimatedRect;\n}\n\ninterface SVGForeignObjectElement extends SVGGraphicsElement {\n    readonly height: SVGAnimatedLength;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGForeignObjectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGForeignObjectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGForeignObjectElement: {\n    prototype: SVGForeignObjectElement;\n    new(): SVGForeignObjectElement;\n};\n\ninterface SVGGElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGGElement: {\n    prototype: SVGGElement;\n    new(): SVGGElement;\n};\n\ninterface SVGGeometryElement extends SVGGraphicsElement {\n    readonly pathLength: SVGAnimatedNumber;\n    getPointAtLength(distance: number): DOMPoint;\n    getTotalLength(): number;\n    isPointInFill(point?: DOMPointInit): boolean;\n    isPointInStroke(point?: DOMPointInit): boolean;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGeometryElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGeometryElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGGeometryElement: {\n    prototype: SVGGeometryElement;\n    new(): SVGGeometryElement;\n};\n\ninterface SVGGradientElement extends SVGElement, SVGURIReference {\n    readonly gradientTransform: SVGAnimatedTransformList;\n    readonly gradientUnits: SVGAnimatedEnumeration;\n    readonly spreadMethod: SVGAnimatedEnumeration;\n    readonly SVG_SPREADMETHOD_PAD: number;\n    readonly SVG_SPREADMETHOD_REFLECT: number;\n    readonly SVG_SPREADMETHOD_REPEAT: number;\n    readonly SVG_SPREADMETHOD_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGGradientElement: {\n    prototype: SVGGradientElement;\n    new(): SVGGradientElement;\n    readonly SVG_SPREADMETHOD_PAD: number;\n    readonly SVG_SPREADMETHOD_REFLECT: number;\n    readonly SVG_SPREADMETHOD_REPEAT: number;\n    readonly SVG_SPREADMETHOD_UNKNOWN: number;\n};\n\ninterface SVGGraphicsElement extends SVGElement, SVGTests {\n    readonly transform: SVGAnimatedTransformList;\n    getBBox(options?: SVGBoundingBoxOptions): DOMRect;\n    getCTM(): DOMMatrix | null;\n    getScreenCTM(): DOMMatrix | null;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGraphicsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGGraphicsElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGGraphicsElement: {\n    prototype: SVGGraphicsElement;\n    new(): SVGGraphicsElement;\n};\n\ninterface SVGImageElement extends SVGGraphicsElement, SVGURIReference {\n    readonly height: SVGAnimatedLength;\n    readonly preserveAspectRatio: SVGAnimatedPreserveAspectRatio;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGImageElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGImageElement: {\n    prototype: SVGImageElement;\n    new(): SVGImageElement;\n};\n\ninterface SVGLength {\n    readonly unitType: number;\n    value: number;\n    valueAsString: string;\n    valueInSpecifiedUnits: number;\n    convertToSpecifiedUnits(unitType: number): void;\n    newValueSpecifiedUnits(unitType: number, valueInSpecifiedUnits: number): void;\n    readonly SVG_LENGTHTYPE_CM: number;\n    readonly SVG_LENGTHTYPE_EMS: number;\n    readonly SVG_LENGTHTYPE_EXS: number;\n    readonly SVG_LENGTHTYPE_IN: number;\n    readonly SVG_LENGTHTYPE_MM: number;\n    readonly SVG_LENGTHTYPE_NUMBER: number;\n    readonly SVG_LENGTHTYPE_PC: number;\n    readonly SVG_LENGTHTYPE_PERCENTAGE: number;\n    readonly SVG_LENGTHTYPE_PT: number;\n    readonly SVG_LENGTHTYPE_PX: number;\n    readonly SVG_LENGTHTYPE_UNKNOWN: number;\n}\n\ndeclare var SVGLength: {\n    prototype: SVGLength;\n    new(): SVGLength;\n    readonly SVG_LENGTHTYPE_CM: number;\n    readonly SVG_LENGTHTYPE_EMS: number;\n    readonly SVG_LENGTHTYPE_EXS: number;\n    readonly SVG_LENGTHTYPE_IN: number;\n    readonly SVG_LENGTHTYPE_MM: number;\n    readonly SVG_LENGTHTYPE_NUMBER: number;\n    readonly SVG_LENGTHTYPE_PC: number;\n    readonly SVG_LENGTHTYPE_PERCENTAGE: number;\n    readonly SVG_LENGTHTYPE_PT: number;\n    readonly SVG_LENGTHTYPE_PX: number;\n    readonly SVG_LENGTHTYPE_UNKNOWN: number;\n};\n\ninterface SVGLengthList {\n    readonly length: number;\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGLength): SVGLength;\n    clear(): void;\n    getItem(index: number): SVGLength;\n    initialize(newItem: SVGLength): SVGLength;\n    insertItemBefore(newItem: SVGLength, index: number): SVGLength;\n    removeItem(index: number): SVGLength;\n    replaceItem(newItem: SVGLength, index: number): SVGLength;\n    [index: number]: SVGLength;\n}\n\ndeclare var SVGLengthList: {\n    prototype: SVGLengthList;\n    new(): SVGLengthList;\n};\n\ninterface SVGLineElement extends SVGGraphicsElement {\n    readonly x1: SVGAnimatedLength;\n    readonly x2: SVGAnimatedLength;\n    readonly y1: SVGAnimatedLength;\n    readonly y2: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGLineElement: {\n    prototype: SVGLineElement;\n    new(): SVGLineElement;\n};\n\ninterface SVGLinearGradientElement extends SVGGradientElement {\n    readonly x1: SVGAnimatedLength;\n    readonly x2: SVGAnimatedLength;\n    readonly y1: SVGAnimatedLength;\n    readonly y2: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLinearGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGLinearGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGLinearGradientElement: {\n    prototype: SVGLinearGradientElement;\n    new(): SVGLinearGradientElement;\n};\n\ninterface SVGMarkerElement extends SVGElement, SVGFitToViewBox {\n    readonly markerHeight: SVGAnimatedLength;\n    readonly markerUnits: SVGAnimatedEnumeration;\n    readonly markerWidth: SVGAnimatedLength;\n    readonly orientAngle: SVGAnimatedAngle;\n    readonly orientType: SVGAnimatedEnumeration;\n    readonly refX: SVGAnimatedLength;\n    readonly refY: SVGAnimatedLength;\n    setOrientToAngle(angle: SVGAngle): void;\n    setOrientToAuto(): void;\n    readonly SVG_MARKERUNITS_STROKEWIDTH: number;\n    readonly SVG_MARKERUNITS_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_USERSPACEONUSE: number;\n    readonly SVG_MARKER_ORIENT_ANGLE: number;\n    readonly SVG_MARKER_ORIENT_AUTO: number;\n    readonly SVG_MARKER_ORIENT_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMarkerElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMarkerElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGMarkerElement: {\n    prototype: SVGMarkerElement;\n    new(): SVGMarkerElement;\n    readonly SVG_MARKERUNITS_STROKEWIDTH: number;\n    readonly SVG_MARKERUNITS_UNKNOWN: number;\n    readonly SVG_MARKERUNITS_USERSPACEONUSE: number;\n    readonly SVG_MARKER_ORIENT_ANGLE: number;\n    readonly SVG_MARKER_ORIENT_AUTO: number;\n    readonly SVG_MARKER_ORIENT_UNKNOWN: number;\n};\n\ninterface SVGMaskElement extends SVGElement, SVGTests {\n    readonly height: SVGAnimatedLength;\n    readonly maskContentUnits: SVGAnimatedEnumeration;\n    readonly maskUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMaskElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMaskElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGMaskElement: {\n    prototype: SVGMaskElement;\n    new(): SVGMaskElement;\n};\n\ninterface SVGMetadataElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMetadataElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGMetadataElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGMetadataElement: {\n    prototype: SVGMetadataElement;\n    new(): SVGMetadataElement;\n};\n\ninterface SVGNumber {\n    value: number;\n}\n\ndeclare var SVGNumber: {\n    prototype: SVGNumber;\n    new(): SVGNumber;\n};\n\ninterface SVGNumberList {\n    readonly length: number;\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGNumber): SVGNumber;\n    clear(): void;\n    getItem(index: number): SVGNumber;\n    initialize(newItem: SVGNumber): SVGNumber;\n    insertItemBefore(newItem: SVGNumber, index: number): SVGNumber;\n    removeItem(index: number): SVGNumber;\n    replaceItem(newItem: SVGNumber, index: number): SVGNumber;\n    [index: number]: SVGNumber;\n}\n\ndeclare var SVGNumberList: {\n    prototype: SVGNumberList;\n    new(): SVGNumberList;\n};\n\ninterface SVGPathElement extends SVGGraphicsElement {\n    /** @deprecated */\n    readonly pathSegList: SVGPathSegList;\n    /** @deprecated */\n    createSVGPathSegArcAbs(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcAbs;\n    /** @deprecated */\n    createSVGPathSegArcRel(x: number, y: number, r1: number, r2: number, angle: number, largeArcFlag: boolean, sweepFlag: boolean): SVGPathSegArcRel;\n    /** @deprecated */\n    createSVGPathSegClosePath(): SVGPathSegClosePath;\n    /** @deprecated */\n    createSVGPathSegCurvetoCubicAbs(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicAbs;\n    /** @deprecated */\n    createSVGPathSegCurvetoCubicRel(x: number, y: number, x1: number, y1: number, x2: number, y2: number): SVGPathSegCurvetoCubicRel;\n    /** @deprecated */\n    createSVGPathSegCurvetoCubicSmoothAbs(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothAbs;\n    /** @deprecated */\n    createSVGPathSegCurvetoCubicSmoothRel(x: number, y: number, x2: number, y2: number): SVGPathSegCurvetoCubicSmoothRel;\n    /** @deprecated */\n    createSVGPathSegCurvetoQuadraticAbs(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticAbs;\n    /** @deprecated */\n    createSVGPathSegCurvetoQuadraticRel(x: number, y: number, x1: number, y1: number): SVGPathSegCurvetoQuadraticRel;\n    /** @deprecated */\n    createSVGPathSegCurvetoQuadraticSmoothAbs(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothAbs;\n    /** @deprecated */\n    createSVGPathSegCurvetoQuadraticSmoothRel(x: number, y: number): SVGPathSegCurvetoQuadraticSmoothRel;\n    /** @deprecated */\n    createSVGPathSegLinetoAbs(x: number, y: number): SVGPathSegLinetoAbs;\n    /** @deprecated */\n    createSVGPathSegLinetoHorizontalAbs(x: number): SVGPathSegLinetoHorizontalAbs;\n    /** @deprecated */\n    createSVGPathSegLinetoHorizontalRel(x: number): SVGPathSegLinetoHorizontalRel;\n    /** @deprecated */\n    createSVGPathSegLinetoRel(x: number, y: number): SVGPathSegLinetoRel;\n    /** @deprecated */\n    createSVGPathSegLinetoVerticalAbs(y: number): SVGPathSegLinetoVerticalAbs;\n    /** @deprecated */\n    createSVGPathSegLinetoVerticalRel(y: number): SVGPathSegLinetoVerticalRel;\n    /** @deprecated */\n    createSVGPathSegMovetoAbs(x: number, y: number): SVGPathSegMovetoAbs;\n    /** @deprecated */\n    createSVGPathSegMovetoRel(x: number, y: number): SVGPathSegMovetoRel;\n    /** @deprecated */\n    getPathSegAtLength(distance: number): number;\n    getPointAtLength(distance: number): SVGPoint;\n    getTotalLength(): number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGPathElement: {\n    prototype: SVGPathElement;\n    new(): SVGPathElement;\n};\n\ninterface SVGPathSeg {\n    readonly pathSegType: number;\n    readonly pathSegTypeAsLetter: string;\n    readonly PATHSEG_ARC_ABS: number;\n    readonly PATHSEG_ARC_REL: number;\n    readonly PATHSEG_CLOSEPATH: number;\n    readonly PATHSEG_CURVETO_CUBIC_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_REL: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\n    readonly PATHSEG_LINETO_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_REL: number;\n    readonly PATHSEG_LINETO_REL: number;\n    readonly PATHSEG_LINETO_VERTICAL_ABS: number;\n    readonly PATHSEG_LINETO_VERTICAL_REL: number;\n    readonly PATHSEG_MOVETO_ABS: number;\n    readonly PATHSEG_MOVETO_REL: number;\n    readonly PATHSEG_UNKNOWN: number;\n}\n\ndeclare var SVGPathSeg: {\n    prototype: SVGPathSeg;\n    new(): SVGPathSeg;\n    readonly PATHSEG_ARC_ABS: number;\n    readonly PATHSEG_ARC_REL: number;\n    readonly PATHSEG_CLOSEPATH: number;\n    readonly PATHSEG_CURVETO_CUBIC_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_REL: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_REL: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: number;\n    readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: number;\n    readonly PATHSEG_LINETO_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_ABS: number;\n    readonly PATHSEG_LINETO_HORIZONTAL_REL: number;\n    readonly PATHSEG_LINETO_REL: number;\n    readonly PATHSEG_LINETO_VERTICAL_ABS: number;\n    readonly PATHSEG_LINETO_VERTICAL_REL: number;\n    readonly PATHSEG_MOVETO_ABS: number;\n    readonly PATHSEG_MOVETO_REL: number;\n    readonly PATHSEG_UNKNOWN: number;\n};\n\ninterface SVGPathSegArcAbs extends SVGPathSeg {\n    angle: number;\n    largeArcFlag: boolean;\n    r1: number;\n    r2: number;\n    sweepFlag: boolean;\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegArcAbs: {\n    prototype: SVGPathSegArcAbs;\n    new(): SVGPathSegArcAbs;\n};\n\ninterface SVGPathSegArcRel extends SVGPathSeg {\n    angle: number;\n    largeArcFlag: boolean;\n    r1: number;\n    r2: number;\n    sweepFlag: boolean;\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegArcRel: {\n    prototype: SVGPathSegArcRel;\n    new(): SVGPathSegArcRel;\n};\n\ninterface SVGPathSegClosePath extends SVGPathSeg {\n}\n\ndeclare var SVGPathSegClosePath: {\n    prototype: SVGPathSegClosePath;\n    new(): SVGPathSegClosePath;\n};\n\ninterface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {\n    x: number;\n    x1: number;\n    x2: number;\n    y: number;\n    y1: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicAbs: {\n    prototype: SVGPathSegCurvetoCubicAbs;\n    new(): SVGPathSegCurvetoCubicAbs;\n};\n\ninterface SVGPathSegCurvetoCubicRel extends SVGPathSeg {\n    x: number;\n    x1: number;\n    x2: number;\n    y: number;\n    y1: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicRel: {\n    prototype: SVGPathSegCurvetoCubicRel;\n    new(): SVGPathSegCurvetoCubicRel;\n};\n\ninterface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {\n    x: number;\n    x2: number;\n    y: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicSmoothAbs: {\n    prototype: SVGPathSegCurvetoCubicSmoothAbs;\n    new(): SVGPathSegCurvetoCubicSmoothAbs;\n};\n\ninterface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {\n    x: number;\n    x2: number;\n    y: number;\n    y2: number;\n}\n\ndeclare var SVGPathSegCurvetoCubicSmoothRel: {\n    prototype: SVGPathSegCurvetoCubicSmoothRel;\n    new(): SVGPathSegCurvetoCubicSmoothRel;\n};\n\ninterface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {\n    x: number;\n    x1: number;\n    y: number;\n    y1: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticAbs: {\n    prototype: SVGPathSegCurvetoQuadraticAbs;\n    new(): SVGPathSegCurvetoQuadraticAbs;\n};\n\ninterface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {\n    x: number;\n    x1: number;\n    y: number;\n    y1: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticRel: {\n    prototype: SVGPathSegCurvetoQuadraticRel;\n    new(): SVGPathSegCurvetoQuadraticRel;\n};\n\ninterface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticSmoothAbs: {\n    prototype: SVGPathSegCurvetoQuadraticSmoothAbs;\n    new(): SVGPathSegCurvetoQuadraticSmoothAbs;\n};\n\ninterface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegCurvetoQuadraticSmoothRel: {\n    prototype: SVGPathSegCurvetoQuadraticSmoothRel;\n    new(): SVGPathSegCurvetoQuadraticSmoothRel;\n};\n\ninterface SVGPathSegLinetoAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoAbs: {\n    prototype: SVGPathSegLinetoAbs;\n    new(): SVGPathSegLinetoAbs;\n};\n\ninterface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {\n    x: number;\n}\n\ndeclare var SVGPathSegLinetoHorizontalAbs: {\n    prototype: SVGPathSegLinetoHorizontalAbs;\n    new(): SVGPathSegLinetoHorizontalAbs;\n};\n\ninterface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {\n    x: number;\n}\n\ndeclare var SVGPathSegLinetoHorizontalRel: {\n    prototype: SVGPathSegLinetoHorizontalRel;\n    new(): SVGPathSegLinetoHorizontalRel;\n};\n\ninterface SVGPathSegLinetoRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoRel: {\n    prototype: SVGPathSegLinetoRel;\n    new(): SVGPathSegLinetoRel;\n};\n\ninterface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoVerticalAbs: {\n    prototype: SVGPathSegLinetoVerticalAbs;\n    new(): SVGPathSegLinetoVerticalAbs;\n};\n\ninterface SVGPathSegLinetoVerticalRel extends SVGPathSeg {\n    y: number;\n}\n\ndeclare var SVGPathSegLinetoVerticalRel: {\n    prototype: SVGPathSegLinetoVerticalRel;\n    new(): SVGPathSegLinetoVerticalRel;\n};\n\ninterface SVGPathSegList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGPathSeg): SVGPathSeg;\n    clear(): void;\n    getItem(index: number): SVGPathSeg;\n    initialize(newItem: SVGPathSeg): SVGPathSeg;\n    insertItemBefore(newItem: SVGPathSeg, index: number): SVGPathSeg;\n    removeItem(index: number): SVGPathSeg;\n    replaceItem(newItem: SVGPathSeg, index: number): SVGPathSeg;\n}\n\ndeclare var SVGPathSegList: {\n    prototype: SVGPathSegList;\n    new(): SVGPathSegList;\n};\n\ninterface SVGPathSegMovetoAbs extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegMovetoAbs: {\n    prototype: SVGPathSegMovetoAbs;\n    new(): SVGPathSegMovetoAbs;\n};\n\ninterface SVGPathSegMovetoRel extends SVGPathSeg {\n    x: number;\n    y: number;\n}\n\ndeclare var SVGPathSegMovetoRel: {\n    prototype: SVGPathSegMovetoRel;\n    new(): SVGPathSegMovetoRel;\n};\n\ninterface SVGPatternElement extends SVGElement, SVGTests, SVGFitToViewBox, SVGURIReference {\n    readonly height: SVGAnimatedLength;\n    readonly patternContentUnits: SVGAnimatedEnumeration;\n    readonly patternTransform: SVGAnimatedTransformList;\n    readonly patternUnits: SVGAnimatedEnumeration;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPatternElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPatternElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGPatternElement: {\n    prototype: SVGPatternElement;\n    new(): SVGPatternElement;\n};\n\ninterface SVGPointList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGPoint): SVGPoint;\n    clear(): void;\n    getItem(index: number): SVGPoint;\n    initialize(newItem: SVGPoint): SVGPoint;\n    insertItemBefore(newItem: SVGPoint, index: number): SVGPoint;\n    removeItem(index: number): SVGPoint;\n    replaceItem(newItem: SVGPoint, index: number): SVGPoint;\n}\n\ndeclare var SVGPointList: {\n    prototype: SVGPointList;\n    new(): SVGPointList;\n};\n\ninterface SVGPolygonElement extends SVGGraphicsElement, SVGAnimatedPoints {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolygonElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolygonElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGPolygonElement: {\n    prototype: SVGPolygonElement;\n    new(): SVGPolygonElement;\n};\n\ninterface SVGPolylineElement extends SVGGraphicsElement, SVGAnimatedPoints {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolylineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGPolylineElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGPolylineElement: {\n    prototype: SVGPolylineElement;\n    new(): SVGPolylineElement;\n};\n\ninterface SVGPreserveAspectRatio {\n    align: number;\n    meetOrSlice: number;\n    readonly SVG_MEETORSLICE_MEET: number;\n    readonly SVG_MEETORSLICE_SLICE: number;\n    readonly SVG_MEETORSLICE_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_NONE: number;\n    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\n}\n\ndeclare var SVGPreserveAspectRatio: {\n    prototype: SVGPreserveAspectRatio;\n    new(): SVGPreserveAspectRatio;\n    readonly SVG_MEETORSLICE_MEET: number;\n    readonly SVG_MEETORSLICE_SLICE: number;\n    readonly SVG_MEETORSLICE_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_NONE: number;\n    readonly SVG_PRESERVEASPECTRATIO_UNKNOWN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMAX: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMID: number;\n    readonly SVG_PRESERVEASPECTRATIO_XMINYMIN: number;\n};\n\ninterface SVGRadialGradientElement extends SVGGradientElement {\n    readonly cx: SVGAnimatedLength;\n    readonly cy: SVGAnimatedLength;\n    readonly fx: SVGAnimatedLength;\n    readonly fy: SVGAnimatedLength;\n    readonly r: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRadialGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRadialGradientElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGRadialGradientElement: {\n    prototype: SVGRadialGradientElement;\n    new(): SVGRadialGradientElement;\n};\n\ninterface SVGRectElement extends SVGGraphicsElement {\n    readonly height: SVGAnimatedLength;\n    readonly rx: SVGAnimatedLength;\n    readonly ry: SVGAnimatedLength;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGRectElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGRectElement: {\n    prototype: SVGRectElement;\n    new(): SVGRectElement;\n};\n\ninterface SVGSVGElementEventMap extends SVGElementEventMap {\n    "SVGUnload": Event;\n    "SVGZoom": SVGZoomEvent;\n}\n\ninterface SVGSVGElement extends SVGGraphicsElement, DocumentEvent, SVGFitToViewBox, SVGZoomAndPan {\n    /** @deprecated */\n    contentScriptType: string;\n    /** @deprecated */\n    contentStyleType: string;\n    currentScale: number;\n    readonly currentTranslate: SVGPoint;\n    readonly height: SVGAnimatedLength;\n    onunload: ((this: SVGSVGElement, ev: Event) => any) | null;\n    onzoom: ((this: SVGSVGElement, ev: SVGZoomEvent) => any) | null;\n    /** @deprecated */\n    readonly pixelUnitToMillimeterX: number;\n    /** @deprecated */\n    readonly pixelUnitToMillimeterY: number;\n    /** @deprecated */\n    readonly screenPixelToMillimeterX: number;\n    /** @deprecated */\n    readonly screenPixelToMillimeterY: number;\n    /** @deprecated */\n    readonly viewport: SVGRect;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    checkEnclosure(element: SVGElement, rect: SVGRect): boolean;\n    checkIntersection(element: SVGElement, rect: SVGRect): boolean;\n    createSVGAngle(): SVGAngle;\n    createSVGLength(): SVGLength;\n    createSVGMatrix(): SVGMatrix;\n    createSVGNumber(): SVGNumber;\n    createSVGPoint(): SVGPoint;\n    createSVGRect(): SVGRect;\n    createSVGTransform(): SVGTransform;\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\n    deselectAll(): void;\n    /** @deprecated */\n    forceRedraw(): void;\n    getComputedStyle(elt: Element, pseudoElt?: string | null): CSSStyleDeclaration;\n    /** @deprecated */\n    getCurrentTime(): number;\n    getElementById(elementId: string): Element;\n    getEnclosureList(rect: SVGRect, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;\n    getIntersectionList(rect: SVGRect, referenceElement: SVGElement): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>;\n    /** @deprecated */\n    pauseAnimations(): void;\n    /** @deprecated */\n    setCurrentTime(seconds: number): void;\n    /** @deprecated */\n    suspendRedraw(maxWaitMilliseconds: number): number;\n    /** @deprecated */\n    unpauseAnimations(): void;\n    /** @deprecated */\n    unsuspendRedraw(suspendHandleID: number): void;\n    /** @deprecated */\n    unsuspendRedrawAll(): void;\n    addEventListener<K extends keyof SVGSVGElementEventMap>(type: K, listener: (this: SVGSVGElement, ev: SVGSVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGSVGElementEventMap>(type: K, listener: (this: SVGSVGElement, ev: SVGSVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGSVGElement: {\n    prototype: SVGSVGElement;\n    new(): SVGSVGElement;\n    readonly SVG_ZOOMANDPAN_DISABLE: number;\n    readonly SVG_ZOOMANDPAN_MAGNIFY: number;\n    readonly SVG_ZOOMANDPAN_UNKNOWN: number;\n};\n\ninterface SVGScriptElement extends SVGElement, SVGURIReference {\n    type: string;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGScriptElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGScriptElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGScriptElement: {\n    prototype: SVGScriptElement;\n    new(): SVGScriptElement;\n};\n\ninterface SVGStopElement extends SVGElement {\n    readonly offset: SVGAnimatedNumber;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStopElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStopElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGStopElement: {\n    prototype: SVGStopElement;\n    new(): SVGStopElement;\n};\n\ninterface SVGStringList {\n    readonly length: number;\n    readonly numberOfItems: number;\n    appendItem(newItem: string): string;\n    clear(): void;\n    getItem(index: number): string;\n    initialize(newItem: string): string;\n    insertItemBefore(newItem: string, index: number): string;\n    removeItem(index: number): string;\n    replaceItem(newItem: string, index: number): string;\n    [index: number]: string;\n}\n\ndeclare var SVGStringList: {\n    prototype: SVGStringList;\n    new(): SVGStringList;\n};\n\ninterface SVGStyleElement extends SVGElement {\n    disabled: boolean;\n    media: string;\n    title: string;\n    type: string;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStyleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGStyleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGStyleElement: {\n    prototype: SVGStyleElement;\n    new(): SVGStyleElement;\n};\n\ninterface SVGSwitchElement extends SVGGraphicsElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSwitchElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSwitchElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGSwitchElement: {\n    prototype: SVGSwitchElement;\n    new(): SVGSwitchElement;\n};\n\ninterface SVGSymbolElement extends SVGElement, SVGFitToViewBox {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSymbolElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGSymbolElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGSymbolElement: {\n    prototype: SVGSymbolElement;\n    new(): SVGSymbolElement;\n};\n\ninterface SVGTSpanElement extends SVGTextPositioningElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTSpanElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTSpanElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTSpanElement: {\n    prototype: SVGTSpanElement;\n    new(): SVGTSpanElement;\n};\n\ninterface SVGTests {\n    readonly requiredExtensions: SVGStringList;\n    readonly systemLanguage: SVGStringList;\n}\n\ninterface SVGTextContentElement extends SVGGraphicsElement {\n    readonly lengthAdjust: SVGAnimatedEnumeration;\n    readonly textLength: SVGAnimatedLength;\n    getCharNumAtPosition(point: SVGPoint): number;\n    getComputedTextLength(): number;\n    getEndPositionOfChar(charnum: number): SVGPoint;\n    getExtentOfChar(charnum: number): SVGRect;\n    getNumberOfChars(): number;\n    getRotationOfChar(charnum: number): number;\n    getStartPositionOfChar(charnum: number): SVGPoint;\n    getSubStringLength(charnum: number, nchars: number): number;\n    selectSubString(charnum: number, nchars: number): void;\n    readonly LENGTHADJUST_SPACING: number;\n    readonly LENGTHADJUST_SPACINGANDGLYPHS: number;\n    readonly LENGTHADJUST_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextContentElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextContentElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTextContentElement: {\n    prototype: SVGTextContentElement;\n    new(): SVGTextContentElement;\n    readonly LENGTHADJUST_SPACING: number;\n    readonly LENGTHADJUST_SPACINGANDGLYPHS: number;\n    readonly LENGTHADJUST_UNKNOWN: number;\n};\n\ninterface SVGTextElement extends SVGTextPositioningElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTextElement: {\n    prototype: SVGTextElement;\n    new(): SVGTextElement;\n};\n\ninterface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {\n    readonly method: SVGAnimatedEnumeration;\n    readonly spacing: SVGAnimatedEnumeration;\n    readonly startOffset: SVGAnimatedLength;\n    readonly TEXTPATH_METHODTYPE_ALIGN: number;\n    readonly TEXTPATH_METHODTYPE_STRETCH: number;\n    readonly TEXTPATH_METHODTYPE_UNKNOWN: number;\n    readonly TEXTPATH_SPACINGTYPE_AUTO: number;\n    readonly TEXTPATH_SPACINGTYPE_EXACT: number;\n    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: number;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPathElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTextPathElement: {\n    prototype: SVGTextPathElement;\n    new(): SVGTextPathElement;\n    readonly TEXTPATH_METHODTYPE_ALIGN: number;\n    readonly TEXTPATH_METHODTYPE_STRETCH: number;\n    readonly TEXTPATH_METHODTYPE_UNKNOWN: number;\n    readonly TEXTPATH_SPACINGTYPE_AUTO: number;\n    readonly TEXTPATH_SPACINGTYPE_EXACT: number;\n    readonly TEXTPATH_SPACINGTYPE_UNKNOWN: number;\n};\n\ninterface SVGTextPositioningElement extends SVGTextContentElement {\n    readonly dx: SVGAnimatedLengthList;\n    readonly dy: SVGAnimatedLengthList;\n    readonly rotate: SVGAnimatedNumberList;\n    readonly x: SVGAnimatedLengthList;\n    readonly y: SVGAnimatedLengthList;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPositioningElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTextPositioningElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTextPositioningElement: {\n    prototype: SVGTextPositioningElement;\n    new(): SVGTextPositioningElement;\n};\n\ninterface SVGTitleElement extends SVGElement {\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTitleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGTitleElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGTitleElement: {\n    prototype: SVGTitleElement;\n    new(): SVGTitleElement;\n};\n\ninterface SVGTransform {\n    readonly angle: number;\n    readonly matrix: SVGMatrix;\n    readonly type: number;\n    setMatrix(matrix: SVGMatrix): void;\n    setRotate(angle: number, cx: number, cy: number): void;\n    setScale(sx: number, sy: number): void;\n    setSkewX(angle: number): void;\n    setSkewY(angle: number): void;\n    setTranslate(tx: number, ty: number): void;\n    readonly SVG_TRANSFORM_MATRIX: number;\n    readonly SVG_TRANSFORM_ROTATE: number;\n    readonly SVG_TRANSFORM_SCALE: number;\n    readonly SVG_TRANSFORM_SKEWX: number;\n    readonly SVG_TRANSFORM_SKEWY: number;\n    readonly SVG_TRANSFORM_TRANSLATE: number;\n    readonly SVG_TRANSFORM_UNKNOWN: number;\n}\n\ndeclare var SVGTransform: {\n    prototype: SVGTransform;\n    new(): SVGTransform;\n    readonly SVG_TRANSFORM_MATRIX: number;\n    readonly SVG_TRANSFORM_ROTATE: number;\n    readonly SVG_TRANSFORM_SCALE: number;\n    readonly SVG_TRANSFORM_SKEWX: number;\n    readonly SVG_TRANSFORM_SKEWY: number;\n    readonly SVG_TRANSFORM_TRANSLATE: number;\n    readonly SVG_TRANSFORM_UNKNOWN: number;\n};\n\ninterface SVGTransformList {\n    readonly numberOfItems: number;\n    appendItem(newItem: SVGTransform): SVGTransform;\n    clear(): void;\n    consolidate(): SVGTransform;\n    createSVGTransformFromMatrix(matrix: SVGMatrix): SVGTransform;\n    getItem(index: number): SVGTransform;\n    initialize(newItem: SVGTransform): SVGTransform;\n    insertItemBefore(newItem: SVGTransform, index: number): SVGTransform;\n    removeItem(index: number): SVGTransform;\n    replaceItem(newItem: SVGTransform, index: number): SVGTransform;\n}\n\ndeclare var SVGTransformList: {\n    prototype: SVGTransformList;\n    new(): SVGTransformList;\n};\n\ninterface SVGURIReference {\n    readonly href: SVGAnimatedString;\n}\n\ninterface SVGUnitTypes {\n    readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: number;\n    readonly SVG_UNIT_TYPE_UNKNOWN: number;\n    readonly SVG_UNIT_TYPE_USERSPACEONUSE: number;\n}\n\ndeclare var SVGUnitTypes: {\n    prototype: SVGUnitTypes;\n    new(): SVGUnitTypes;\n    readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: number;\n    readonly SVG_UNIT_TYPE_UNKNOWN: number;\n    readonly SVG_UNIT_TYPE_USERSPACEONUSE: number;\n};\n\ninterface SVGUseElement extends SVGGraphicsElement, SVGURIReference {\n    readonly animatedInstanceRoot: SVGElementInstance | null;\n    readonly height: SVGAnimatedLength;\n    readonly instanceRoot: SVGElementInstance | null;\n    readonly width: SVGAnimatedLength;\n    readonly x: SVGAnimatedLength;\n    readonly y: SVGAnimatedLength;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGUseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGUseElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGUseElement: {\n    prototype: SVGUseElement;\n    new(): SVGUseElement;\n};\n\ninterface SVGViewElement extends SVGElement, SVGFitToViewBox, SVGZoomAndPan {\n    /** @deprecated */\n    readonly viewTarget: SVGStringList;\n    addEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGViewElement, ev: SVGElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGViewElement, ev: SVGElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SVGViewElement: {\n    prototype: SVGViewElement;\n    new(): SVGViewElement;\n    readonly SVG_ZOOMANDPAN_DISABLE: number;\n    readonly SVG_ZOOMANDPAN_MAGNIFY: number;\n    readonly SVG_ZOOMANDPAN_UNKNOWN: number;\n};\n\ninterface SVGZoomAndPan {\n    readonly zoomAndPan: number;\n}\n\ndeclare var SVGZoomAndPan: {\n    readonly SVG_ZOOMANDPAN_DISABLE: number;\n    readonly SVG_ZOOMANDPAN_MAGNIFY: number;\n    readonly SVG_ZOOMANDPAN_UNKNOWN: number;\n};\n\ninterface SVGZoomEvent extends UIEvent {\n    readonly newScale: number;\n    readonly newTranslate: SVGPoint;\n    readonly previousScale: number;\n    readonly previousTranslate: SVGPoint;\n    readonly zoomRectScreen: SVGRect;\n}\n\ndeclare var SVGZoomEvent: {\n    prototype: SVGZoomEvent;\n    new(): SVGZoomEvent;\n};\n\ninterface ScopedCredential {\n    readonly id: ArrayBuffer;\n    readonly type: ScopedCredentialType;\n}\n\ndeclare var ScopedCredential: {\n    prototype: ScopedCredential;\n    new(): ScopedCredential;\n};\n\ninterface ScopedCredentialInfo {\n    readonly credential: ScopedCredential;\n    readonly publicKey: CryptoKey;\n}\n\ndeclare var ScopedCredentialInfo: {\n    prototype: ScopedCredentialInfo;\n    new(): ScopedCredentialInfo;\n};\n\ninterface Screen {\n    readonly availHeight: number;\n    readonly availWidth: number;\n    readonly colorDepth: number;\n    readonly height: number;\n    readonly orientation: ScreenOrientation;\n    readonly pixelDepth: number;\n    readonly width: number;\n}\n\ndeclare var Screen: {\n    prototype: Screen;\n    new(): Screen;\n};\n\ninterface ScreenOrientationEventMap {\n    "change": Event;\n}\n\ninterface ScreenOrientation extends EventTarget {\n    readonly angle: number;\n    onchange: ((this: ScreenOrientation, ev: Event) => any) | null;\n    readonly type: OrientationType;\n    lock(orientation: OrientationLockType): Promise<void>;\n    unlock(): void;\n    addEventListener<K extends keyof ScreenOrientationEventMap>(type: K, listener: (this: ScreenOrientation, ev: ScreenOrientationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ScreenOrientationEventMap>(type: K, listener: (this: ScreenOrientation, ev: ScreenOrientationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ScreenOrientation: {\n    prototype: ScreenOrientation;\n    new(): ScreenOrientation;\n};\n\ninterface ScriptProcessorNodeEventMap {\n    "audioprocess": AudioProcessingEvent;\n}\n\ninterface ScriptProcessorNode extends AudioNode {\n    /** @deprecated */\n    readonly bufferSize: number;\n    /** @deprecated */\n    onaudioprocess: ((this: ScriptProcessorNode, ev: AudioProcessingEvent) => any) | null;\n    addEventListener<K extends keyof ScriptProcessorNodeEventMap>(type: K, listener: (this: ScriptProcessorNode, ev: ScriptProcessorNodeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ScriptProcessorNodeEventMap>(type: K, listener: (this: ScriptProcessorNode, ev: ScriptProcessorNodeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ScriptProcessorNode: {\n    prototype: ScriptProcessorNode;\n    new(): ScriptProcessorNode;\n};\n\ninterface SecurityPolicyViolationEvent extends Event {\n    readonly blockedURI: string;\n    readonly columnNumber: number;\n    readonly documentURI: string;\n    readonly effectiveDirective: string;\n    readonly lineNumber: number;\n    readonly originalPolicy: string;\n    readonly referrer: string;\n    readonly sourceFile: string;\n    readonly statusCode: number;\n    readonly violatedDirective: string;\n}\n\ndeclare var SecurityPolicyViolationEvent: {\n    prototype: SecurityPolicyViolationEvent;\n    new(type: string, eventInitDict?: SecurityPolicyViolationEventInit): SecurityPolicyViolationEvent;\n};\n\ninterface Selection {\n    readonly anchorNode: Node;\n    readonly anchorOffset: number;\n    readonly baseNode: Node;\n    readonly baseOffset: number;\n    readonly extentNode: Node;\n    readonly extentOffset: number;\n    readonly focusNode: Node;\n    readonly focusOffset: number;\n    readonly isCollapsed: boolean;\n    readonly rangeCount: number;\n    readonly type: string;\n    addRange(range: Range): void;\n    collapse(parentNode: Node, offset: number): void;\n    collapseToEnd(): void;\n    collapseToStart(): void;\n    containsNode(node: Node, partlyContained: boolean): boolean;\n    deleteFromDocument(): void;\n    empty(): void;\n    extend(newNode: Node, offset: number): void;\n    getRangeAt(index: number): Range;\n    removeAllRanges(): void;\n    removeRange(range: Range): void;\n    selectAllChildren(parentNode: Node): void;\n    setBaseAndExtent(baseNode: Node, baseOffset: number, extentNode: Node, extentOffset: number): void;\n    setPosition(parentNode: Node, offset: number): void;\n    toString(): string;\n}\n\ndeclare var Selection: {\n    prototype: Selection;\n    new(): Selection;\n};\n\ninterface ServiceUIFrameContext {\n    getCachedFrameMessage(key: string): string;\n    postFrameMessage(key: string, data: string): void;\n}\ndeclare var ServiceUIFrameContext: ServiceUIFrameContext;\n\ninterface ServiceWorkerEventMap extends AbstractWorkerEventMap {\n    "statechange": Event;\n}\n\ninterface ServiceWorker extends EventTarget, AbstractWorker {\n    onstatechange: ((this: ServiceWorker, ev: Event) => any) | null;\n    readonly scriptURL: string;\n    readonly state: ServiceWorkerState;\n    postMessage(message: any, transfer?: Transferable[]): void;\n    addEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorker: {\n    prototype: ServiceWorker;\n    new(): ServiceWorker;\n};\n\ninterface ServiceWorkerContainerEventMap {\n    "controllerchange": Event;\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface ServiceWorkerContainer extends EventTarget {\n    readonly controller: ServiceWorker | null;\n    oncontrollerchange: ((this: ServiceWorkerContainer, ev: Event) => any) | null;\n    onmessage: ((this: ServiceWorkerContainer, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: ServiceWorkerContainer, ev: MessageEvent) => any) | null;\n    readonly ready: Promise<ServiceWorkerRegistration>;\n    getRegistration(clientURL?: string): Promise<ServiceWorkerRegistration | undefined>;\n    getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>;\n    register(scriptURL: string, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;\n    startMessages(): void;\n    addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorkerContainer: {\n    prototype: ServiceWorkerContainer;\n    new(): ServiceWorkerContainer;\n};\n\ninterface ServiceWorkerMessageEvent extends Event {\n    readonly data: any;\n    readonly lastEventId: string;\n    readonly origin: string;\n    readonly ports: ReadonlyArray<MessagePort> | null;\n    readonly source: ServiceWorker | MessagePort | null;\n}\n\ndeclare var ServiceWorkerMessageEvent: {\n    prototype: ServiceWorkerMessageEvent;\n    new(type: string, eventInitDict?: ServiceWorkerMessageEventInit): ServiceWorkerMessageEvent;\n};\n\ninterface ServiceWorkerRegistrationEventMap {\n    "updatefound": Event;\n}\n\ninterface ServiceWorkerRegistration extends EventTarget {\n    readonly active: ServiceWorker | null;\n    readonly installing: ServiceWorker | null;\n    readonly navigationPreload: NavigationPreloadManager;\n    onupdatefound: ((this: ServiceWorkerRegistration, ev: Event) => any) | null;\n    readonly pushManager: PushManager;\n    readonly scope: string;\n    readonly sync: SyncManager;\n    readonly updateViaCache: ServiceWorkerUpdateViaCache;\n    readonly waiting: ServiceWorker | null;\n    getNotifications(filter?: GetNotificationOptions): Promise<Notification[]>;\n    showNotification(title: string, options?: NotificationOptions): Promise<void>;\n    unregister(): Promise<boolean>;\n    update(): Promise<void>;\n    addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorkerRegistration: {\n    prototype: ServiceWorkerRegistration;\n    new(): ServiceWorkerRegistration;\n};\n\ninterface ShadowRoot extends DocumentOrShadowRoot, DocumentFragment, DocumentOrShadowRoot {\n    readonly host: Element;\n    innerHTML: string;\n    readonly mode: ShadowRootMode;\n}\n\ninterface ShadowRootInit {\n    delegatesFocus?: boolean;\n    mode: "open" | "closed";\n}\n\ninterface Slotable {\n    readonly assignedSlot: HTMLSlotElement | null;\n}\n\ninterface SourceBuffer extends EventTarget {\n    appendWindowEnd: number;\n    appendWindowStart: number;\n    readonly audioTracks: AudioTrackList;\n    readonly buffered: TimeRanges;\n    mode: AppendMode;\n    readonly textTracks: TextTrackList;\n    timestampOffset: number;\n    readonly updating: boolean;\n    readonly videoTracks: VideoTrackList;\n    abort(): void;\n    appendBuffer(data: ArrayBuffer | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | null): void;\n    appendStream(stream: MSStream, maxSize?: number): void;\n    remove(start: number, end: number): void;\n}\n\ndeclare var SourceBuffer: {\n    prototype: SourceBuffer;\n    new(): SourceBuffer;\n};\n\ninterface SourceBufferList extends EventTarget {\n    readonly length: number;\n    item(index: number): SourceBuffer;\n    [index: number]: SourceBuffer;\n}\n\ndeclare var SourceBufferList: {\n    prototype: SourceBufferList;\n    new(): SourceBufferList;\n};\n\ninterface SpeechGrammar {\n    src: string;\n    weight: number;\n}\n\ndeclare var SpeechGrammar: {\n    prototype: SpeechGrammar;\n    new(): SpeechGrammar;\n};\n\ninterface SpeechGrammarList {\n    readonly length: number;\n    addFromString(string: string, weight?: number): void;\n    addFromURI(src: string, weight?: number): void;\n    item(index: number): SpeechGrammar;\n    [index: number]: SpeechGrammar;\n}\n\ndeclare var SpeechGrammarList: {\n    prototype: SpeechGrammarList;\n    new(): SpeechGrammarList;\n};\n\ninterface SpeechRecognitionEventMap {\n    "audioend": Event;\n    "audiostart": Event;\n    "end": Event;\n    "error": SpeechRecognitionError;\n    "nomatch": SpeechRecognitionEvent;\n    "result": SpeechRecognitionEvent;\n    "soundend": Event;\n    "soundstart": Event;\n    "speechend": Event;\n    "speechstart": Event;\n    "start": Event;\n}\n\ninterface SpeechRecognition extends EventTarget {\n    continuous: boolean;\n    grammars: SpeechGrammarList;\n    interimResults: boolean;\n    lang: string;\n    maxAlternatives: number;\n    onaudioend: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onaudiostart: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onend: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onerror: ((this: SpeechRecognition, ev: SpeechRecognitionError) => any) | null;\n    onnomatch: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;\n    onresult: ((this: SpeechRecognition, ev: SpeechRecognitionEvent) => any) | null;\n    onsoundend: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onsoundstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onspeechend: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onspeechstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n    onstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n    serviceURI: string;\n    abort(): void;\n    start(): void;\n    stop(): void;\n    addEventListener<K extends keyof SpeechRecognitionEventMap>(type: K, listener: (this: SpeechRecognition, ev: SpeechRecognitionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SpeechRecognitionEventMap>(type: K, listener: (this: SpeechRecognition, ev: SpeechRecognitionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SpeechRecognition: {\n    prototype: SpeechRecognition;\n    new(): SpeechRecognition;\n};\n\ninterface SpeechRecognitionAlternative {\n    readonly confidence: number;\n    readonly transcript: string;\n}\n\ndeclare var SpeechRecognitionAlternative: {\n    prototype: SpeechRecognitionAlternative;\n    new(): SpeechRecognitionAlternative;\n};\n\ninterface SpeechRecognitionError extends Event {\n    readonly error: SpeechRecognitionErrorCode;\n    readonly message: string;\n}\n\ndeclare var SpeechRecognitionError: {\n    prototype: SpeechRecognitionError;\n    new(): SpeechRecognitionError;\n};\n\ninterface SpeechRecognitionEvent extends Event {\n    readonly emma: Document | null;\n    readonly interpretation: any;\n    readonly resultIndex: number;\n    readonly results: SpeechRecognitionResultList;\n}\n\ndeclare var SpeechRecognitionEvent: {\n    prototype: SpeechRecognitionEvent;\n    new(): SpeechRecognitionEvent;\n};\n\ninterface SpeechRecognitionResult {\n    readonly isFinal: boolean;\n    readonly length: number;\n    item(index: number): SpeechRecognitionAlternative;\n    [index: number]: SpeechRecognitionAlternative;\n}\n\ndeclare var SpeechRecognitionResult: {\n    prototype: SpeechRecognitionResult;\n    new(): SpeechRecognitionResult;\n};\n\ninterface SpeechRecognitionResultList {\n    readonly length: number;\n    item(index: number): SpeechRecognitionResult;\n    [index: number]: SpeechRecognitionResult;\n}\n\ndeclare var SpeechRecognitionResultList: {\n    prototype: SpeechRecognitionResultList;\n    new(): SpeechRecognitionResultList;\n};\n\ninterface SpeechSynthesisEventMap {\n    "voiceschanged": Event;\n}\n\ninterface SpeechSynthesis extends EventTarget {\n    onvoiceschanged: ((this: SpeechSynthesis, ev: Event) => any) | null;\n    readonly paused: boolean;\n    readonly pending: boolean;\n    readonly speaking: boolean;\n    cancel(): void;\n    getVoices(): SpeechSynthesisVoice[];\n    pause(): void;\n    resume(): void;\n    speak(utterance: SpeechSynthesisUtterance): void;\n    addEventListener<K extends keyof SpeechSynthesisEventMap>(type: K, listener: (this: SpeechSynthesis, ev: SpeechSynthesisEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SpeechSynthesisEventMap>(type: K, listener: (this: SpeechSynthesis, ev: SpeechSynthesisEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SpeechSynthesis: {\n    prototype: SpeechSynthesis;\n    new(): SpeechSynthesis;\n};\n\ninterface SpeechSynthesisErrorEvent extends SpeechSynthesisEvent {\n    readonly error: SpeechSynthesisErrorCode;\n}\n\ndeclare var SpeechSynthesisErrorEvent: {\n    prototype: SpeechSynthesisErrorEvent;\n    new(): SpeechSynthesisErrorEvent;\n};\n\ninterface SpeechSynthesisEvent extends Event {\n    readonly charIndex: number;\n    readonly elapsedTime: number;\n    readonly name: string;\n    readonly utterance: SpeechSynthesisUtterance;\n}\n\ndeclare var SpeechSynthesisEvent: {\n    prototype: SpeechSynthesisEvent;\n    new(): SpeechSynthesisEvent;\n};\n\ninterface SpeechSynthesisUtteranceEventMap {\n    "boundary": SpeechSynthesisEvent;\n    "end": SpeechSynthesisEvent;\n    "error": SpeechSynthesisErrorEvent;\n    "mark": SpeechSynthesisEvent;\n    "pause": SpeechSynthesisEvent;\n    "resume": SpeechSynthesisEvent;\n    "start": SpeechSynthesisEvent;\n}\n\ninterface SpeechSynthesisUtterance extends EventTarget {\n    lang: string;\n    onboundary: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    onend: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    onerror: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisErrorEvent) => any) | null;\n    onmark: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    onpause: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    onresume: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    onstart: ((this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent) => any) | null;\n    pitch: number;\n    rate: number;\n    text: string;\n    voice: SpeechSynthesisVoice;\n    volume: number;\n    addEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type: K, listener: (this: SpeechSynthesisUtterance, ev: SpeechSynthesisUtteranceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type: K, listener: (this: SpeechSynthesisUtterance, ev: SpeechSynthesisUtteranceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var SpeechSynthesisUtterance: {\n    prototype: SpeechSynthesisUtterance;\n    new(): SpeechSynthesisUtterance;\n    new(text: string): SpeechSynthesisUtterance;\n};\n\ninterface SpeechSynthesisVoice {\n    readonly default: boolean;\n    readonly lang: string;\n    readonly localService: boolean;\n    readonly name: string;\n    readonly voiceURI: string;\n}\n\ndeclare var SpeechSynthesisVoice: {\n    prototype: SpeechSynthesisVoice;\n    new(): SpeechSynthesisVoice;\n};\n\ninterface StaticRange extends AbstractRange {\n}\n\ndeclare var StaticRange: {\n    prototype: StaticRange;\n    new(): StaticRange;\n};\n\ninterface StereoPannerNode extends AudioNode {\n    readonly pan: AudioParam;\n}\n\ndeclare var StereoPannerNode: {\n    prototype: StereoPannerNode;\n    new(context: BaseAudioContext, options?: StereoPannerOptions): StereoPannerNode;\n};\n\ninterface Storage {\n    /**\n     * Returns the number of key/value pairs currently present in the list associated with the\n     * object.\n     */\n    readonly length: number;\n    /**\n     * Empties the list associated with the object of all key/value pairs, if there are any.\n     */\n    clear(): void;\n    /**\n     * value = storage[key]\n     */\n    getItem(key: string): string | null;\n    /**\n     * Returns the name of the nth key in the list, or null if n is greater\n     * than or equal to the number of key/value pairs in the object.\n     */\n    key(index: number): string | null;\n    /**\n     * delete storage[key]\n     */\n    removeItem(key: string): void;\n    /**\n     * storage[key] = value\n     */\n    setItem(key: string, value: string): void;\n    [name: string]: any;\n}\n\ndeclare var Storage: {\n    prototype: Storage;\n    new(): Storage;\n};\n\ninterface StorageEvent extends Event {\n    /**\n     * Returns the key of the storage item being changed.\n     */\n    readonly key: string | null;\n    /**\n     * Returns the new value of the key of the storage item whose value is being changed.\n     */\n    readonly newValue: string | null;\n    /**\n     * Returns the old value of the key of the storage item whose value is being changed.\n     */\n    readonly oldValue: string | null;\n    /**\n     * Returns the Storage object that was affected.\n     */\n    readonly storageArea: Storage | null;\n    /**\n     * Returns the URL of the document whose storage item changed.\n     */\n    readonly url: string;\n}\n\ndeclare var StorageEvent: {\n    prototype: StorageEvent;\n    new(type: string, eventInitDict?: StorageEventInit): StorageEvent;\n};\n\ninterface StorageManager {\n    estimate(): Promise<StorageEstimate>;\n    persist(): Promise<boolean>;\n    persisted(): Promise<boolean>;\n}\n\ndeclare var StorageManager: {\n    prototype: StorageManager;\n    new(): StorageManager;\n};\n\ninterface StyleMedia {\n    readonly type: string;\n    matchMedium(mediaquery: string): boolean;\n}\n\ndeclare var StyleMedia: {\n    prototype: StyleMedia;\n    new(): StyleMedia;\n};\n\ninterface StyleSheet {\n    disabled: boolean;\n    readonly href: string | null;\n    readonly media: MediaList;\n    readonly ownerNode: Node;\n    readonly parentStyleSheet: StyleSheet | null;\n    readonly title: string | null;\n    readonly type: string;\n}\n\ndeclare var StyleSheet: {\n    prototype: StyleSheet;\n    new(): StyleSheet;\n};\n\ninterface StyleSheetList {\n    readonly length: number;\n    item(index: number): StyleSheet | null;\n    [index: number]: StyleSheet;\n}\n\ndeclare var StyleSheetList: {\n    prototype: StyleSheetList;\n    new(): StyleSheetList;\n};\n\ninterface SubtleCrypto {\n    decrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    deriveBits(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, length: number): PromiseLike<ArrayBuffer>;\n    deriveKey(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: string | AesDerivedKeyParams | HmacImportParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    digest(algorithm: string | Algorithm, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    encrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    exportKey(format: "jwk", key: CryptoKey): PromiseLike<JsonWebKey>;\n    exportKey(format: "raw" | "pkcs8" | "spki", key: CryptoKey): PromiseLike<ArrayBuffer>;\n    exportKey(format: string, key: CryptoKey): PromiseLike<JsonWebKey | ArrayBuffer>;\n    generateKey(algorithm: string, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair | CryptoKey>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams | DhKeyGenParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: "jwk", keyData: JsonWebKey, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: "raw" | "pkcs8" | "spki", keyData: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: string, keyData: JsonWebKey | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    sign(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    unwrapKey(format: string, wrappedKey: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, unwrappingKey: CryptoKey, unwrapAlgorithm: string | Algorithm, unwrappedKeyAlgorithm: string | Algorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    verify(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, signature: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<boolean>;\n    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: string | Algorithm): PromiseLike<ArrayBuffer>;\n}\n\ndeclare var SubtleCrypto: {\n    prototype: SubtleCrypto;\n    new(): SubtleCrypto;\n};\n\ninterface SyncManager {\n    getTags(): Promise<string[]>;\n    register(tag: string): Promise<void>;\n}\n\ndeclare var SyncManager: {\n    prototype: SyncManager;\n    new(): SyncManager;\n};\n\ninterface Text extends CharacterData, Slotable {\n    readonly assignedSlot: HTMLSlotElement | null;\n    /**\n     * Returns the combined data of all direct Text node siblings.\n     */\n    readonly wholeText: string;\n    /**\n     * Splits data at the given offset and returns the remainder as Text node.\n     */\n    splitText(offset: number): Text;\n}\n\ndeclare var Text: {\n    prototype: Text;\n    new(data?: string): Text;\n};\n\ninterface TextDecoder {\n    /**\n     * Returns encoding\'s name, lowercased.\n     */\n    readonly encoding: string;\n    /**\n     * Returns true if error mode is "fatal", and false\n     * otherwise.\n     */\n    readonly fatal: boolean;\n    /**\n     * Returns true if ignore BOM flag is set, and false otherwise.\n     */\n    readonly ignoreBOM: boolean;\n    /**\n     * Returns the result of running encoding\'s decoder. The\n     * method can be invoked zero or more times with options\'s stream set to\n     * true, and then once without options\'s stream (or set to false), to process\n     * a fragmented stream. If the invocation without options\'s stream (or set to\n     * false) has no input, it\'s clearest to omit both arguments.\n     * var string = "", decoder = new TextDecoder(encoding), buffer;\n     * while(buffer = next_chunk()) {\n     * string += decoder.decode(buffer, {stream:true});\n     * }\n     * string += decoder.decode(); // end-of-stream\n     * If the error mode is "fatal" and encoding\'s decoder returns error, throws a TypeError.\n     */\n    decode(input?: BufferSource, options?: TextDecodeOptions): string;\n}\n\ndeclare var TextDecoder: {\n    prototype: TextDecoder;\n    new(label?: string, options?: TextDecoderOptions): TextDecoder;\n};\n\ninterface TextEncoder {\n    /**\n     * Returns "utf-8".\n     */\n    readonly encoding: string;\n    /**\n     * Returns the result of running UTF-8\'s encoder.\n     */\n    encode(input?: string): Uint8Array;\n}\n\ndeclare var TextEncoder: {\n    prototype: TextEncoder;\n    new(): TextEncoder;\n};\n\ninterface TextEvent extends UIEvent {\n    readonly data: string;\n    initTextEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, dataArg: string, inputMethod: number, locale: string): void;\n    readonly DOM_INPUT_METHOD_DROP: number;\n    readonly DOM_INPUT_METHOD_HANDWRITING: number;\n    readonly DOM_INPUT_METHOD_IME: number;\n    readonly DOM_INPUT_METHOD_KEYBOARD: number;\n    readonly DOM_INPUT_METHOD_MULTIMODAL: number;\n    readonly DOM_INPUT_METHOD_OPTION: number;\n    readonly DOM_INPUT_METHOD_PASTE: number;\n    readonly DOM_INPUT_METHOD_SCRIPT: number;\n    readonly DOM_INPUT_METHOD_UNKNOWN: number;\n    readonly DOM_INPUT_METHOD_VOICE: number;\n}\n\ndeclare var TextEvent: {\n    prototype: TextEvent;\n    new(): TextEvent;\n    readonly DOM_INPUT_METHOD_DROP: number;\n    readonly DOM_INPUT_METHOD_HANDWRITING: number;\n    readonly DOM_INPUT_METHOD_IME: number;\n    readonly DOM_INPUT_METHOD_KEYBOARD: number;\n    readonly DOM_INPUT_METHOD_MULTIMODAL: number;\n    readonly DOM_INPUT_METHOD_OPTION: number;\n    readonly DOM_INPUT_METHOD_PASTE: number;\n    readonly DOM_INPUT_METHOD_SCRIPT: number;\n    readonly DOM_INPUT_METHOD_UNKNOWN: number;\n    readonly DOM_INPUT_METHOD_VOICE: number;\n};\n\ninterface TextMetrics {\n    readonly actualBoundingBoxAscent: number;\n    readonly actualBoundingBoxDescent: number;\n    readonly actualBoundingBoxLeft: number;\n    readonly actualBoundingBoxRight: number;\n    readonly alphabeticBaseline: number;\n    readonly emHeightAscent: number;\n    readonly emHeightDescent: number;\n    readonly fontBoundingBoxAscent: number;\n    readonly fontBoundingBoxDescent: number;\n    readonly hangingBaseline: number;\n    /**\n     * Returns the measurement described below.\n     */\n    readonly ideographicBaseline: number;\n    readonly width: number;\n}\n\ndeclare var TextMetrics: {\n    prototype: TextMetrics;\n    new(): TextMetrics;\n};\n\ninterface TextTrackEventMap {\n    "cuechange": Event;\n    "error": Event;\n    "load": Event;\n}\n\ninterface TextTrack extends EventTarget {\n    readonly activeCues: TextTrackCueList;\n    readonly cues: TextTrackCueList;\n    readonly inBandMetadataTrackDispatchType: string;\n    readonly kind: string;\n    readonly label: string;\n    readonly language: string;\n    mode: TextTrackMode | number;\n    oncuechange: ((this: TextTrack, ev: Event) => any) | null;\n    onerror: ((this: TextTrack, ev: Event) => any) | null;\n    onload: ((this: TextTrack, ev: Event) => any) | null;\n    readonly readyState: number;\n    addCue(cue: TextTrackCue): void;\n    removeCue(cue: TextTrackCue): void;\n    readonly DISABLED: number;\n    readonly ERROR: number;\n    readonly HIDDEN: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    readonly SHOWING: number;\n    addEventListener<K extends keyof TextTrackEventMap>(type: K, listener: (this: TextTrack, ev: TextTrackEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof TextTrackEventMap>(type: K, listener: (this: TextTrack, ev: TextTrackEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var TextTrack: {\n    prototype: TextTrack;\n    new(): TextTrack;\n    readonly DISABLED: number;\n    readonly ERROR: number;\n    readonly HIDDEN: number;\n    readonly LOADED: number;\n    readonly LOADING: number;\n    readonly NONE: number;\n    readonly SHOWING: number;\n};\n\ninterface TextTrackCueEventMap {\n    "enter": Event;\n    "exit": Event;\n}\n\ninterface TextTrackCue extends EventTarget {\n    endTime: number;\n    id: string;\n    onenter: ((this: TextTrackCue, ev: Event) => any) | null;\n    onexit: ((this: TextTrackCue, ev: Event) => any) | null;\n    pauseOnExit: boolean;\n    startTime: number;\n    text: string;\n    readonly track: TextTrack;\n    getCueAsHTML(): DocumentFragment;\n    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: TextTrackCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: TextTrackCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var TextTrackCue: {\n    prototype: TextTrackCue;\n    new(startTime: number, endTime: number, text: string): TextTrackCue;\n};\n\ninterface TextTrackCueList {\n    readonly length: number;\n    getCueById(id: string): TextTrackCue;\n    item(index: number): TextTrackCue;\n    [index: number]: TextTrackCue;\n}\n\ndeclare var TextTrackCueList: {\n    prototype: TextTrackCueList;\n    new(): TextTrackCueList;\n};\n\ninterface TextTrackListEventMap {\n    "addtrack": TrackEvent;\n}\n\ninterface TextTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: ((this: TextTrackList, ev: TrackEvent) => any) | null;\n    item(index: number): TextTrack;\n    addEventListener<K extends keyof TextTrackListEventMap>(type: K, listener: (this: TextTrackList, ev: TextTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof TextTrackListEventMap>(type: K, listener: (this: TextTrackList, ev: TextTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    [index: number]: TextTrack;\n}\n\ndeclare var TextTrackList: {\n    prototype: TextTrackList;\n    new(): TextTrackList;\n};\n\ninterface TimeRanges {\n    readonly length: number;\n    end(index: number): number;\n    start(index: number): number;\n}\n\ndeclare var TimeRanges: {\n    prototype: TimeRanges;\n    new(): TimeRanges;\n};\n\ninterface Touch {\n    readonly altitudeAngle: number;\n    readonly azimuthAngle: number;\n    readonly clientX: number;\n    readonly clientY: number;\n    readonly force: number;\n    readonly identifier: number;\n    readonly pageX: number;\n    readonly pageY: number;\n    readonly radiusX: number;\n    readonly radiusY: number;\n    readonly rotationAngle: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly target: EventTarget;\n    readonly touchType: TouchType;\n}\n\ndeclare var Touch: {\n    prototype: Touch;\n    new(touchInitDict: TouchInit): Touch;\n};\n\ninterface TouchEvent extends UIEvent {\n    readonly altKey: boolean;\n    readonly changedTouches: TouchList;\n    readonly ctrlKey: boolean;\n    readonly metaKey: boolean;\n    readonly shiftKey: boolean;\n    readonly targetTouches: TouchList;\n    readonly touches: TouchList;\n}\n\ndeclare var TouchEvent: {\n    prototype: TouchEvent;\n    new(type: string, eventInitDict?: TouchEventInit): TouchEvent;\n};\n\ninterface TouchList {\n    readonly length: number;\n    item(index: number): Touch | null;\n    [index: number]: Touch;\n}\n\ndeclare var TouchList: {\n    prototype: TouchList;\n    new(): TouchList;\n};\n\ninterface TrackEvent extends Event {\n    readonly track: VideoTrack | AudioTrack | TextTrack | null;\n}\n\ndeclare var TrackEvent: {\n    prototype: TrackEvent;\n    new(typeArg: string, eventInitDict?: TrackEventInit): TrackEvent;\n};\n\ninterface TransformStream<I = any, O = any> {\n    readonly readable: ReadableStream<O>;\n    readonly writable: WritableStream<I>;\n}\n\ndeclare var TransformStream: {\n    prototype: TransformStream;\n    new<I = any, O = any>(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>): TransformStream<I, O>;\n};\n\ninterface TransformStreamDefaultController<O = any> {\n    readonly desiredSize: number | null;\n    enqueue(chunk: O): void;\n    error(reason?: any): void;\n    terminate(): void;\n}\n\ninterface TransitionEvent extends Event {\n    readonly elapsedTime: number;\n    readonly propertyName: string;\n    readonly pseudoElement: string;\n}\n\ndeclare var TransitionEvent: {\n    prototype: TransitionEvent;\n    new(type: string, transitionEventInitDict?: TransitionEventInit): TransitionEvent;\n};\n\ninterface TreeWalker {\n    currentNode: Node;\n    readonly filter: NodeFilter | null;\n    readonly root: Node;\n    readonly whatToShow: number;\n    firstChild(): Node | null;\n    lastChild(): Node | null;\n    nextNode(): Node | null;\n    nextSibling(): Node | null;\n    parentNode(): Node | null;\n    previousNode(): Node | null;\n    previousSibling(): Node | null;\n}\n\ndeclare var TreeWalker: {\n    prototype: TreeWalker;\n    new(): TreeWalker;\n};\n\ninterface UIEvent extends Event {\n    readonly detail: number;\n    readonly view: Window;\n    initUIEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number): void;\n}\n\ndeclare var UIEvent: {\n    prototype: UIEvent;\n    new(typeArg: string, eventInitDict?: UIEventInit): UIEvent;\n};\n\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    readonly searchParams: URLSearchParams;\n    username: string;\n    toJSON(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string | URL): URL;\n    createObjectURL(object: any): string;\n    revokeObjectURL(url: string): void;\n};\n\ntype webkitURL = URL;\ndeclare var webkitURL: typeof URL;\n\ninterface URLSearchParams {\n    /**\n     * Appends a specified key/value pair as a new search parameter.\n     */\n    append(name: string, value: string): void;\n    /**\n     * Deletes the given search parameter, and its associated value, from the list of all search parameters.\n     */\n    delete(name: string): void;\n    /**\n     * Returns the first value associated to the given search parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Returns all the values association with a given search parameter.\n     */\n    getAll(name: string): string[];\n    /**\n     * Returns a Boolean indicating if such a search parameter exists.\n     */\n    has(name: string): boolean;\n    /**\n     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.\n     */\n    set(name: string, value: string): void;\n    sort(): void;\n    forEach(callbackfn: (value: string, key: string, parent: URLSearchParams) => void, thisArg?: any): void;\n}\n\ndeclare var URLSearchParams: {\n    prototype: URLSearchParams;\n    new(init?: string[][] | Record<string, string> | string | URLSearchParams): URLSearchParams;\n};\n\ninterface VRDisplay extends EventTarget {\n    readonly capabilities: VRDisplayCapabilities;\n    depthFar: number;\n    depthNear: number;\n    readonly displayId: number;\n    readonly displayName: string;\n    readonly isConnected: boolean;\n    readonly isPresenting: boolean;\n    readonly stageParameters: VRStageParameters | null;\n    cancelAnimationFrame(handle: number): void;\n    exitPresent(): Promise<void>;\n    getEyeParameters(whichEye: string): VREyeParameters;\n    getFrameData(frameData: VRFrameData): boolean;\n    getLayers(): VRLayer[];\n    /** @deprecated */\n    getPose(): VRPose;\n    requestAnimationFrame(callback: FrameRequestCallback): number;\n    requestPresent(layers: VRLayer[]): Promise<void>;\n    resetPose(): void;\n    submitFrame(pose?: VRPose): void;\n}\n\ndeclare var VRDisplay: {\n    prototype: VRDisplay;\n    new(): VRDisplay;\n};\n\ninterface VRDisplayCapabilities {\n    readonly canPresent: boolean;\n    readonly hasExternalDisplay: boolean;\n    readonly hasOrientation: boolean;\n    readonly hasPosition: boolean;\n    readonly maxLayers: number;\n}\n\ndeclare var VRDisplayCapabilities: {\n    prototype: VRDisplayCapabilities;\n    new(): VRDisplayCapabilities;\n};\n\ninterface VRDisplayEvent extends Event {\n    readonly display: VRDisplay;\n    readonly reason: VRDisplayEventReason | null;\n}\n\ndeclare var VRDisplayEvent: {\n    prototype: VRDisplayEvent;\n    new(type: string, eventInitDict: VRDisplayEventInit): VRDisplayEvent;\n};\n\ninterface VREyeParameters {\n    /** @deprecated */\n    readonly fieldOfView: VRFieldOfView;\n    readonly offset: Float32Array;\n    readonly renderHeight: number;\n    readonly renderWidth: number;\n}\n\ndeclare var VREyeParameters: {\n    prototype: VREyeParameters;\n    new(): VREyeParameters;\n};\n\ninterface VRFieldOfView {\n    readonly downDegrees: number;\n    readonly leftDegrees: number;\n    readonly rightDegrees: number;\n    readonly upDegrees: number;\n}\n\ndeclare var VRFieldOfView: {\n    prototype: VRFieldOfView;\n    new(): VRFieldOfView;\n};\n\ninterface VRFrameData {\n    readonly leftProjectionMatrix: Float32Array;\n    readonly leftViewMatrix: Float32Array;\n    readonly pose: VRPose;\n    readonly rightProjectionMatrix: Float32Array;\n    readonly rightViewMatrix: Float32Array;\n    readonly timestamp: number;\n}\n\ndeclare var VRFrameData: {\n    prototype: VRFrameData;\n    new(): VRFrameData;\n};\n\ninterface VRPose {\n    readonly angularAcceleration: Float32Array | null;\n    readonly angularVelocity: Float32Array | null;\n    readonly linearAcceleration: Float32Array | null;\n    readonly linearVelocity: Float32Array | null;\n    readonly orientation: Float32Array | null;\n    readonly position: Float32Array | null;\n    readonly timestamp: number;\n}\n\ndeclare var VRPose: {\n    prototype: VRPose;\n    new(): VRPose;\n};\n\ninterface VTTCue extends TextTrackCue {\n    align: AlignSetting;\n    line: LineAndPositionSetting;\n    lineAlign: LineAlignSetting;\n    position: LineAndPositionSetting;\n    positionAlign: PositionAlignSetting;\n    region: VTTRegion | null;\n    size: number;\n    snapToLines: boolean;\n    text: string;\n    vertical: DirectionSetting;\n    getCueAsHTML(): DocumentFragment;\n    addEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: VTTCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof TextTrackCueEventMap>(type: K, listener: (this: VTTCue, ev: TextTrackCueEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var VTTCue: {\n    prototype: VTTCue;\n    new(startTime: number, endTime: number, text: string): VTTCue;\n};\n\ninterface VTTRegion {\n    id: string;\n    lines: number;\n    regionAnchorX: number;\n    regionAnchorY: number;\n    scroll: ScrollSetting;\n    viewportAnchorX: number;\n    viewportAnchorY: number;\n    width: number;\n}\n\ndeclare var VTTRegion: {\n    prototype: VTTRegion;\n    new(): VTTRegion;\n};\n\ninterface ValidityState {\n    readonly badInput: boolean;\n    readonly customError: boolean;\n    readonly patternMismatch: boolean;\n    readonly rangeOverflow: boolean;\n    readonly rangeUnderflow: boolean;\n    readonly stepMismatch: boolean;\n    readonly tooLong: boolean;\n    readonly tooShort: boolean;\n    readonly typeMismatch: boolean;\n    readonly valid: boolean;\n    readonly valueMissing: boolean;\n}\n\ndeclare var ValidityState: {\n    prototype: ValidityState;\n    new(): ValidityState;\n};\n\ninterface VideoPlaybackQuality {\n    readonly corruptedVideoFrames: number;\n    readonly creationTime: number;\n    readonly droppedVideoFrames: number;\n    readonly totalFrameDelay: number;\n    readonly totalVideoFrames: number;\n}\n\ndeclare var VideoPlaybackQuality: {\n    prototype: VideoPlaybackQuality;\n    new(): VideoPlaybackQuality;\n};\n\ninterface VideoTrack {\n    readonly id: string;\n    kind: string;\n    readonly label: string;\n    language: string;\n    selected: boolean;\n    readonly sourceBuffer: SourceBuffer;\n}\n\ndeclare var VideoTrack: {\n    prototype: VideoTrack;\n    new(): VideoTrack;\n};\n\ninterface VideoTrackListEventMap {\n    "addtrack": TrackEvent;\n    "change": Event;\n    "removetrack": TrackEvent;\n}\n\ninterface VideoTrackList extends EventTarget {\n    readonly length: number;\n    onaddtrack: ((this: VideoTrackList, ev: TrackEvent) => any) | null;\n    onchange: ((this: VideoTrackList, ev: Event) => any) | null;\n    onremovetrack: ((this: VideoTrackList, ev: TrackEvent) => any) | null;\n    readonly selectedIndex: number;\n    getTrackById(id: string): VideoTrack | null;\n    item(index: number): VideoTrack;\n    addEventListener<K extends keyof VideoTrackListEventMap>(type: K, listener: (this: VideoTrackList, ev: VideoTrackListEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof VideoTrackListEventMap>(type: K, listener: (this: VideoTrackList, ev: VideoTrackListEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    [index: number]: VideoTrack;\n}\n\ndeclare var VideoTrackList: {\n    prototype: VideoTrackList;\n    new(): VideoTrackList;\n};\n\ninterface WEBGL_color_buffer_float {\n    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: GLenum;\n    readonly RGBA32F_EXT: GLenum;\n    readonly UNSIGNED_NORMALIZED_EXT: GLenum;\n}\n\ninterface WEBGL_compressed_texture_astc {\n    getSupportedProfiles(): string[];\n    readonly COMPRESSED_RGBA_ASTC_10x10_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x8_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_12x10_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_12x12_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_4x4_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_5x4_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_5x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_6x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_6x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x8_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: GLenum;\n}\n\ninterface WEBGL_compressed_texture_s3tc {\n    readonly COMPRESSED_RGBA_S3TC_DXT1_EXT: GLenum;\n    readonly COMPRESSED_RGBA_S3TC_DXT3_EXT: GLenum;\n    readonly COMPRESSED_RGBA_S3TC_DXT5_EXT: GLenum;\n    readonly COMPRESSED_RGB_S3TC_DXT1_EXT: GLenum;\n}\n\ninterface WEBGL_compressed_texture_s3tc_srgb {\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: GLenum;\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: GLenum;\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: GLenum;\n    readonly COMPRESSED_SRGB_S3TC_DXT1_EXT: GLenum;\n}\n\ninterface WEBGL_debug_renderer_info {\n    readonly UNMASKED_RENDERER_WEBGL: GLenum;\n    readonly UNMASKED_VENDOR_WEBGL: GLenum;\n}\n\ninterface WEBGL_debug_shaders {\n    getTranslatedShaderSource(shader: WebGLShader): string;\n}\n\ninterface WEBGL_depth_texture {\n    readonly UNSIGNED_INT_24_8_WEBGL: GLenum;\n}\n\ninterface WEBGL_draw_buffers {\n    drawBuffersWEBGL(buffers: GLenum[]): void;\n    readonly COLOR_ATTACHMENT0_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT10_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT11_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT12_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT13_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT14_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT15_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT1_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT2_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT3_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT4_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT5_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT6_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT7_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT8_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT9_WEBGL: GLenum;\n    readonly DRAW_BUFFER0_WEBGL: GLenum;\n    readonly DRAW_BUFFER10_WEBGL: GLenum;\n    readonly DRAW_BUFFER11_WEBGL: GLenum;\n    readonly DRAW_BUFFER12_WEBGL: GLenum;\n    readonly DRAW_BUFFER13_WEBGL: GLenum;\n    readonly DRAW_BUFFER14_WEBGL: GLenum;\n    readonly DRAW_BUFFER15_WEBGL: GLenum;\n    readonly DRAW_BUFFER1_WEBGL: GLenum;\n    readonly DRAW_BUFFER2_WEBGL: GLenum;\n    readonly DRAW_BUFFER3_WEBGL: GLenum;\n    readonly DRAW_BUFFER4_WEBGL: GLenum;\n    readonly DRAW_BUFFER5_WEBGL: GLenum;\n    readonly DRAW_BUFFER6_WEBGL: GLenum;\n    readonly DRAW_BUFFER7_WEBGL: GLenum;\n    readonly DRAW_BUFFER8_WEBGL: GLenum;\n    readonly DRAW_BUFFER9_WEBGL: GLenum;\n    readonly MAX_COLOR_ATTACHMENTS_WEBGL: GLenum;\n    readonly MAX_DRAW_BUFFERS_WEBGL: GLenum;\n}\n\ninterface WEBGL_lose_context {\n    loseContext(): void;\n    restoreContext(): void;\n}\n\ninterface WaveShaperNode extends AudioNode {\n    curve: Float32Array | null;\n    oversample: OverSampleType;\n}\n\ndeclare var WaveShaperNode: {\n    prototype: WaveShaperNode;\n    new(context: BaseAudioContext, options?: WaveShaperOptions): WaveShaperNode;\n};\n\ninterface WebAuthentication {\n    getAssertion(assertionChallenge: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null, options?: AssertionOptions): Promise<WebAuthnAssertion>;\n    makeCredential(accountInformation: Account, cryptoParameters: ScopedCredentialParameters[], attestationChallenge: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null, options?: ScopedCredentialOptions): Promise<ScopedCredentialInfo>;\n}\n\ndeclare var WebAuthentication: {\n    prototype: WebAuthentication;\n    new(): WebAuthentication;\n};\n\ninterface WebAuthnAssertion {\n    readonly authenticatorData: ArrayBuffer;\n    readonly clientData: ArrayBuffer;\n    readonly credential: ScopedCredential;\n    readonly signature: ArrayBuffer;\n}\n\ndeclare var WebAuthnAssertion: {\n    prototype: WebAuthnAssertion;\n    new(): WebAuthnAssertion;\n};\n\ninterface WebGLActiveInfo {\n    readonly name: string;\n    readonly size: GLint;\n    readonly type: GLenum;\n}\n\ndeclare var WebGLActiveInfo: {\n    prototype: WebGLActiveInfo;\n    new(): WebGLActiveInfo;\n};\n\ninterface WebGLBuffer extends WebGLObject {\n}\n\ndeclare var WebGLBuffer: {\n    prototype: WebGLBuffer;\n    new(): WebGLBuffer;\n};\n\ninterface WebGLContextEvent extends Event {\n    readonly statusMessage: string;\n}\n\ndeclare var WebGLContextEvent: {\n    prototype: WebGLContextEvent;\n    new(type: string, eventInit?: WebGLContextEventInit): WebGLContextEvent;\n};\n\ninterface WebGLFramebuffer extends WebGLObject {\n}\n\ndeclare var WebGLFramebuffer: {\n    prototype: WebGLFramebuffer;\n    new(): WebGLFramebuffer;\n};\n\ninterface WebGLObject {\n}\n\ndeclare var WebGLObject: {\n    prototype: WebGLObject;\n    new(): WebGLObject;\n};\n\ninterface WebGLProgram extends WebGLObject {\n}\n\ndeclare var WebGLProgram: {\n    prototype: WebGLProgram;\n    new(): WebGLProgram;\n};\n\ninterface WebGLRenderbuffer extends WebGLObject {\n}\n\ndeclare var WebGLRenderbuffer: {\n    prototype: WebGLRenderbuffer;\n    new(): WebGLRenderbuffer;\n};\n\ninterface WebGLRenderingContext extends WebGLRenderingContextBase {\n}\n\ndeclare var WebGLRenderingContext: {\n    prototype: WebGLRenderingContext;\n    new(): WebGLRenderingContext;\n    readonly ACTIVE_ATTRIBUTES: GLenum;\n    readonly ACTIVE_TEXTURE: GLenum;\n    readonly ACTIVE_UNIFORMS: GLenum;\n    readonly ALIASED_LINE_WIDTH_RANGE: GLenum;\n    readonly ALIASED_POINT_SIZE_RANGE: GLenum;\n    readonly ALPHA: GLenum;\n    readonly ALPHA_BITS: GLenum;\n    readonly ALWAYS: GLenum;\n    readonly ARRAY_BUFFER: GLenum;\n    readonly ARRAY_BUFFER_BINDING: GLenum;\n    readonly ATTACHED_SHADERS: GLenum;\n    readonly BACK: GLenum;\n    readonly BLEND: GLenum;\n    readonly BLEND_COLOR: GLenum;\n    readonly BLEND_DST_ALPHA: GLenum;\n    readonly BLEND_DST_RGB: GLenum;\n    readonly BLEND_EQUATION: GLenum;\n    readonly BLEND_EQUATION_ALPHA: GLenum;\n    readonly BLEND_EQUATION_RGB: GLenum;\n    readonly BLEND_SRC_ALPHA: GLenum;\n    readonly BLEND_SRC_RGB: GLenum;\n    readonly BLUE_BITS: GLenum;\n    readonly BOOL: GLenum;\n    readonly BOOL_VEC2: GLenum;\n    readonly BOOL_VEC3: GLenum;\n    readonly BOOL_VEC4: GLenum;\n    readonly BROWSER_DEFAULT_WEBGL: GLenum;\n    readonly BUFFER_SIZE: GLenum;\n    readonly BUFFER_USAGE: GLenum;\n    readonly BYTE: GLenum;\n    readonly CCW: GLenum;\n    readonly CLAMP_TO_EDGE: GLenum;\n    readonly COLOR_ATTACHMENT0: GLenum;\n    readonly COLOR_BUFFER_BIT: GLenum;\n    readonly COLOR_CLEAR_VALUE: GLenum;\n    readonly COLOR_WRITEMASK: GLenum;\n    readonly COMPILE_STATUS: GLenum;\n    readonly COMPRESSED_TEXTURE_FORMATS: GLenum;\n    readonly CONSTANT_ALPHA: GLenum;\n    readonly CONSTANT_COLOR: GLenum;\n    readonly CONTEXT_LOST_WEBGL: GLenum;\n    readonly CULL_FACE: GLenum;\n    readonly CULL_FACE_MODE: GLenum;\n    readonly CURRENT_PROGRAM: GLenum;\n    readonly CURRENT_VERTEX_ATTRIB: GLenum;\n    readonly CW: GLenum;\n    readonly DECR: GLenum;\n    readonly DECR_WRAP: GLenum;\n    readonly DELETE_STATUS: GLenum;\n    readonly DEPTH_ATTACHMENT: GLenum;\n    readonly DEPTH_BITS: GLenum;\n    readonly DEPTH_BUFFER_BIT: GLenum;\n    readonly DEPTH_CLEAR_VALUE: GLenum;\n    readonly DEPTH_COMPONENT: GLenum;\n    readonly DEPTH_COMPONENT16: GLenum;\n    readonly DEPTH_FUNC: GLenum;\n    readonly DEPTH_RANGE: GLenum;\n    readonly DEPTH_STENCIL: GLenum;\n    readonly DEPTH_STENCIL_ATTACHMENT: GLenum;\n    readonly DEPTH_TEST: GLenum;\n    readonly DEPTH_WRITEMASK: GLenum;\n    readonly DITHER: GLenum;\n    readonly DONT_CARE: GLenum;\n    readonly DST_ALPHA: GLenum;\n    readonly DST_COLOR: GLenum;\n    readonly DYNAMIC_DRAW: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: GLenum;\n    readonly EQUAL: GLenum;\n    readonly FASTEST: GLenum;\n    readonly FLOAT: GLenum;\n    readonly FLOAT_MAT2: GLenum;\n    readonly FLOAT_MAT3: GLenum;\n    readonly FLOAT_MAT4: GLenum;\n    readonly FLOAT_VEC2: GLenum;\n    readonly FLOAT_VEC3: GLenum;\n    readonly FLOAT_VEC4: GLenum;\n    readonly FRAGMENT_SHADER: GLenum;\n    readonly FRAMEBUFFER: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum;\n    readonly FRAMEBUFFER_BINDING: GLenum;\n    readonly FRAMEBUFFER_COMPLETE: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_UNSUPPORTED: GLenum;\n    readonly FRONT: GLenum;\n    readonly FRONT_AND_BACK: GLenum;\n    readonly FRONT_FACE: GLenum;\n    readonly FUNC_ADD: GLenum;\n    readonly FUNC_REVERSE_SUBTRACT: GLenum;\n    readonly FUNC_SUBTRACT: GLenum;\n    readonly GENERATE_MIPMAP_HINT: GLenum;\n    readonly GEQUAL: GLenum;\n    readonly GREATER: GLenum;\n    readonly GREEN_BITS: GLenum;\n    readonly HIGH_FLOAT: GLenum;\n    readonly HIGH_INT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: GLenum;\n    readonly INCR: GLenum;\n    readonly INCR_WRAP: GLenum;\n    readonly INT: GLenum;\n    readonly INT_VEC2: GLenum;\n    readonly INT_VEC3: GLenum;\n    readonly INT_VEC4: GLenum;\n    readonly INVALID_ENUM: GLenum;\n    readonly INVALID_FRAMEBUFFER_OPERATION: GLenum;\n    readonly INVALID_OPERATION: GLenum;\n    readonly INVALID_VALUE: GLenum;\n    readonly INVERT: GLenum;\n    readonly KEEP: GLenum;\n    readonly LEQUAL: GLenum;\n    readonly LESS: GLenum;\n    readonly LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_NEAREST: GLenum;\n    readonly LINES: GLenum;\n    readonly LINE_LOOP: GLenum;\n    readonly LINE_STRIP: GLenum;\n    readonly LINE_WIDTH: GLenum;\n    readonly LINK_STATUS: GLenum;\n    readonly LOW_FLOAT: GLenum;\n    readonly LOW_INT: GLenum;\n    readonly LUMINANCE: GLenum;\n    readonly LUMINANCE_ALPHA: GLenum;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: GLenum;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: GLenum;\n    readonly MAX_RENDERBUFFER_SIZE: GLenum;\n    readonly MAX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_TEXTURE_SIZE: GLenum;\n    readonly MAX_VARYING_VECTORS: GLenum;\n    readonly MAX_VERTEX_ATTRIBS: GLenum;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: GLenum;\n    readonly MAX_VIEWPORT_DIMS: GLenum;\n    readonly MEDIUM_FLOAT: GLenum;\n    readonly MEDIUM_INT: GLenum;\n    readonly MIRRORED_REPEAT: GLenum;\n    readonly NEAREST: GLenum;\n    readonly NEAREST_MIPMAP_LINEAR: GLenum;\n    readonly NEAREST_MIPMAP_NEAREST: GLenum;\n    readonly NEVER: GLenum;\n    readonly NICEST: GLenum;\n    readonly NONE: GLenum;\n    readonly NOTEQUAL: GLenum;\n    readonly NO_ERROR: GLenum;\n    readonly ONE: GLenum;\n    readonly ONE_MINUS_CONSTANT_ALPHA: GLenum;\n    readonly ONE_MINUS_CONSTANT_COLOR: GLenum;\n    readonly ONE_MINUS_DST_ALPHA: GLenum;\n    readonly ONE_MINUS_DST_COLOR: GLenum;\n    readonly ONE_MINUS_SRC_ALPHA: GLenum;\n    readonly ONE_MINUS_SRC_COLOR: GLenum;\n    readonly OUT_OF_MEMORY: GLenum;\n    readonly PACK_ALIGNMENT: GLenum;\n    readonly POINTS: GLenum;\n    readonly POLYGON_OFFSET_FACTOR: GLenum;\n    readonly POLYGON_OFFSET_FILL: GLenum;\n    readonly POLYGON_OFFSET_UNITS: GLenum;\n    readonly RED_BITS: GLenum;\n    readonly RENDERBUFFER: GLenum;\n    readonly RENDERBUFFER_ALPHA_SIZE: GLenum;\n    readonly RENDERBUFFER_BINDING: GLenum;\n    readonly RENDERBUFFER_BLUE_SIZE: GLenum;\n    readonly RENDERBUFFER_DEPTH_SIZE: GLenum;\n    readonly RENDERBUFFER_GREEN_SIZE: GLenum;\n    readonly RENDERBUFFER_HEIGHT: GLenum;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: GLenum;\n    readonly RENDERBUFFER_RED_SIZE: GLenum;\n    readonly RENDERBUFFER_STENCIL_SIZE: GLenum;\n    readonly RENDERBUFFER_WIDTH: GLenum;\n    readonly RENDERER: GLenum;\n    readonly REPEAT: GLenum;\n    readonly REPLACE: GLenum;\n    readonly RGB: GLenum;\n    readonly RGB565: GLenum;\n    readonly RGB5_A1: GLenum;\n    readonly RGBA: GLenum;\n    readonly RGBA4: GLenum;\n    readonly SAMPLER_2D: GLenum;\n    readonly SAMPLER_CUBE: GLenum;\n    readonly SAMPLES: GLenum;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: GLenum;\n    readonly SAMPLE_BUFFERS: GLenum;\n    readonly SAMPLE_COVERAGE: GLenum;\n    readonly SAMPLE_COVERAGE_INVERT: GLenum;\n    readonly SAMPLE_COVERAGE_VALUE: GLenum;\n    readonly SCISSOR_BOX: GLenum;\n    readonly SCISSOR_TEST: GLenum;\n    readonly SHADER_TYPE: GLenum;\n    readonly SHADING_LANGUAGE_VERSION: GLenum;\n    readonly SHORT: GLenum;\n    readonly SRC_ALPHA: GLenum;\n    readonly SRC_ALPHA_SATURATE: GLenum;\n    readonly SRC_COLOR: GLenum;\n    readonly STATIC_DRAW: GLenum;\n    readonly STENCIL_ATTACHMENT: GLenum;\n    readonly STENCIL_BACK_FAIL: GLenum;\n    readonly STENCIL_BACK_FUNC: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_BACK_REF: GLenum;\n    readonly STENCIL_BACK_VALUE_MASK: GLenum;\n    readonly STENCIL_BACK_WRITEMASK: GLenum;\n    readonly STENCIL_BITS: GLenum;\n    readonly STENCIL_BUFFER_BIT: GLenum;\n    readonly STENCIL_CLEAR_VALUE: GLenum;\n    readonly STENCIL_FAIL: GLenum;\n    readonly STENCIL_FUNC: GLenum;\n    readonly STENCIL_INDEX8: GLenum;\n    readonly STENCIL_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_REF: GLenum;\n    readonly STENCIL_TEST: GLenum;\n    readonly STENCIL_VALUE_MASK: GLenum;\n    readonly STENCIL_WRITEMASK: GLenum;\n    readonly STREAM_DRAW: GLenum;\n    readonly SUBPIXEL_BITS: GLenum;\n    readonly TEXTURE: GLenum;\n    readonly TEXTURE0: GLenum;\n    readonly TEXTURE1: GLenum;\n    readonly TEXTURE10: GLenum;\n    readonly TEXTURE11: GLenum;\n    readonly TEXTURE12: GLenum;\n    readonly TEXTURE13: GLenum;\n    readonly TEXTURE14: GLenum;\n    readonly TEXTURE15: GLenum;\n    readonly TEXTURE16: GLenum;\n    readonly TEXTURE17: GLenum;\n    readonly TEXTURE18: GLenum;\n    readonly TEXTURE19: GLenum;\n    readonly TEXTURE2: GLenum;\n    readonly TEXTURE20: GLenum;\n    readonly TEXTURE21: GLenum;\n    readonly TEXTURE22: GLenum;\n    readonly TEXTURE23: GLenum;\n    readonly TEXTURE24: GLenum;\n    readonly TEXTURE25: GLenum;\n    readonly TEXTURE26: GLenum;\n    readonly TEXTURE27: GLenum;\n    readonly TEXTURE28: GLenum;\n    readonly TEXTURE29: GLenum;\n    readonly TEXTURE3: GLenum;\n    readonly TEXTURE30: GLenum;\n    readonly TEXTURE31: GLenum;\n    readonly TEXTURE4: GLenum;\n    readonly TEXTURE5: GLenum;\n    readonly TEXTURE6: GLenum;\n    readonly TEXTURE7: GLenum;\n    readonly TEXTURE8: GLenum;\n    readonly TEXTURE9: GLenum;\n    readonly TEXTURE_2D: GLenum;\n    readonly TEXTURE_BINDING_2D: GLenum;\n    readonly TEXTURE_BINDING_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum;\n    readonly TEXTURE_MAG_FILTER: GLenum;\n    readonly TEXTURE_MIN_FILTER: GLenum;\n    readonly TEXTURE_WRAP_S: GLenum;\n    readonly TEXTURE_WRAP_T: GLenum;\n    readonly TRIANGLES: GLenum;\n    readonly TRIANGLE_FAN: GLenum;\n    readonly TRIANGLE_STRIP: GLenum;\n    readonly UNPACK_ALIGNMENT: GLenum;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum;\n    readonly UNPACK_FLIP_Y_WEBGL: GLenum;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum;\n    readonly UNSIGNED_BYTE: GLenum;\n    readonly UNSIGNED_INT: GLenum;\n    readonly UNSIGNED_SHORT: GLenum;\n    readonly UNSIGNED_SHORT_4_4_4_4: GLenum;\n    readonly UNSIGNED_SHORT_5_5_5_1: GLenum;\n    readonly UNSIGNED_SHORT_5_6_5: GLenum;\n    readonly VALIDATE_STATUS: GLenum;\n    readonly VENDOR: GLenum;\n    readonly VERSION: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: GLenum;\n    readonly VERTEX_SHADER: GLenum;\n    readonly VIEWPORT: GLenum;\n    readonly ZERO: GLenum;\n};\n\ninterface WebGLRenderingContextBase {\n    readonly canvas: HTMLCanvasElement;\n    readonly drawingBufferHeight: GLsizei;\n    readonly drawingBufferWidth: GLsizei;\n    activeTexture(texture: GLenum): void;\n    attachShader(program: WebGLProgram, shader: WebGLShader): void;\n    bindAttribLocation(program: WebGLProgram, index: GLuint, name: string): void;\n    bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void;\n    bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer | null): void;\n    bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer | null): void;\n    bindTexture(target: GLenum, texture: WebGLTexture | null): void;\n    blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\n    blendEquation(mode: GLenum): void;\n    blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void;\n    blendFunc(sfactor: GLenum, dfactor: GLenum): void;\n    blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;\n    bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum): void;\n    bufferData(target: GLenum, data: BufferSource | null, usage: GLenum): void;\n    bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource): void;\n    checkFramebufferStatus(target: GLenum): GLenum;\n    clear(mask: GLbitfield): void;\n    clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\n    clearDepth(depth: GLclampf): void;\n    clearStencil(s: GLint): void;\n    colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;\n    compileShader(shader: WebGLShader): void;\n    compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;\n    compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;\n    copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;\n    copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    createBuffer(): WebGLBuffer | null;\n    createFramebuffer(): WebGLFramebuffer | null;\n    createProgram(): WebGLProgram | null;\n    createRenderbuffer(): WebGLRenderbuffer | null;\n    createShader(type: GLenum): WebGLShader | null;\n    createTexture(): WebGLTexture | null;\n    cullFace(mode: GLenum): void;\n    deleteBuffer(buffer: WebGLBuffer | null): void;\n    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;\n    deleteProgram(program: WebGLProgram | null): void;\n    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;\n    deleteShader(shader: WebGLShader | null): void;\n    deleteTexture(texture: WebGLTexture | null): void;\n    depthFunc(func: GLenum): void;\n    depthMask(flag: GLboolean): void;\n    depthRange(zNear: GLclampf, zFar: GLclampf): void;\n    detachShader(program: WebGLProgram, shader: WebGLShader): void;\n    disable(cap: GLenum): void;\n    disableVertexAttribArray(index: GLuint): void;\n    drawArrays(mode: GLenum, first: GLint, count: GLsizei): void;\n    drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr): void;\n    enable(cap: GLenum): void;\n    enableVertexAttribArray(index: GLuint): void;\n    finish(): void;\n    flush(): void;\n    framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer | null): void;\n    framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture | null, level: GLint): void;\n    frontFace(mode: GLenum): void;\n    generateMipmap(target: GLenum): void;\n    getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;\n    getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;\n    getAttachedShaders(program: WebGLProgram): WebGLShader[] | null;\n    getAttribLocation(program: WebGLProgram, name: string): GLint;\n    getBufferParameter(target: GLenum, pname: GLenum): any;\n    getContextAttributes(): WebGLContextAttributes | null;\n    getError(): GLenum;\n    getExtension(extensionName: "EXT_blend_minmax"): EXT_blend_minmax | null;\n    getExtension(extensionName: "EXT_texture_filter_anisotropic"): EXT_texture_filter_anisotropic | null;\n    getExtension(extensionName: "EXT_frag_depth"): EXT_frag_depth | null;\n    getExtension(extensionName: "EXT_shader_texture_lod"): EXT_shader_texture_lod | null;\n    getExtension(extensionName: "EXT_sRGB"): EXT_sRGB | null;\n    getExtension(extensionName: "OES_vertex_array_object"): OES_vertex_array_object | null;\n    getExtension(extensionName: "WEBGL_color_buffer_float"): WEBGL_color_buffer_float | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_astc"): WEBGL_compressed_texture_astc | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_s3tc_srgb"): WEBGL_compressed_texture_s3tc_srgb | null;\n    getExtension(extensionName: "WEBGL_debug_shaders"): WEBGL_debug_shaders | null;\n    getExtension(extensionName: "WEBGL_draw_buffers"): WEBGL_draw_buffers | null;\n    getExtension(extensionName: "WEBGL_lose_context"): WEBGL_lose_context | null;\n    getExtension(extensionName: "WEBGL_depth_texture"): WEBGL_depth_texture | null;\n    getExtension(extensionName: "WEBGL_debug_renderer_info"): WEBGL_debug_renderer_info | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_s3tc"): WEBGL_compressed_texture_s3tc | null;\n    getExtension(extensionName: "OES_texture_half_float_linear"): OES_texture_half_float_linear | null;\n    getExtension(extensionName: "OES_texture_half_float"): OES_texture_half_float | null;\n    getExtension(extensionName: "OES_texture_float_linear"): OES_texture_float_linear | null;\n    getExtension(extensionName: "OES_texture_float"): OES_texture_float | null;\n    getExtension(extensionName: "OES_standard_derivatives"): OES_standard_derivatives | null;\n    getExtension(extensionName: "OES_element_index_uint"): OES_element_index_uint | null;\n    getExtension(extensionName: "ANGLE_instanced_arrays"): ANGLE_instanced_arrays | null;\n    getExtension(extensionName: string): any;\n    getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): any;\n    getParameter(pname: GLenum): any;\n    getProgramInfoLog(program: WebGLProgram): string | null;\n    getProgramParameter(program: WebGLProgram, pname: GLenum): any;\n    getRenderbufferParameter(target: GLenum, pname: GLenum): any;\n    getShaderInfoLog(shader: WebGLShader): string | null;\n    getShaderParameter(shader: WebGLShader, pname: GLenum): any;\n    getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat | null;\n    getShaderSource(shader: WebGLShader): string | null;\n    getSupportedExtensions(): string[] | null;\n    getTexParameter(target: GLenum, pname: GLenum): any;\n    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;\n    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation | null;\n    getVertexAttrib(index: GLuint, pname: GLenum): any;\n    getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr;\n    hint(target: GLenum, mode: GLenum): void;\n    isBuffer(buffer: WebGLBuffer | null): GLboolean;\n    isContextLost(): boolean;\n    isEnabled(cap: GLenum): GLboolean;\n    isFramebuffer(framebuffer: WebGLFramebuffer | null): GLboolean;\n    isProgram(program: WebGLProgram | null): GLboolean;\n    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): GLboolean;\n    isShader(shader: WebGLShader | null): GLboolean;\n    isTexture(texture: WebGLTexture | null): GLboolean;\n    lineWidth(width: GLfloat): void;\n    linkProgram(program: WebGLProgram): void;\n    pixelStorei(pname: GLenum, param: GLint): void;\n    polygonOffset(factor: GLfloat, units: GLfloat): void;\n    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void;\n    sampleCoverage(value: GLclampf, invert: GLboolean): void;\n    scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    shaderSource(shader: WebGLShader, source: string): void;\n    stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;\n    stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;\n    stencilMask(mask: GLuint): void;\n    stencilMaskSeparate(face: GLenum, mask: GLuint): void;\n    stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;\n    stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\n    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource): void;\n    texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void;\n    texParameteri(target: GLenum, pname: GLenum, param: GLint): void;\n    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource): void;\n    uniform1f(location: WebGLUniformLocation | null, x: GLfloat): void;\n    uniform1fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform1i(location: WebGLUniformLocation | null, x: GLint): void;\n    uniform1iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform2f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat): void;\n    uniform2fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform2i(location: WebGLUniformLocation | null, x: GLint, y: GLint): void;\n    uniform2iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform3f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat): void;\n    uniform3fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform3i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint): void;\n    uniform3iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform4f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\n    uniform4fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform4i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint, w: GLint): void;\n    uniform4iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    useProgram(program: WebGLProgram | null): void;\n    validateProgram(program: WebGLProgram): void;\n    vertexAttrib1f(index: GLuint, x: GLfloat): void;\n    vertexAttrib1fv(index: GLuint, values: Float32List): void;\n    vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat): void;\n    vertexAttrib2fv(index: GLuint, values: Float32List): void;\n    vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;\n    vertexAttrib3fv(index: GLuint, values: Float32List): void;\n    vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\n    vertexAttrib4fv(index: GLuint, values: Float32List): void;\n    vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void;\n    viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    readonly ACTIVE_ATTRIBUTES: GLenum;\n    readonly ACTIVE_TEXTURE: GLenum;\n    readonly ACTIVE_UNIFORMS: GLenum;\n    readonly ALIASED_LINE_WIDTH_RANGE: GLenum;\n    readonly ALIASED_POINT_SIZE_RANGE: GLenum;\n    readonly ALPHA: GLenum;\n    readonly ALPHA_BITS: GLenum;\n    readonly ALWAYS: GLenum;\n    readonly ARRAY_BUFFER: GLenum;\n    readonly ARRAY_BUFFER_BINDING: GLenum;\n    readonly ATTACHED_SHADERS: GLenum;\n    readonly BACK: GLenum;\n    readonly BLEND: GLenum;\n    readonly BLEND_COLOR: GLenum;\n    readonly BLEND_DST_ALPHA: GLenum;\n    readonly BLEND_DST_RGB: GLenum;\n    readonly BLEND_EQUATION: GLenum;\n    readonly BLEND_EQUATION_ALPHA: GLenum;\n    readonly BLEND_EQUATION_RGB: GLenum;\n    readonly BLEND_SRC_ALPHA: GLenum;\n    readonly BLEND_SRC_RGB: GLenum;\n    readonly BLUE_BITS: GLenum;\n    readonly BOOL: GLenum;\n    readonly BOOL_VEC2: GLenum;\n    readonly BOOL_VEC3: GLenum;\n    readonly BOOL_VEC4: GLenum;\n    readonly BROWSER_DEFAULT_WEBGL: GLenum;\n    readonly BUFFER_SIZE: GLenum;\n    readonly BUFFER_USAGE: GLenum;\n    readonly BYTE: GLenum;\n    readonly CCW: GLenum;\n    readonly CLAMP_TO_EDGE: GLenum;\n    readonly COLOR_ATTACHMENT0: GLenum;\n    readonly COLOR_BUFFER_BIT: GLenum;\n    readonly COLOR_CLEAR_VALUE: GLenum;\n    readonly COLOR_WRITEMASK: GLenum;\n    readonly COMPILE_STATUS: GLenum;\n    readonly COMPRESSED_TEXTURE_FORMATS: GLenum;\n    readonly CONSTANT_ALPHA: GLenum;\n    readonly CONSTANT_COLOR: GLenum;\n    readonly CONTEXT_LOST_WEBGL: GLenum;\n    readonly CULL_FACE: GLenum;\n    readonly CULL_FACE_MODE: GLenum;\n    readonly CURRENT_PROGRAM: GLenum;\n    readonly CURRENT_VERTEX_ATTRIB: GLenum;\n    readonly CW: GLenum;\n    readonly DECR: GLenum;\n    readonly DECR_WRAP: GLenum;\n    readonly DELETE_STATUS: GLenum;\n    readonly DEPTH_ATTACHMENT: GLenum;\n    readonly DEPTH_BITS: GLenum;\n    readonly DEPTH_BUFFER_BIT: GLenum;\n    readonly DEPTH_CLEAR_VALUE: GLenum;\n    readonly DEPTH_COMPONENT: GLenum;\n    readonly DEPTH_COMPONENT16: GLenum;\n    readonly DEPTH_FUNC: GLenum;\n    readonly DEPTH_RANGE: GLenum;\n    readonly DEPTH_STENCIL: GLenum;\n    readonly DEPTH_STENCIL_ATTACHMENT: GLenum;\n    readonly DEPTH_TEST: GLenum;\n    readonly DEPTH_WRITEMASK: GLenum;\n    readonly DITHER: GLenum;\n    readonly DONT_CARE: GLenum;\n    readonly DST_ALPHA: GLenum;\n    readonly DST_COLOR: GLenum;\n    readonly DYNAMIC_DRAW: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: GLenum;\n    readonly EQUAL: GLenum;\n    readonly FASTEST: GLenum;\n    readonly FLOAT: GLenum;\n    readonly FLOAT_MAT2: GLenum;\n    readonly FLOAT_MAT3: GLenum;\n    readonly FLOAT_MAT4: GLenum;\n    readonly FLOAT_VEC2: GLenum;\n    readonly FLOAT_VEC3: GLenum;\n    readonly FLOAT_VEC4: GLenum;\n    readonly FRAGMENT_SHADER: GLenum;\n    readonly FRAMEBUFFER: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum;\n    readonly FRAMEBUFFER_BINDING: GLenum;\n    readonly FRAMEBUFFER_COMPLETE: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_UNSUPPORTED: GLenum;\n    readonly FRONT: GLenum;\n    readonly FRONT_AND_BACK: GLenum;\n    readonly FRONT_FACE: GLenum;\n    readonly FUNC_ADD: GLenum;\n    readonly FUNC_REVERSE_SUBTRACT: GLenum;\n    readonly FUNC_SUBTRACT: GLenum;\n    readonly GENERATE_MIPMAP_HINT: GLenum;\n    readonly GEQUAL: GLenum;\n    readonly GREATER: GLenum;\n    readonly GREEN_BITS: GLenum;\n    readonly HIGH_FLOAT: GLenum;\n    readonly HIGH_INT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: GLenum;\n    readonly INCR: GLenum;\n    readonly INCR_WRAP: GLenum;\n    readonly INT: GLenum;\n    readonly INT_VEC2: GLenum;\n    readonly INT_VEC3: GLenum;\n    readonly INT_VEC4: GLenum;\n    readonly INVALID_ENUM: GLenum;\n    readonly INVALID_FRAMEBUFFER_OPERATION: GLenum;\n    readonly INVALID_OPERATION: GLenum;\n    readonly INVALID_VALUE: GLenum;\n    readonly INVERT: GLenum;\n    readonly KEEP: GLenum;\n    readonly LEQUAL: GLenum;\n    readonly LESS: GLenum;\n    readonly LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_NEAREST: GLenum;\n    readonly LINES: GLenum;\n    readonly LINE_LOOP: GLenum;\n    readonly LINE_STRIP: GLenum;\n    readonly LINE_WIDTH: GLenum;\n    readonly LINK_STATUS: GLenum;\n    readonly LOW_FLOAT: GLenum;\n    readonly LOW_INT: GLenum;\n    readonly LUMINANCE: GLenum;\n    readonly LUMINANCE_ALPHA: GLenum;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: GLenum;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: GLenum;\n    readonly MAX_RENDERBUFFER_SIZE: GLenum;\n    readonly MAX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_TEXTURE_SIZE: GLenum;\n    readonly MAX_VARYING_VECTORS: GLenum;\n    readonly MAX_VERTEX_ATTRIBS: GLenum;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: GLenum;\n    readonly MAX_VIEWPORT_DIMS: GLenum;\n    readonly MEDIUM_FLOAT: GLenum;\n    readonly MEDIUM_INT: GLenum;\n    readonly MIRRORED_REPEAT: GLenum;\n    readonly NEAREST: GLenum;\n    readonly NEAREST_MIPMAP_LINEAR: GLenum;\n    readonly NEAREST_MIPMAP_NEAREST: GLenum;\n    readonly NEVER: GLenum;\n    readonly NICEST: GLenum;\n    readonly NONE: GLenum;\n    readonly NOTEQUAL: GLenum;\n    readonly NO_ERROR: GLenum;\n    readonly ONE: GLenum;\n    readonly ONE_MINUS_CONSTANT_ALPHA: GLenum;\n    readonly ONE_MINUS_CONSTANT_COLOR: GLenum;\n    readonly ONE_MINUS_DST_ALPHA: GLenum;\n    readonly ONE_MINUS_DST_COLOR: GLenum;\n    readonly ONE_MINUS_SRC_ALPHA: GLenum;\n    readonly ONE_MINUS_SRC_COLOR: GLenum;\n    readonly OUT_OF_MEMORY: GLenum;\n    readonly PACK_ALIGNMENT: GLenum;\n    readonly POINTS: GLenum;\n    readonly POLYGON_OFFSET_FACTOR: GLenum;\n    readonly POLYGON_OFFSET_FILL: GLenum;\n    readonly POLYGON_OFFSET_UNITS: GLenum;\n    readonly RED_BITS: GLenum;\n    readonly RENDERBUFFER: GLenum;\n    readonly RENDERBUFFER_ALPHA_SIZE: GLenum;\n    readonly RENDERBUFFER_BINDING: GLenum;\n    readonly RENDERBUFFER_BLUE_SIZE: GLenum;\n    readonly RENDERBUFFER_DEPTH_SIZE: GLenum;\n    readonly RENDERBUFFER_GREEN_SIZE: GLenum;\n    readonly RENDERBUFFER_HEIGHT: GLenum;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: GLenum;\n    readonly RENDERBUFFER_RED_SIZE: GLenum;\n    readonly RENDERBUFFER_STENCIL_SIZE: GLenum;\n    readonly RENDERBUFFER_WIDTH: GLenum;\n    readonly RENDERER: GLenum;\n    readonly REPEAT: GLenum;\n    readonly REPLACE: GLenum;\n    readonly RGB: GLenum;\n    readonly RGB565: GLenum;\n    readonly RGB5_A1: GLenum;\n    readonly RGBA: GLenum;\n    readonly RGBA4: GLenum;\n    readonly SAMPLER_2D: GLenum;\n    readonly SAMPLER_CUBE: GLenum;\n    readonly SAMPLES: GLenum;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: GLenum;\n    readonly SAMPLE_BUFFERS: GLenum;\n    readonly SAMPLE_COVERAGE: GLenum;\n    readonly SAMPLE_COVERAGE_INVERT: GLenum;\n    readonly SAMPLE_COVERAGE_VALUE: GLenum;\n    readonly SCISSOR_BOX: GLenum;\n    readonly SCISSOR_TEST: GLenum;\n    readonly SHADER_TYPE: GLenum;\n    readonly SHADING_LANGUAGE_VERSION: GLenum;\n    readonly SHORT: GLenum;\n    readonly SRC_ALPHA: GLenum;\n    readonly SRC_ALPHA_SATURATE: GLenum;\n    readonly SRC_COLOR: GLenum;\n    readonly STATIC_DRAW: GLenum;\n    readonly STENCIL_ATTACHMENT: GLenum;\n    readonly STENCIL_BACK_FAIL: GLenum;\n    readonly STENCIL_BACK_FUNC: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_BACK_REF: GLenum;\n    readonly STENCIL_BACK_VALUE_MASK: GLenum;\n    readonly STENCIL_BACK_WRITEMASK: GLenum;\n    readonly STENCIL_BITS: GLenum;\n    readonly STENCIL_BUFFER_BIT: GLenum;\n    readonly STENCIL_CLEAR_VALUE: GLenum;\n    readonly STENCIL_FAIL: GLenum;\n    readonly STENCIL_FUNC: GLenum;\n    readonly STENCIL_INDEX8: GLenum;\n    readonly STENCIL_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_REF: GLenum;\n    readonly STENCIL_TEST: GLenum;\n    readonly STENCIL_VALUE_MASK: GLenum;\n    readonly STENCIL_WRITEMASK: GLenum;\n    readonly STREAM_DRAW: GLenum;\n    readonly SUBPIXEL_BITS: GLenum;\n    readonly TEXTURE: GLenum;\n    readonly TEXTURE0: GLenum;\n    readonly TEXTURE1: GLenum;\n    readonly TEXTURE10: GLenum;\n    readonly TEXTURE11: GLenum;\n    readonly TEXTURE12: GLenum;\n    readonly TEXTURE13: GLenum;\n    readonly TEXTURE14: GLenum;\n    readonly TEXTURE15: GLenum;\n    readonly TEXTURE16: GLenum;\n    readonly TEXTURE17: GLenum;\n    readonly TEXTURE18: GLenum;\n    readonly TEXTURE19: GLenum;\n    readonly TEXTURE2: GLenum;\n    readonly TEXTURE20: GLenum;\n    readonly TEXTURE21: GLenum;\n    readonly TEXTURE22: GLenum;\n    readonly TEXTURE23: GLenum;\n    readonly TEXTURE24: GLenum;\n    readonly TEXTURE25: GLenum;\n    readonly TEXTURE26: GLenum;\n    readonly TEXTURE27: GLenum;\n    readonly TEXTURE28: GLenum;\n    readonly TEXTURE29: GLenum;\n    readonly TEXTURE3: GLenum;\n    readonly TEXTURE30: GLenum;\n    readonly TEXTURE31: GLenum;\n    readonly TEXTURE4: GLenum;\n    readonly TEXTURE5: GLenum;\n    readonly TEXTURE6: GLenum;\n    readonly TEXTURE7: GLenum;\n    readonly TEXTURE8: GLenum;\n    readonly TEXTURE9: GLenum;\n    readonly TEXTURE_2D: GLenum;\n    readonly TEXTURE_BINDING_2D: GLenum;\n    readonly TEXTURE_BINDING_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum;\n    readonly TEXTURE_MAG_FILTER: GLenum;\n    readonly TEXTURE_MIN_FILTER: GLenum;\n    readonly TEXTURE_WRAP_S: GLenum;\n    readonly TEXTURE_WRAP_T: GLenum;\n    readonly TRIANGLES: GLenum;\n    readonly TRIANGLE_FAN: GLenum;\n    readonly TRIANGLE_STRIP: GLenum;\n    readonly UNPACK_ALIGNMENT: GLenum;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum;\n    readonly UNPACK_FLIP_Y_WEBGL: GLenum;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum;\n    readonly UNSIGNED_BYTE: GLenum;\n    readonly UNSIGNED_INT: GLenum;\n    readonly UNSIGNED_SHORT: GLenum;\n    readonly UNSIGNED_SHORT_4_4_4_4: GLenum;\n    readonly UNSIGNED_SHORT_5_5_5_1: GLenum;\n    readonly UNSIGNED_SHORT_5_6_5: GLenum;\n    readonly VALIDATE_STATUS: GLenum;\n    readonly VENDOR: GLenum;\n    readonly VERSION: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: GLenum;\n    readonly VERTEX_SHADER: GLenum;\n    readonly VIEWPORT: GLenum;\n    readonly ZERO: GLenum;\n}\n\ninterface WebGLShader extends WebGLObject {\n}\n\ndeclare var WebGLShader: {\n    prototype: WebGLShader;\n    new(): WebGLShader;\n};\n\ninterface WebGLShaderPrecisionFormat {\n    readonly precision: GLint;\n    readonly rangeMax: GLint;\n    readonly rangeMin: GLint;\n}\n\ndeclare var WebGLShaderPrecisionFormat: {\n    prototype: WebGLShaderPrecisionFormat;\n    new(): WebGLShaderPrecisionFormat;\n};\n\ninterface WebGLTexture extends WebGLObject {\n}\n\ndeclare var WebGLTexture: {\n    prototype: WebGLTexture;\n    new(): WebGLTexture;\n};\n\ninterface WebGLUniformLocation {\n}\n\ndeclare var WebGLUniformLocation: {\n    prototype: WebGLUniformLocation;\n    new(): WebGLUniformLocation;\n};\n\ninterface WebGLVertexArrayObjectOES extends WebGLObject {\n}\n\ninterface WebKitPoint {\n    x: number;\n    y: number;\n}\n\ndeclare var WebKitPoint: {\n    prototype: WebKitPoint;\n    new(x?: number, y?: number): WebKitPoint;\n};\n\ninterface WebSocketEventMap {\n    "close": CloseEvent;\n    "error": Event;\n    "message": MessageEvent;\n    "open": Event;\n}\n\ninterface WebSocket extends EventTarget {\n    binaryType: BinaryType;\n    readonly bufferedAmount: number;\n    readonly extensions: string;\n    onclose: ((this: WebSocket, ev: CloseEvent) => any) | null;\n    onerror: ((this: WebSocket, ev: Event) => any) | null;\n    onmessage: ((this: WebSocket, ev: MessageEvent) => any) | null;\n    onopen: ((this: WebSocket, ev: Event) => any) | null;\n    readonly protocol: string;\n    readonly readyState: number;\n    readonly url: string;\n    close(code?: number, reason?: string): void;\n    send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var WebSocket: {\n    prototype: WebSocket;\n    new(url: string, protocols?: string | string[]): WebSocket;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n};\n\ninterface WheelEvent extends MouseEvent {\n    readonly deltaMode: number;\n    readonly deltaX: number;\n    readonly deltaY: number;\n    readonly deltaZ: number;\n    getCurrentPoint(element: Element): void;\n    initWheelEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, viewArg: Window, detailArg: number, screenXArg: number, screenYArg: number, clientXArg: number, clientYArg: number, buttonArg: number, relatedTargetArg: EventTarget, modifiersListArg: string, deltaXArg: number, deltaYArg: number, deltaZArg: number, deltaMode: number): void;\n    readonly DOM_DELTA_LINE: number;\n    readonly DOM_DELTA_PAGE: number;\n    readonly DOM_DELTA_PIXEL: number;\n}\n\ndeclare var WheelEvent: {\n    prototype: WheelEvent;\n    new(typeArg: string, eventInitDict?: WheelEventInit): WheelEvent;\n    readonly DOM_DELTA_LINE: number;\n    readonly DOM_DELTA_PAGE: number;\n    readonly DOM_DELTA_PIXEL: number;\n};\n\ninterface WindowEventMap extends GlobalEventHandlersEventMap, WindowEventHandlersEventMap {\n    "abort": UIEvent;\n    "afterprint": Event;\n    "beforeprint": Event;\n    "beforeunload": BeforeUnloadEvent;\n    "blur": FocusEvent;\n    "canplay": Event;\n    "canplaythrough": Event;\n    "change": Event;\n    "click": MouseEvent;\n    "compassneedscalibration": Event;\n    "contextmenu": MouseEvent;\n    "dblclick": MouseEvent;\n    "devicelight": DeviceLightEvent;\n    "devicemotion": DeviceMotionEvent;\n    "deviceorientation": DeviceOrientationEvent;\n    "drag": DragEvent;\n    "dragend": DragEvent;\n    "dragenter": DragEvent;\n    "dragleave": DragEvent;\n    "dragover": DragEvent;\n    "dragstart": DragEvent;\n    "drop": DragEvent;\n    "durationchange": Event;\n    "emptied": Event;\n    "ended": Event;\n    "error": ErrorEvent;\n    "focus": FocusEvent;\n    "hashchange": HashChangeEvent;\n    "input": Event;\n    "invalid": Event;\n    "keydown": KeyboardEvent;\n    "keypress": KeyboardEvent;\n    "keyup": KeyboardEvent;\n    "load": Event;\n    "loadeddata": Event;\n    "loadedmetadata": Event;\n    "loadstart": Event;\n    "message": MessageEvent;\n    "mousedown": MouseEvent;\n    "mouseenter": MouseEvent;\n    "mouseleave": MouseEvent;\n    "mousemove": MouseEvent;\n    "mouseout": MouseEvent;\n    "mouseover": MouseEvent;\n    "mouseup": MouseEvent;\n    "mousewheel": Event;\n    "MSGestureChange": Event;\n    "MSGestureDoubleTap": Event;\n    "MSGestureEnd": Event;\n    "MSGestureHold": Event;\n    "MSGestureStart": Event;\n    "MSGestureTap": Event;\n    "MSInertiaStart": Event;\n    "MSPointerCancel": Event;\n    "MSPointerDown": Event;\n    "MSPointerEnter": Event;\n    "MSPointerLeave": Event;\n    "MSPointerMove": Event;\n    "MSPointerOut": Event;\n    "MSPointerOver": Event;\n    "MSPointerUp": Event;\n    "offline": Event;\n    "online": Event;\n    "orientationchange": Event;\n    "pagehide": PageTransitionEvent;\n    "pageshow": PageTransitionEvent;\n    "pause": Event;\n    "play": Event;\n    "playing": Event;\n    "popstate": PopStateEvent;\n    "progress": ProgressEvent;\n    "ratechange": Event;\n    "readystatechange": ProgressEvent;\n    "reset": Event;\n    "resize": UIEvent;\n    "scroll": UIEvent;\n    "seeked": Event;\n    "seeking": Event;\n    "select": UIEvent;\n    "stalled": Event;\n    "storage": StorageEvent;\n    "submit": Event;\n    "suspend": Event;\n    "timeupdate": Event;\n    "unload": Event;\n    "volumechange": Event;\n    "vrdisplayactivate": Event;\n    "vrdisplayblur": Event;\n    "vrdisplayconnect": Event;\n    "vrdisplaydeactivate": Event;\n    "vrdisplaydisconnect": Event;\n    "vrdisplayfocus": Event;\n    "vrdisplaypointerrestricted": Event;\n    "vrdisplaypointerunrestricted": Event;\n    "vrdisplaypresentchange": Event;\n    "waiting": Event;\n}\n\ninterface Window extends EventTarget, WindowTimers, WindowSessionStorage, WindowLocalStorage, WindowConsole, GlobalEventHandlers, IDBEnvironment, WindowBase64, GlobalFetch, WindowOrWorkerGlobalScope, WindowEventHandlers {\n    Blob: typeof Blob;\n    URL: typeof URL;\n    URLSearchParams: typeof URLSearchParams;\n    readonly applicationCache: ApplicationCache;\n    readonly caches: CacheStorage;\n    readonly clientInformation: Navigator;\n    readonly closed: boolean;\n    readonly crypto: Crypto;\n    customElements: CustomElementRegistry;\n    defaultStatus: string;\n    readonly devicePixelRatio: number;\n    readonly doNotTrack: string;\n    readonly document: Document;\n    readonly event: Event | undefined;\n    /** @deprecated */\n    readonly external: External;\n    readonly frameElement: Element;\n    readonly frames: Window;\n    readonly history: History;\n    readonly innerHeight: number;\n    readonly innerWidth: number;\n    readonly isSecureContext: boolean;\n    readonly length: number;\n    location: Location;\n    readonly locationbar: BarProp;\n    readonly menubar: BarProp;\n    readonly msContentScript: ExtensionScriptApis;\n    name: string;\n    readonly navigator: Navigator;\n    offscreenBuffering: string | boolean;\n    oncompassneedscalibration: ((this: Window, ev: Event) => any) | null;\n    ondevicelight: ((this: Window, ev: DeviceLightEvent) => any) | null;\n    ondevicemotion: ((this: Window, ev: DeviceMotionEvent) => any) | null;\n    ondeviceorientation: ((this: Window, ev: DeviceOrientationEvent) => any) | null;\n    onmousewheel: ((this: Window, ev: Event) => any) | null;\n    onmsgesturechange: ((this: Window, ev: Event) => any) | null;\n    onmsgesturedoubletap: ((this: Window, ev: Event) => any) | null;\n    onmsgestureend: ((this: Window, ev: Event) => any) | null;\n    onmsgesturehold: ((this: Window, ev: Event) => any) | null;\n    onmsgesturestart: ((this: Window, ev: Event) => any) | null;\n    onmsgesturetap: ((this: Window, ev: Event) => any) | null;\n    onmsinertiastart: ((this: Window, ev: Event) => any) | null;\n    onmspointercancel: ((this: Window, ev: Event) => any) | null;\n    onmspointerdown: ((this: Window, ev: Event) => any) | null;\n    onmspointerenter: ((this: Window, ev: Event) => any) | null;\n    onmspointerleave: ((this: Window, ev: Event) => any) | null;\n    onmspointermove: ((this: Window, ev: Event) => any) | null;\n    onmspointerout: ((this: Window, ev: Event) => any) | null;\n    onmspointerover: ((this: Window, ev: Event) => any) | null;\n    onmspointerup: ((this: Window, ev: Event) => any) | null;\n    /** @deprecated */\n    onorientationchange: ((this: Window, ev: Event) => any) | null;\n    onreadystatechange: ((this: Window, ev: ProgressEvent) => any) | null;\n    onvrdisplayactivate: ((this: Window, ev: Event) => any) | null;\n    onvrdisplayblur: ((this: Window, ev: Event) => any) | null;\n    onvrdisplayconnect: ((this: Window, ev: Event) => any) | null;\n    onvrdisplaydeactivate: ((this: Window, ev: Event) => any) | null;\n    onvrdisplaydisconnect: ((this: Window, ev: Event) => any) | null;\n    onvrdisplayfocus: ((this: Window, ev: Event) => any) | null;\n    onvrdisplaypointerrestricted: ((this: Window, ev: Event) => any) | null;\n    onvrdisplaypointerunrestricted: ((this: Window, ev: Event) => any) | null;\n    onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;\n    opener: any;\n    /** @deprecated */\n    readonly orientation: string | number;\n    readonly outerHeight: number;\n    readonly outerWidth: number;\n    readonly pageXOffset: number;\n    readonly pageYOffset: number;\n    readonly parent: Window;\n    readonly performance: Performance;\n    readonly personalbar: BarProp;\n    readonly screen: Screen;\n    readonly screenLeft: number;\n    readonly screenTop: number;\n    readonly screenX: number;\n    readonly screenY: number;\n    readonly scrollX: number;\n    readonly scrollY: number;\n    readonly scrollbars: BarProp;\n    readonly self: Window;\n    readonly speechSynthesis: SpeechSynthesis;\n    status: string;\n    readonly statusbar: BarProp;\n    readonly styleMedia: StyleMedia;\n    readonly toolbar: BarProp;\n    readonly top: Window;\n    readonly window: Window;\n    alert(message?: any): void;\n    blur(): void;\n    cancelAnimationFrame(handle: number): void;\n    /** @deprecated */\n    captureEvents(): void;\n    close(): void;\n    confirm(message?: string): boolean;\n    departFocus(navigationReason: NavigationReason, origin: FocusNavigationOrigin): void;\n    focus(): void;\n    getComputedStyle(elt: Element, pseudoElt?: string | null): CSSStyleDeclaration;\n    getMatchedCSSRules(elt: Element, pseudoElt?: string | null): CSSRuleList;\n    getSelection(): Selection;\n    matchMedia(query: string): MediaQueryList;\n    moveBy(x: number, y: number): void;\n    moveTo(x: number, y: number): void;\n    msWriteProfilerMark(profilerMarkName: string): void;\n    open(url?: string, target?: string, features?: string, replace?: boolean): Window | null;\n    postMessage(message: any, targetOrigin: string, transfer?: Transferable[]): void;\n    print(): void;\n    prompt(message?: string, _default?: string): string | null;\n    /** @deprecated */\n    releaseEvents(): void;\n    requestAnimationFrame(callback: FrameRequestCallback): number;\n    resizeBy(x: number, y: number): void;\n    resizeTo(x: number, y: number): void;\n    scroll(options?: ScrollToOptions): void;\n    scroll(x: number, y: number): void;\n    scrollBy(options?: ScrollToOptions): void;\n    scrollBy(x: number, y: number): void;\n    scrollTo(options?: ScrollToOptions): void;\n    scrollTo(x: number, y: number): void;\n    stop(): void;\n    webkitCancelAnimationFrame(handle: number): void;\n    webkitConvertPointFromNodeToPage(node: Node, pt: WebKitPoint): WebKitPoint;\n    webkitConvertPointFromPageToNode(node: Node, pt: WebKitPoint): WebKitPoint;\n    webkitRequestAnimationFrame(callback: FrameRequestCallback): number;\n    addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Window: {\n    prototype: Window;\n    new(): Window;\n};\n\ninterface WindowBase64 {\n    atob(encodedString: string): string;\n    btoa(rawString: string): string;\n}\n\ninterface WindowConsole {\n    readonly console: Console;\n}\n\ninterface WindowEventHandlersEventMap {\n    "afterprint": Event;\n    "beforeprint": Event;\n    "beforeunload": BeforeUnloadEvent;\n    "hashchange": HashChangeEvent;\n    "languagechange": Event;\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n    "offline": Event;\n    "online": Event;\n    "pagehide": PageTransitionEvent;\n    "pageshow": PageTransitionEvent;\n    "popstate": PopStateEvent;\n    "rejectionhandled": Event;\n    "storage": StorageEvent;\n    "unhandledrejection": PromiseRejectionEvent;\n    "unload": Event;\n}\n\ninterface WindowEventHandlers {\n    onafterprint: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    onbeforeprint: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    onbeforeunload: ((this: WindowEventHandlers, ev: BeforeUnloadEvent) => any) | null;\n    onhashchange: ((this: WindowEventHandlers, ev: HashChangeEvent) => any) | null;\n    onlanguagechange: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    onmessage: ((this: WindowEventHandlers, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: WindowEventHandlers, ev: MessageEvent) => any) | null;\n    onoffline: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    ononline: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    onpagehide: ((this: WindowEventHandlers, ev: PageTransitionEvent) => any) | null;\n    onpageshow: ((this: WindowEventHandlers, ev: PageTransitionEvent) => any) | null;\n    onpopstate: ((this: WindowEventHandlers, ev: PopStateEvent) => any) | null;\n    onrejectionhandled: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    onstorage: ((this: WindowEventHandlers, ev: StorageEvent) => any) | null;\n    onunhandledrejection: ((this: WindowEventHandlers, ev: PromiseRejectionEvent) => any) | null;\n    onunload: ((this: WindowEventHandlers, ev: Event) => any) | null;\n    addEventListener<K extends keyof WindowEventHandlersEventMap>(type: K, listener: (this: WindowEventHandlers, ev: WindowEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WindowEventHandlersEventMap>(type: K, listener: (this: WindowEventHandlers, ev: WindowEventHandlersEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface WindowLocalStorage {\n    readonly localStorage: Storage;\n}\n\ninterface WindowOrWorkerGlobalScope {\n    readonly caches: CacheStorage;\n    readonly crypto: Crypto;\n    readonly indexedDB: IDBFactory;\n    readonly origin: string;\n    readonly performance: Performance;\n    atob(data: string): string;\n    btoa(data: string): string;\n    clearInterval(handle?: number): void;\n    clearTimeout(handle?: number): void;\n    createImageBitmap(image: ImageBitmapSource): Promise<ImageBitmap>;\n    createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number): Promise<ImageBitmap>;\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n    queueMicrotask(callback: Function): void;\n    setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\n    setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\n}\n\ninterface WindowSessionStorage {\n    readonly sessionStorage: Storage;\n}\n\ninterface WindowTimers {\n}\n\ninterface WorkerEventMap extends AbstractWorkerEventMap {\n    "message": MessageEvent;\n}\n\ninterface Worker extends EventTarget, AbstractWorker {\n    onmessage: ((this: Worker, ev: MessageEvent) => any) | null;\n    postMessage(message: any, transfer?: Transferable[]): void;\n    terminate(): void;\n    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Worker: {\n    prototype: Worker;\n    new(stringUrl: string, options?: WorkerOptions): Worker;\n};\n\ninterface Worklet {\n    addModule(moduleURL: string, options?: WorkletOptions): Promise<void>;\n}\n\ndeclare var Worklet: {\n    prototype: Worklet;\n    new(): Worklet;\n};\n\ninterface WritableStream<W = any> {\n    readonly locked: boolean;\n    abort(reason?: any): Promise<void>;\n    getWriter(): WritableStreamDefaultWriter<W>;\n}\n\ndeclare var WritableStream: {\n    prototype: WritableStream;\n    new<W = any>(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>): WritableStream<W>;\n};\n\ninterface WritableStreamDefaultController {\n    error(error?: any): void;\n}\n\ninterface WritableStreamDefaultWriter<W = any> {\n    readonly closed: Promise<void>;\n    readonly desiredSize: number | null;\n    readonly ready: Promise<void>;\n    abort(reason?: any): Promise<void>;\n    close(): Promise<void>;\n    releaseLock(): void;\n    write(chunk: W): Promise<void>;\n}\n\ninterface XMLDocument extends Document {\n    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: XMLDocument, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLDocument: {\n    prototype: XMLDocument;\n    new(): XMLDocument;\n};\n\ninterface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {\n    "readystatechange": Event;\n}\n\ninterface XMLHttpRequest extends XMLHttpRequestEventTarget {\n    onreadystatechange: ((this: XMLHttpRequest, ev: Event) => any) | null;\n    /**\n     * Returns client\'s state.\n     */\n    readonly readyState: number;\n    /**\n     * Returns the response\'s body.\n     */\n    readonly response: any;\n    /**\n     * Returns the text response.\n     * Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".\n     */\n    readonly responseText: string;\n    /**\n     * Returns the response type.\n     * Can be set to change the response type. Values are:\n     * the empty string (default),\n     * "arraybuffer",\n     * "blob",\n     * "document",\n     * "json", and\n     * "text".\n     * When set: setting to "document" is ignored if current global object is not a Window object.\n     * When set: throws an "InvalidStateError" DOMException if state is loading or done.\n     * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n     */\n    responseType: XMLHttpRequestResponseType;\n    readonly responseURL: string;\n    /**\n     * Returns the document response.\n     * Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".\n     */\n    readonly responseXML: Document | null;\n    readonly status: number;\n    readonly statusText: string;\n    /**\n     * Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the\n     * request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a\n     * "TimeoutError" DOMException will be thrown otherwise (for the send() method).\n     * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n     */\n    timeout: number;\n    /**\n     * Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is\n     * transferred to a server.\n     */\n    readonly upload: XMLHttpRequestUpload;\n    /**\n     * True when credentials are to be included in a cross-origin request. False when they are\n     * to be excluded in a cross-origin request and when cookies are to be ignored in its response.\n     * Initially false.\n     * When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.\n     */\n    withCredentials: boolean;\n    /**\n     * Cancels any network activity.\n     */\n    abort(): void;\n    getAllResponseHeaders(): string;\n    getResponseHeader(name: string): string | null;\n    /**\n     * Sets the request method, request URL, and synchronous flag.\n     * Throws a "SyntaxError" DOMException if either method is not a\n     * valid HTTP method or url cannot be parsed.\n     * Throws a "SecurityError" DOMException if method is a\n     * case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.\n     * Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.\n     */\n    open(method: string, url: string): void;\n    open(method: string, url: string, async: boolean, username?: string | null, password?: string | null): void;\n    /**\n     * Acts as if the `Content-Type` header value for response is mime.\n     * (It does not actually change the header though.)\n     * Throws an "InvalidStateError" DOMException if state is loading or done.\n     */\n    overrideMimeType(mime: string): void;\n    /**\n     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD.\n     * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n     */\n    send(body?: Document | BodyInit | null): void;\n    /**\n     * Combines a header in author request headers.\n     * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n     * Throws a "SyntaxError" DOMException if name is not a header name\n     * or if value is not a header value.\n     */\n    setRequestHeader(name: string, value: string): void;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequest: {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n};\n\ninterface XMLHttpRequestEventTargetEventMap {\n    "abort": ProgressEvent;\n    "error": ProgressEvent;\n    "load": ProgressEvent;\n    "loadend": ProgressEvent;\n    "loadstart": ProgressEvent;\n    "progress": ProgressEvent;\n    "timeout": ProgressEvent;\n}\n\ninterface XMLHttpRequestEventTarget extends EventTarget {\n    onabort: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onerror: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onload: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    ontimeout: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequestEventTarget: {\n    prototype: XMLHttpRequestEventTarget;\n    new(): XMLHttpRequestEventTarget;\n};\n\ninterface XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequestUpload: {\n    prototype: XMLHttpRequestUpload;\n    new(): XMLHttpRequestUpload;\n};\n\ninterface XMLSerializer {\n    serializeToString(root: Node): string;\n}\n\ndeclare var XMLSerializer: {\n    prototype: XMLSerializer;\n    new(): XMLSerializer;\n};\n\ninterface XPathEvaluator {\n    createExpression(expression: string, resolver: XPathNSResolver): XPathExpression;\n    createNSResolver(nodeResolver?: Node): XPathNSResolver;\n    evaluate(expression: string, contextNode: Node, resolver: XPathNSResolver | ((prefix: string) => string | null) | null, type: number, result: XPathResult | null): XPathResult;\n}\n\ndeclare var XPathEvaluator: {\n    prototype: XPathEvaluator;\n    new(): XPathEvaluator;\n};\n\ninterface XPathExpression {\n    evaluate(contextNode: Node, type: number, result: XPathResult | null): XPathResult;\n}\n\ndeclare var XPathExpression: {\n    prototype: XPathExpression;\n    new(): XPathExpression;\n};\n\ninterface XPathNSResolver {\n    lookupNamespaceURI(prefix: string): string | null;\n}\n\ndeclare var XPathNSResolver: {\n    prototype: XPathNSResolver;\n    new(): XPathNSResolver;\n};\n\ninterface XPathResult {\n    readonly booleanValue: boolean;\n    readonly invalidIteratorState: boolean;\n    readonly numberValue: number;\n    readonly resultType: number;\n    readonly singleNodeValue: Node;\n    readonly snapshotLength: number;\n    readonly stringValue: string;\n    iterateNext(): Node;\n    snapshotItem(index: number): Node;\n    readonly ANY_TYPE: number;\n    readonly ANY_UNORDERED_NODE_TYPE: number;\n    readonly BOOLEAN_TYPE: number;\n    readonly FIRST_ORDERED_NODE_TYPE: number;\n    readonly NUMBER_TYPE: number;\n    readonly ORDERED_NODE_ITERATOR_TYPE: number;\n    readonly ORDERED_NODE_SNAPSHOT_TYPE: number;\n    readonly STRING_TYPE: number;\n    readonly UNORDERED_NODE_ITERATOR_TYPE: number;\n    readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;\n}\n\ndeclare var XPathResult: {\n    prototype: XPathResult;\n    new(): XPathResult;\n    readonly ANY_TYPE: number;\n    readonly ANY_UNORDERED_NODE_TYPE: number;\n    readonly BOOLEAN_TYPE: number;\n    readonly FIRST_ORDERED_NODE_TYPE: number;\n    readonly NUMBER_TYPE: number;\n    readonly ORDERED_NODE_ITERATOR_TYPE: number;\n    readonly ORDERED_NODE_SNAPSHOT_TYPE: number;\n    readonly STRING_TYPE: number;\n    readonly UNORDERED_NODE_ITERATOR_TYPE: number;\n    readonly UNORDERED_NODE_SNAPSHOT_TYPE: number;\n};\n\ninterface XSLTProcessor {\n    clearParameters(): void;\n    getParameter(namespaceURI: string, localName: string): any;\n    importStylesheet(style: Node): void;\n    removeParameter(namespaceURI: string, localName: string): void;\n    reset(): void;\n    setParameter(namespaceURI: string, localName: string, value: any): void;\n    transformToDocument(source: Node): Document;\n    transformToFragment(source: Node, document: Document): DocumentFragment;\n}\n\ndeclare var XSLTProcessor: {\n    prototype: XSLTProcessor;\n    new(): XSLTProcessor;\n};\n\ninterface webkitRTCPeerConnection extends RTCPeerConnection {\n    addEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: webkitRTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof RTCPeerConnectionEventMap>(type: K, listener: (this: webkitRTCPeerConnection, ev: RTCPeerConnectionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var webkitRTCPeerConnection: {\n    prototype: webkitRTCPeerConnection;\n    new(configuration: RTCConfiguration): webkitRTCPeerConnection;\n};\n\ndeclare type EventListenerOrEventListenerObject = EventListener | EventListenerObject;\n\ninterface BlobCallback {\n    (blob: Blob | null): void;\n}\n\ninterface DecodeErrorCallback {\n    (error: DOMException): void;\n}\n\ninterface DecodeSuccessCallback {\n    (decodedData: AudioBuffer): void;\n}\n\ninterface ErrorEventHandler {\n    (event: Event | string, source?: string, fileno?: number, columnNumber?: number, error?: Error): void;\n}\n\ninterface EventHandlerNonNull {\n    (event: Event): any;\n}\n\ninterface ForEachCallback {\n    (keyId: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | null, status: MediaKeyStatus): void;\n}\n\ninterface FrameRequestCallback {\n    (time: number): void;\n}\n\ninterface FunctionStringCallback {\n    (data: string): void;\n}\n\ninterface IntersectionObserverCallback {\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;\n}\n\ninterface MSLaunchUriCallback {\n    (): void;\n}\n\ninterface MutationCallback {\n    (mutations: MutationRecord[], observer: MutationObserver): void;\n}\n\ninterface NavigatorUserMediaErrorCallback {\n    (error: MediaStreamError): void;\n}\n\ninterface NavigatorUserMediaSuccessCallback {\n    (stream: MediaStream): void;\n}\n\ninterface NotificationPermissionCallback {\n    (permission: NotificationPermission): void;\n}\n\ninterface OnBeforeUnloadEventHandlerNonNull {\n    (event: Event): string | null;\n}\n\ninterface OnErrorEventHandlerNonNull {\n    (event: Event | string, source?: string, lineno?: number, colno?: number, error?: any): any;\n}\n\ninterface PerformanceObserverCallback {\n    (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;\n}\n\ninterface PositionCallback {\n    (position: Position): void;\n}\n\ninterface PositionErrorCallback {\n    (positionError: PositionError): void;\n}\n\ninterface QueuingStrategySizeCallback<T = any> {\n    (chunk: T): number;\n}\n\ninterface RTCPeerConnectionErrorCallback {\n    (error: DOMException): void;\n}\n\ninterface RTCSessionDescriptionCallback {\n    (description: RTCSessionDescriptionInit): void;\n}\n\ninterface RTCStatsCallback {\n    (report: RTCStatsReport): void;\n}\n\ninterface ReadableByteStreamControllerCallback {\n    (controller: ReadableByteStreamController): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamDefaultControllerCallback<R> {\n    (controller: ReadableStreamDefaultController<R>): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamErrorCallback {\n    (reason: any): void | PromiseLike<void>;\n}\n\ninterface TransformStreamDefaultControllerCallback<O> {\n    (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;\n}\n\ninterface TransformStreamDefaultControllerTransformCallback<I, O> {\n    (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;\n}\n\ninterface VoidFunction {\n    (): void;\n}\n\ninterface WritableStreamDefaultControllerCloseCallback {\n    (): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerStartCallback {\n    (controller: WritableStreamDefaultController): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerWriteCallback<W> {\n    (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>;\n}\n\ninterface WritableStreamErrorCallback {\n    (reason: any): void | PromiseLike<void>;\n}\n\ninterface HTMLElementTagNameMap {\n    "a": HTMLAnchorElement;\n    "abbr": HTMLElement;\n    "address": HTMLElement;\n    "applet": HTMLAppletElement;\n    "area": HTMLAreaElement;\n    "article": HTMLElement;\n    "aside": HTMLElement;\n    "audio": HTMLAudioElement;\n    "b": HTMLElement;\n    "base": HTMLBaseElement;\n    "basefont": HTMLBaseFontElement;\n    "bdo": HTMLElement;\n    "blockquote": HTMLQuoteElement;\n    "body": HTMLBodyElement;\n    "br": HTMLBRElement;\n    "button": HTMLButtonElement;\n    "canvas": HTMLCanvasElement;\n    "caption": HTMLTableCaptionElement;\n    "cite": HTMLElement;\n    "code": HTMLElement;\n    "col": HTMLTableColElement;\n    "colgroup": HTMLTableColElement;\n    "data": HTMLDataElement;\n    "datalist": HTMLDataListElement;\n    "dd": HTMLElement;\n    "del": HTMLModElement;\n    "details": HTMLDetailsElement;\n    "dfn": HTMLElement;\n    "dialog": HTMLDialogElement;\n    "dir": HTMLDirectoryElement;\n    "div": HTMLDivElement;\n    "dl": HTMLDListElement;\n    "dt": HTMLElement;\n    "em": HTMLElement;\n    "embed": HTMLEmbedElement;\n    "fieldset": HTMLFieldSetElement;\n    "figcaption": HTMLElement;\n    "figure": HTMLElement;\n    "font": HTMLFontElement;\n    "footer": HTMLElement;\n    "form": HTMLFormElement;\n    "frame": HTMLFrameElement;\n    "frameset": HTMLFrameSetElement;\n    "h1": HTMLHeadingElement;\n    "h2": HTMLHeadingElement;\n    "h3": HTMLHeadingElement;\n    "h4": HTMLHeadingElement;\n    "h5": HTMLHeadingElement;\n    "h6": HTMLHeadingElement;\n    "head": HTMLHeadElement;\n    "header": HTMLElement;\n    "hgroup": HTMLElement;\n    "hr": HTMLHRElement;\n    "html": HTMLHtmlElement;\n    "i": HTMLElement;\n    "iframe": HTMLIFrameElement;\n    "img": HTMLImageElement;\n    "input": HTMLInputElement;\n    "ins": HTMLModElement;\n    "kbd": HTMLElement;\n    "label": HTMLLabelElement;\n    "legend": HTMLLegendElement;\n    "li": HTMLLIElement;\n    "link": HTMLLinkElement;\n    "map": HTMLMapElement;\n    "mark": HTMLElement;\n    "marquee": HTMLMarqueeElement;\n    "menu": HTMLMenuElement;\n    "meta": HTMLMetaElement;\n    "meter": HTMLMeterElement;\n    "nav": HTMLElement;\n    "noscript": HTMLElement;\n    "object": HTMLObjectElement;\n    "ol": HTMLOListElement;\n    "optgroup": HTMLOptGroupElement;\n    "option": HTMLOptionElement;\n    "output": HTMLOutputElement;\n    "p": HTMLParagraphElement;\n    "param": HTMLParamElement;\n    "picture": HTMLPictureElement;\n    "pre": HTMLPreElement;\n    "progress": HTMLProgressElement;\n    "q": HTMLQuoteElement;\n    "rt": HTMLElement;\n    "ruby": HTMLElement;\n    "s": HTMLElement;\n    "samp": HTMLElement;\n    "script": HTMLScriptElement;\n    "section": HTMLElement;\n    "select": HTMLSelectElement;\n    "slot": HTMLSlotElement;\n    "small": HTMLElement;\n    "source": HTMLSourceElement;\n    "span": HTMLSpanElement;\n    "strong": HTMLElement;\n    "style": HTMLStyleElement;\n    "sub": HTMLElement;\n    "sup": HTMLElement;\n    "table": HTMLTableElement;\n    "tbody": HTMLTableSectionElement;\n    "td": HTMLTableDataCellElement;\n    "template": HTMLTemplateElement;\n    "textarea": HTMLTextAreaElement;\n    "tfoot": HTMLTableSectionElement;\n    "th": HTMLTableHeaderCellElement;\n    "thead": HTMLTableSectionElement;\n    "time": HTMLTimeElement;\n    "title": HTMLTitleElement;\n    "tr": HTMLTableRowElement;\n    "track": HTMLTrackElement;\n    "u": HTMLElement;\n    "ul": HTMLUListElement;\n    "var": HTMLElement;\n    "video": HTMLVideoElement;\n    "wbr": HTMLElement;\n}\n\ninterface HTMLElementDeprecatedTagNameMap {\n    "listing": HTMLPreElement;\n    "xmp": HTMLPreElement;\n}\n\ninterface SVGElementTagNameMap {\n    "circle": SVGCircleElement;\n    "clipPath": SVGClipPathElement;\n    "defs": SVGDefsElement;\n    "desc": SVGDescElement;\n    "ellipse": SVGEllipseElement;\n    "feBlend": SVGFEBlendElement;\n    "feColorMatrix": SVGFEColorMatrixElement;\n    "feComponentTransfer": SVGFEComponentTransferElement;\n    "feComposite": SVGFECompositeElement;\n    "feConvolveMatrix": SVGFEConvolveMatrixElement;\n    "feDiffuseLighting": SVGFEDiffuseLightingElement;\n    "feDisplacementMap": SVGFEDisplacementMapElement;\n    "feDistantLight": SVGFEDistantLightElement;\n    "feFlood": SVGFEFloodElement;\n    "feFuncA": SVGFEFuncAElement;\n    "feFuncB": SVGFEFuncBElement;\n    "feFuncG": SVGFEFuncGElement;\n    "feFuncR": SVGFEFuncRElement;\n    "feGaussianBlur": SVGFEGaussianBlurElement;\n    "feImage": SVGFEImageElement;\n    "feMerge": SVGFEMergeElement;\n    "feMergeNode": SVGFEMergeNodeElement;\n    "feMorphology": SVGFEMorphologyElement;\n    "feOffset": SVGFEOffsetElement;\n    "fePointLight": SVGFEPointLightElement;\n    "feSpecularLighting": SVGFESpecularLightingElement;\n    "feSpotLight": SVGFESpotLightElement;\n    "feTile": SVGFETileElement;\n    "feTurbulence": SVGFETurbulenceElement;\n    "filter": SVGFilterElement;\n    "foreignObject": SVGForeignObjectElement;\n    "g": SVGGElement;\n    "image": SVGImageElement;\n    "line": SVGLineElement;\n    "linearGradient": SVGLinearGradientElement;\n    "marker": SVGMarkerElement;\n    "mask": SVGMaskElement;\n    "metadata": SVGMetadataElement;\n    "path": SVGPathElement;\n    "pattern": SVGPatternElement;\n    "polygon": SVGPolygonElement;\n    "polyline": SVGPolylineElement;\n    "radialGradient": SVGRadialGradientElement;\n    "rect": SVGRectElement;\n    "stop": SVGStopElement;\n    "svg": SVGSVGElement;\n    "switch": SVGSwitchElement;\n    "symbol": SVGSymbolElement;\n    "text": SVGTextElement;\n    "textPath": SVGTextPathElement;\n    "tspan": SVGTSpanElement;\n    "use": SVGUseElement;\n    "view": SVGViewElement;\n}\n\n/** @deprecated Directly use HTMLElementTagNameMap or SVGElementTagNameMap as appropriate, instead. */\ninterface ElementTagNameMap extends HTMLElementTagNameMap, SVGElementTagNameMap { }\n\ndeclare var Audio: {\n    new(src?: string): HTMLAudioElement;\n};\ndeclare var Image: {\n    new(width?: number, height?: number): HTMLImageElement;\n};\ndeclare var Option: {\n    new(text?: string, value?: string, defaultSelected?: boolean, selected?: boolean): HTMLOptionElement;\n};\ndeclare var Blob: typeof Blob;\ndeclare var URL: typeof URL;\ndeclare var URLSearchParams: typeof URLSearchParams;\ndeclare var applicationCache: ApplicationCache;\ndeclare var caches: CacheStorage;\ndeclare var clientInformation: Navigator;\ndeclare var closed: boolean;\ndeclare var crypto: Crypto;\ndeclare var customElements: CustomElementRegistry;\ndeclare var defaultStatus: string;\ndeclare var devicePixelRatio: number;\ndeclare var doNotTrack: string;\ndeclare var document: Document;\ndeclare var event: Event | undefined;\n/** @deprecated */\ndeclare var external: External;\ndeclare var frameElement: Element;\ndeclare var frames: Window;\ndeclare var history: History;\ndeclare var innerHeight: number;\ndeclare var innerWidth: number;\ndeclare var isSecureContext: boolean;\ndeclare var length: number;\ndeclare var location: Location;\ndeclare var locationbar: BarProp;\ndeclare var menubar: BarProp;\ndeclare var msContentScript: ExtensionScriptApis;\ndeclare const name: never;\ndeclare var navigator: Navigator;\ndeclare var offscreenBuffering: string | boolean;\ndeclare var oncompassneedscalibration: ((this: Window, ev: Event) => any) | null;\ndeclare var ondevicelight: ((this: Window, ev: DeviceLightEvent) => any) | null;\ndeclare var ondevicemotion: ((this: Window, ev: DeviceMotionEvent) => any) | null;\ndeclare var ondeviceorientation: ((this: Window, ev: DeviceOrientationEvent) => any) | null;\ndeclare var onmousewheel: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgesturechange: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgesturedoubletap: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgestureend: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgesturehold: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgesturestart: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsgesturetap: ((this: Window, ev: Event) => any) | null;\ndeclare var onmsinertiastart: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointercancel: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerdown: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerenter: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerleave: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointermove: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerout: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerover: ((this: Window, ev: Event) => any) | null;\ndeclare var onmspointerup: ((this: Window, ev: Event) => any) | null;\n/** @deprecated */\ndeclare var onorientationchange: ((this: Window, ev: Event) => any) | null;\ndeclare var onreadystatechange: ((this: Window, ev: ProgressEvent) => any) | null;\ndeclare var onvrdisplayactivate: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplayblur: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplayconnect: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplaydeactivate: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplaydisconnect: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplayfocus: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplaypointerrestricted: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplaypointerunrestricted: ((this: Window, ev: Event) => any) | null;\ndeclare var onvrdisplaypresentchange: ((this: Window, ev: Event) => any) | null;\ndeclare var opener: any;\n/** @deprecated */\ndeclare var orientation: string | number;\ndeclare var outerHeight: number;\ndeclare var outerWidth: number;\ndeclare var pageXOffset: number;\ndeclare var pageYOffset: number;\ndeclare var parent: Window;\ndeclare var performance: Performance;\ndeclare var personalbar: BarProp;\ndeclare var screen: Screen;\ndeclare var screenLeft: number;\ndeclare var screenTop: number;\ndeclare var screenX: number;\ndeclare var screenY: number;\ndeclare var scrollX: number;\ndeclare var scrollY: number;\ndeclare var scrollbars: BarProp;\ndeclare var self: Window;\ndeclare var speechSynthesis: SpeechSynthesis;\ndeclare var status: string;\ndeclare var statusbar: BarProp;\ndeclare var styleMedia: StyleMedia;\ndeclare var toolbar: BarProp;\ndeclare var top: Window;\ndeclare var window: Window;\ndeclare function alert(message?: any): void;\ndeclare function blur(): void;\ndeclare function cancelAnimationFrame(handle: number): void;\n/** @deprecated */\ndeclare function captureEvents(): void;\ndeclare function close(): void;\ndeclare function confirm(message?: string): boolean;\ndeclare function departFocus(navigationReason: NavigationReason, origin: FocusNavigationOrigin): void;\ndeclare function focus(): void;\ndeclare function getComputedStyle(elt: Element, pseudoElt?: string | null): CSSStyleDeclaration;\ndeclare function getMatchedCSSRules(elt: Element, pseudoElt?: string | null): CSSRuleList;\ndeclare function getSelection(): Selection;\ndeclare function matchMedia(query: string): MediaQueryList;\ndeclare function moveBy(x: number, y: number): void;\ndeclare function moveTo(x: number, y: number): void;\ndeclare function msWriteProfilerMark(profilerMarkName: string): void;\ndeclare function open(url?: string, target?: string, features?: string, replace?: boolean): Window | null;\ndeclare function postMessage(message: any, targetOrigin: string, transfer?: Transferable[]): void;\ndeclare function print(): void;\ndeclare function prompt(message?: string, _default?: string): string | null;\n/** @deprecated */\ndeclare function releaseEvents(): void;\ndeclare function requestAnimationFrame(callback: FrameRequestCallback): number;\ndeclare function resizeBy(x: number, y: number): void;\ndeclare function resizeTo(x: number, y: number): void;\ndeclare function scroll(options?: ScrollToOptions): void;\ndeclare function scroll(x: number, y: number): void;\ndeclare function scrollBy(options?: ScrollToOptions): void;\ndeclare function scrollBy(x: number, y: number): void;\ndeclare function scrollTo(options?: ScrollToOptions): void;\ndeclare function scrollTo(x: number, y: number): void;\ndeclare function stop(): void;\ndeclare function webkitCancelAnimationFrame(handle: number): void;\ndeclare function webkitConvertPointFromNodeToPage(node: Node, pt: WebKitPoint): WebKitPoint;\ndeclare function webkitConvertPointFromPageToNode(node: Node, pt: WebKitPoint): WebKitPoint;\ndeclare function webkitRequestAnimationFrame(callback: FrameRequestCallback): number;\ndeclare function toString(): string;\n/**\n * Dispatches a synthetic event event to target and returns true\n * if either event\'s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n */\ndeclare function dispatchEvent(event: Event): boolean;\ndeclare var sessionStorage: Storage;\ndeclare var localStorage: Storage;\ndeclare var console: Console;\n/**\n * Fires when the user aborts the download.\n * @param ev The event.\n */\ndeclare var onabort: ((this: Window, ev: UIEvent) => any) | null;\ndeclare var onanimationcancel: ((this: Window, ev: AnimationEvent) => any) | null;\ndeclare var onanimationend: ((this: Window, ev: AnimationEvent) => any) | null;\ndeclare var onanimationiteration: ((this: Window, ev: AnimationEvent) => any) | null;\ndeclare var onanimationstart: ((this: Window, ev: AnimationEvent) => any) | null;\ndeclare var onauxclick: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the object loses the input focus.\n * @param ev The focus event.\n */\ndeclare var onblur: ((this: Window, ev: FocusEvent) => any) | null;\ndeclare var oncancel: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when playback is possible, but would require further buffering.\n * @param ev The event.\n */\ndeclare var oncanplay: ((this: Window, ev: Event) => any) | null;\ndeclare var oncanplaythrough: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the contents of the object or selection have changed.\n * @param ev The event.\n */\ndeclare var onchange: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the user clicks the left mouse button on the object\n * @param ev The mouse event.\n */\ndeclare var onclick: ((this: Window, ev: MouseEvent) => any) | null;\ndeclare var onclose: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the user clicks the right mouse button in the client area, opening the context menu.\n * @param ev The mouse event.\n */\ndeclare var oncontextmenu: ((this: Window, ev: MouseEvent) => any) | null;\ndeclare var oncuechange: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the user double-clicks the object.\n * @param ev The mouse event.\n */\ndeclare var ondblclick: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Fires on the source object continuously during a drag operation.\n * @param ev The event.\n */\ndeclare var ondrag: ((this: Window, ev: DragEvent) => any) | null;\n/**\n * Fires on the source object when the user releases the mouse at the close of a drag operation.\n * @param ev The event.\n */\ndeclare var ondragend: ((this: Window, ev: DragEvent) => any) | null;\n/**\n * Fires on the target element when the user drags the object to a valid drop target.\n * @param ev The drag event.\n */\ndeclare var ondragenter: ((this: Window, ev: DragEvent) => any) | null;\ndeclare var ondragexit: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.\n * @param ev The drag event.\n */\ndeclare var ondragleave: ((this: Window, ev: DragEvent) => any) | null;\n/**\n * Fires on the target element continuously while the user drags the object over a valid drop target.\n * @param ev The event.\n */\ndeclare var ondragover: ((this: Window, ev: DragEvent) => any) | null;\n/**\n * Fires on the source object when the user starts to drag a text selection or selected object.\n * @param ev The event.\n */\ndeclare var ondragstart: ((this: Window, ev: DragEvent) => any) | null;\ndeclare var ondrop: ((this: Window, ev: DragEvent) => any) | null;\n/**\n * Occurs when the duration attribute is updated.\n * @param ev The event.\n */\ndeclare var ondurationchange: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the media element is reset to its initial state.\n * @param ev The event.\n */\ndeclare var onemptied: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the end of playback is reached.\n * @param ev The event\n */\ndeclare var onended: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when an error occurs during object loading.\n * @param ev The event.\n */\ndeclare var onerror: ErrorEventHandler;\n/**\n * Fires when the object receives focus.\n * @param ev The event.\n */\ndeclare var onfocus: ((this: Window, ev: FocusEvent) => any) | null;\ndeclare var ongotpointercapture: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var oninput: ((this: Window, ev: Event) => any) | null;\ndeclare var oninvalid: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the user presses a key.\n * @param ev The keyboard event\n */\ndeclare var onkeydown: ((this: Window, ev: KeyboardEvent) => any) | null;\n/**\n * Fires when the user presses an alphanumeric key.\n * @param ev The event.\n */\ndeclare var onkeypress: ((this: Window, ev: KeyboardEvent) => any) | null;\n/**\n * Fires when the user releases a key.\n * @param ev The keyboard event\n */\ndeclare var onkeyup: ((this: Window, ev: KeyboardEvent) => any) | null;\n/**\n * Fires immediately after the browser loads the object.\n * @param ev The event.\n */\ndeclare var onload: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when media data is loaded at the current playback position.\n * @param ev The event.\n */\ndeclare var onloadeddata: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the duration and dimensions of the media have been determined.\n * @param ev The event.\n */\ndeclare var onloadedmetadata: ((this: Window, ev: Event) => any) | null;\ndeclare var onloadend: ((this: Window, ev: ProgressEvent) => any) | null;\n/**\n * Occurs when Internet Explorer begins looking for media data.\n * @param ev The event.\n */\ndeclare var onloadstart: ((this: Window, ev: Event) => any) | null;\ndeclare var onlostpointercapture: ((this: Window, ev: PointerEvent) => any) | null;\n/**\n * Fires when the user clicks the object with either mouse button.\n * @param ev The mouse event.\n */\ndeclare var onmousedown: ((this: Window, ev: MouseEvent) => any) | null;\ndeclare var onmouseenter: ((this: Window, ev: MouseEvent) => any) | null;\ndeclare var onmouseleave: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Fires when the user moves the mouse over the object.\n * @param ev The mouse event.\n */\ndeclare var onmousemove: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Fires when the user moves the mouse pointer outside the boundaries of the object.\n * @param ev The mouse event.\n */\ndeclare var onmouseout: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Fires when the user moves the mouse pointer into the object.\n * @param ev The mouse event.\n */\ndeclare var onmouseover: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Fires when the user releases a mouse button while the mouse is over the object.\n * @param ev The mouse event.\n */\ndeclare var onmouseup: ((this: Window, ev: MouseEvent) => any) | null;\n/**\n * Occurs when playback is paused.\n * @param ev The event.\n */\ndeclare var onpause: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the play method is requested.\n * @param ev The event.\n */\ndeclare var onplay: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the audio or video has started playing.\n * @param ev The event.\n */\ndeclare var onplaying: ((this: Window, ev: Event) => any) | null;\ndeclare var onpointercancel: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerdown: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerenter: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerleave: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointermove: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerout: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerover: ((this: Window, ev: PointerEvent) => any) | null;\ndeclare var onpointerup: ((this: Window, ev: PointerEvent) => any) | null;\n/**\n * Occurs to indicate progress while downloading media data.\n * @param ev The event.\n */\ndeclare var onprogress: ((this: Window, ev: ProgressEvent) => any) | null;\n/**\n * Occurs when the playback rate is increased or decreased.\n * @param ev The event.\n */\ndeclare var onratechange: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the user resets a form.\n * @param ev The event.\n */\ndeclare var onreset: ((this: Window, ev: Event) => any) | null;\ndeclare var onresize: ((this: Window, ev: UIEvent) => any) | null;\n/**\n * Fires when the user repositions the scroll box in the scroll bar on the object.\n * @param ev The event.\n */\ndeclare var onscroll: ((this: Window, ev: UIEvent) => any) | null;\ndeclare var onsecuritypolicyviolation: ((this: Window, ev: SecurityPolicyViolationEvent) => any) | null;\n/**\n * Occurs when the seek operation ends.\n * @param ev The event.\n */\ndeclare var onseeked: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when the current playback position is moved.\n * @param ev The event.\n */\ndeclare var onseeking: ((this: Window, ev: Event) => any) | null;\n/**\n * Fires when the current selection changes.\n * @param ev The event.\n */\ndeclare var onselect: ((this: Window, ev: UIEvent) => any) | null;\n/**\n * Occurs when the download has stopped.\n * @param ev The event.\n */\ndeclare var onstalled: ((this: Window, ev: Event) => any) | null;\ndeclare var onsubmit: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs if the load operation has been intentionally halted.\n * @param ev The event.\n */\ndeclare var onsuspend: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs to indicate the current playback position.\n * @param ev The event.\n */\ndeclare var ontimeupdate: ((this: Window, ev: Event) => any) | null;\ndeclare var ontoggle: ((this: Window, ev: Event) => any) | null;\ndeclare var ontouchcancel: ((this: Window, ev: TouchEvent) => any) | null;\ndeclare var ontouchend: ((this: Window, ev: TouchEvent) => any) | null;\ndeclare var ontouchmove: ((this: Window, ev: TouchEvent) => any) | null;\ndeclare var ontouchstart: ((this: Window, ev: TouchEvent) => any) | null;\ndeclare var ontransitioncancel: ((this: Window, ev: TransitionEvent) => any) | null;\ndeclare var ontransitionend: ((this: Window, ev: TransitionEvent) => any) | null;\ndeclare var ontransitionrun: ((this: Window, ev: TransitionEvent) => any) | null;\ndeclare var ontransitionstart: ((this: Window, ev: TransitionEvent) => any) | null;\n/**\n * Occurs when the volume is changed, or playback is muted or unmuted.\n * @param ev The event.\n */\ndeclare var onvolumechange: ((this: Window, ev: Event) => any) | null;\n/**\n * Occurs when playback stops because the next frame of a video resource is not available.\n * @param ev The event.\n */\ndeclare var onwaiting: ((this: Window, ev: Event) => any) | null;\ndeclare var onwheel: ((this: Window, ev: WheelEvent) => any) | null;\ndeclare var indexedDB: IDBFactory;\ndeclare function atob(encodedString: string): string;\ndeclare function btoa(rawString: string): string;\ndeclare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\ndeclare var caches: CacheStorage;\ndeclare var crypto: Crypto;\ndeclare var indexedDB: IDBFactory;\ndeclare var origin: string;\ndeclare var performance: Performance;\ndeclare function atob(data: string): string;\ndeclare function btoa(data: string): string;\ndeclare function clearInterval(handle?: number): void;\ndeclare function clearTimeout(handle?: number): void;\ndeclare function createImageBitmap(image: ImageBitmapSource): Promise<ImageBitmap>;\ndeclare function createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number): Promise<ImageBitmap>;\ndeclare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\ndeclare function queueMicrotask(callback: Function): void;\ndeclare function setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\ndeclare function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\ndeclare var sessionStorage: Storage;\ndeclare var localStorage: Storage;\ndeclare var onafterprint: ((this: Window, ev: Event) => any) | null;\ndeclare var onbeforeprint: ((this: Window, ev: Event) => any) | null;\ndeclare var onbeforeunload: ((this: Window, ev: BeforeUnloadEvent) => any) | null;\ndeclare var onhashchange: ((this: Window, ev: HashChangeEvent) => any) | null;\ndeclare var onlanguagechange: ((this: Window, ev: Event) => any) | null;\ndeclare var onmessage: ((this: Window, ev: MessageEvent) => any) | null;\ndeclare var onmessageerror: ((this: Window, ev: MessageEvent) => any) | null;\ndeclare var onoffline: ((this: Window, ev: Event) => any) | null;\ndeclare var ononline: ((this: Window, ev: Event) => any) | null;\ndeclare var onpagehide: ((this: Window, ev: PageTransitionEvent) => any) | null;\ndeclare var onpageshow: ((this: Window, ev: PageTransitionEvent) => any) | null;\ndeclare var onpopstate: ((this: Window, ev: PopStateEvent) => any) | null;\ndeclare var onrejectionhandled: ((this: Window, ev: Event) => any) | null;\ndeclare var onstorage: ((this: Window, ev: StorageEvent) => any) | null;\ndeclare var onunhandledrejection: ((this: Window, ev: PromiseRejectionEvent) => any) | null;\ndeclare var onunload: ((this: Window, ev: Event) => any) | null;\ndeclare function addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\ndeclare function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\ndeclare function removeEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\ndeclare function removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\ntype BlobPart = BufferSource | Blob | string;\ntype HeadersInit = Headers | string[][] | Record<string, string>;\ntype BodyInit = Blob | BufferSource | FormData | URLSearchParams | ReadableStream<Uint8Array> | string;\ntype RequestInfo = Request | string;\ntype DOMHighResTimeStamp = number;\ntype RenderingContext = CanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext;\ntype HTMLOrSVGImageElement = HTMLImageElement | SVGImageElement;\ntype CanvasImageSource = HTMLOrSVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap;\ntype MessageEventSource = WindowProxy | MessagePort | ServiceWorker;\ntype HTMLOrSVGScriptElement = HTMLScriptElement | SVGScriptElement;\ntype ImageBitmapSource = CanvasImageSource | Blob | ImageData;\ntype OnErrorEventHandler = OnErrorEventHandlerNonNull | null;\ntype OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull | null;\ntype TimerHandler = string | Function;\ntype PerformanceEntryList = PerformanceEntry[];\ntype VibratePattern = number | number[];\ntype AlgorithmIdentifier = string | Algorithm;\ntype HashAlgorithmIdentifier = AlgorithmIdentifier;\ntype BigInteger = Uint8Array;\ntype NamedCurve = string;\ntype GLenum = number;\ntype GLboolean = boolean;\ntype GLbitfield = number;\ntype GLint = number;\ntype GLsizei = number;\ntype GLintptr = number;\ntype GLsizeiptr = number;\ntype GLuint = number;\ntype GLfloat = number;\ntype GLclampf = number;\ntype TexImageSource = ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;\ntype Float32List = Float32Array | GLfloat[];\ntype Int32List = Int32Array | GLint[];\ntype BufferSource = ArrayBufferView | ArrayBuffer;\ntype DOMTimeStamp = number;\ntype LineAndPositionSetting = number | AutoKeyword;\ntype FormDataEntryValue = File | string;\ntype InsertPosition = "beforebegin" | "afterbegin" | "beforeend" | "afterend";\ntype IDBValidKey = number | string | Date | BufferSource | IDBArrayKey;\ntype MutationRecordType = "attributes" | "characterData" | "childList";\ntype ConstrainBoolean = boolean | ConstrainBooleanParameters;\ntype ConstrainDOMString = string | string[] | ConstrainDOMStringParameters;\ntype ConstrainDouble = number | ConstrainDoubleRange;\ntype ConstrainLong = number | ConstrainLongRange;\ntype IDBKeyPath = string;\ntype Transferable = ArrayBuffer | MessagePort | ImageBitmap;\ntype RTCIceGatherCandidate = RTCIceCandidateDictionary | RTCIceCandidateComplete;\ntype RTCTransport = RTCDtlsTransport | RTCSrtpSdesTransport;\n/** @deprecated */\ntype MouseWheelEvent = WheelEvent;\ntype WindowProxy = Window;\ntype AlignSetting = "start" | "center" | "end" | "left" | "right";\ntype AnimationPlayState = "idle" | "running" | "paused" | "finished";\ntype AppendMode = "segments" | "sequence";\ntype AudioContextLatencyCategory = "balanced" | "interactive" | "playback";\ntype AudioContextState = "suspended" | "running" | "closed";\ntype AutoKeyword = "auto";\ntype AutomationRate = "a-rate" | "k-rate";\ntype BinaryType = "blob" | "arraybuffer";\ntype BiquadFilterType = "lowpass" | "highpass" | "bandpass" | "lowshelf" | "highshelf" | "peaking" | "notch" | "allpass";\ntype CanPlayTypeResult = "" | "maybe" | "probably";\ntype CanvasDirection = "ltr" | "rtl" | "inherit";\ntype CanvasFillRule = "nonzero" | "evenodd";\ntype CanvasLineCap = "butt" | "round" | "square";\ntype CanvasLineJoin = "round" | "bevel" | "miter";\ntype CanvasTextAlign = "start" | "end" | "left" | "right" | "center";\ntype CanvasTextBaseline = "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";\ntype ChannelCountMode = "max" | "clamped-max" | "explicit";\ntype ChannelInterpretation = "speakers" | "discrete";\ntype ClientTypes = "window" | "worker" | "sharedworker" | "all";\ntype CompositeOperation = "replace" | "add" | "accumulate";\ntype CompositeOperationOrAuto = "replace" | "add" | "accumulate" | "auto";\ntype DirectionSetting = "" | "rl" | "lr";\ntype DisplayCaptureSurfaceType = "monitor" | "window" | "application" | "browser";\ntype DistanceModelType = "linear" | "inverse" | "exponential";\ntype DocumentReadyState = "loading" | "interactive" | "complete";\ntype EndOfStreamError = "network" | "decode";\ntype EndingType = "transparent" | "native";\ntype FillMode = "none" | "forwards" | "backwards" | "both" | "auto";\ntype GamepadHand = "" | "left" | "right";\ntype GamepadHapticActuatorType = "vibration";\ntype GamepadInputEmulationType = "mouse" | "keyboard" | "gamepad";\ntype GamepadMappingType = "" | "standard";\ntype IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique";\ntype IDBRequestReadyState = "pending" | "done";\ntype IDBTransactionMode = "readonly" | "readwrite" | "versionchange";\ntype ImageSmoothingQuality = "low" | "medium" | "high";\ntype IterationCompositeOperation = "replace" | "accumulate";\ntype KeyFormat = "raw" | "spki" | "pkcs8" | "jwk";\ntype KeyType = "public" | "private" | "secret";\ntype KeyUsage = "encrypt" | "decrypt" | "sign" | "verify" | "deriveKey" | "deriveBits" | "wrapKey" | "unwrapKey";\ntype LineAlignSetting = "start" | "center" | "end";\ntype ListeningState = "inactive" | "active" | "disambiguation";\ntype MSCredentialType = "FIDO_2_0";\ntype MSTransportType = "Embedded" | "USB" | "NFC" | "BT";\ntype MSWebViewPermissionState = "unknown" | "defer" | "allow" | "deny";\ntype MSWebViewPermissionType = "geolocation" | "unlimitedIndexedDBQuota" | "media" | "pointerlock" | "webnotifications";\ntype MediaDeviceKind = "audioinput" | "audiooutput" | "videoinput";\ntype MediaKeyMessageType = "license-request" | "license-renewal" | "license-release" | "individualization-request";\ntype MediaKeySessionType = "temporary" | "persistent-license" | "persistent-release-message";\ntype MediaKeyStatus = "usable" | "expired" | "output-downscaled" | "output-not-allowed" | "status-pending" | "internal-error";\ntype MediaKeysRequirement = "required" | "optional" | "not-allowed";\ntype MediaStreamTrackState = "live" | "ended";\ntype NavigationReason = "up" | "down" | "left" | "right";\ntype NavigationType = "navigate" | "reload" | "back_forward" | "prerender";\ntype NotificationDirection = "auto" | "ltr" | "rtl";\ntype NotificationPermission = "default" | "denied" | "granted";\ntype OrientationLockType = "any" | "natural" | "landscape" | "portrait" | "portrait-primary" | "portrait-secondary" | "landscape-primary" | "landscape-secondary";\ntype OrientationType = "portrait-primary" | "portrait-secondary" | "landscape-primary" | "landscape-secondary";\ntype OscillatorType = "sine" | "square" | "sawtooth" | "triangle" | "custom";\ntype OverSampleType = "none" | "2x" | "4x";\ntype PanningModelType = "equalpower" | "HRTF";\ntype PaymentComplete = "success" | "fail" | "unknown";\ntype PaymentShippingType = "shipping" | "delivery" | "pickup";\ntype PlaybackDirection = "normal" | "reverse" | "alternate" | "alternate-reverse";\ntype PositionAlignSetting = "line-left" | "center" | "line-right" | "auto";\ntype PushEncryptionKeyName = "p256dh" | "auth";\ntype PushPermissionState = "denied" | "granted" | "prompt";\ntype RTCBundlePolicy = "balanced" | "max-compat" | "max-bundle";\ntype RTCDataChannelState = "connecting" | "open" | "closing" | "closed";\ntype RTCDegradationPreference = "maintain-framerate" | "maintain-resolution" | "balanced";\ntype RTCDtlsRole = "auto" | "client" | "server";\ntype RTCDtlsTransportState = "new" | "connecting" | "connected" | "closed" | "failed";\ntype RTCDtxStatus = "disabled" | "enabled";\ntype RTCErrorDetailType = "data-channel-failure" | "dtls-failure" | "fingerprint-failure" | "idp-bad-script-failure" | "idp-execution-failure" | "idp-load-failure" | "idp-need-login" | "idp-timeout" | "idp-tls-failure" | "idp-token-expired" | "idp-token-invalid" | "sctp-failure" | "sdp-syntax-error" | "hardware-encoder-not-available" | "hardware-encoder-error";\ntype RTCIceCandidateType = "host" | "srflx" | "prflx" | "relay";\ntype RTCIceComponent = "rtp" | "rtcp";\ntype RTCIceConnectionState = "new" | "checking" | "connected" | "completed" | "disconnected" | "failed" | "closed";\ntype RTCIceCredentialType = "password" | "oauth";\ntype RTCIceGatherPolicy = "all" | "nohost" | "relay";\ntype RTCIceGathererState = "new" | "gathering" | "complete";\ntype RTCIceGatheringState = "new" | "gathering" | "complete";\ntype RTCIceProtocol = "udp" | "tcp";\ntype RTCIceRole = "controlling" | "controlled";\ntype RTCIceTcpCandidateType = "active" | "passive" | "so";\ntype RTCIceTransportPolicy = "relay" | "all";\ntype RTCIceTransportState = "new" | "checking" | "connected" | "completed" | "disconnected" | "failed" | "closed";\ntype RTCPeerConnectionState = "new" | "connecting" | "connected" | "disconnected" | "failed" | "closed";\ntype RTCPriorityType = "very-low" | "low" | "medium" | "high";\ntype RTCRtcpMuxPolicy = "negotiate" | "require";\ntype RTCRtpTransceiverDirection = "sendrecv" | "sendonly" | "recvonly" | "inactive";\ntype RTCSctpTransportState = "connecting" | "connected" | "closed";\ntype RTCSdpType = "offer" | "pranswer" | "answer" | "rollback";\ntype RTCSignalingState = "stable" | "have-local-offer" | "have-remote-offer" | "have-local-pranswer" | "have-remote-pranswer" | "closed";\ntype RTCStatsIceCandidatePairState = "frozen" | "waiting" | "inprogress" | "failed" | "succeeded" | "cancelled";\ntype RTCStatsIceCandidateType = "host" | "serverreflexive" | "peerreflexive" | "relayed";\ntype RTCStatsType = "inboundrtp" | "outboundrtp" | "session" | "datachannel" | "track" | "transport" | "candidatepair" | "localcandidate" | "remotecandidate";\ntype ReadyState = "closed" | "open" | "ended";\ntype ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin-only" | "origin-when-cross-origin" | "unsafe-url";\ntype RequestCache = "default" | "no-store" | "reload" | "no-cache" | "force-cache" | "only-if-cached";\ntype RequestCredentials = "omit" | "same-origin" | "include";\ntype RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt";\ntype RequestMode = "navigate" | "same-origin" | "no-cors" | "cors";\ntype RequestRedirect = "follow" | "error" | "manual";\ntype ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";\ntype ScopedCredentialType = "ScopedCred";\ntype ScrollBehavior = "auto" | "smooth";\ntype ScrollLogicalPosition = "start" | "center" | "end" | "nearest";\ntype ScrollRestoration = "auto" | "manual";\ntype ScrollSetting = "" | "up";\ntype SelectionMode = "select" | "start" | "end" | "preserve";\ntype ServiceWorkerState = "installing" | "installed" | "activating" | "activated" | "redundant";\ntype ServiceWorkerUpdateViaCache = "imports" | "all" | "none";\ntype ShadowRootMode = "open" | "closed";\ntype SpeechRecognitionErrorCode = "no-speech" | "aborted" | "audio-capture" | "network" | "not-allowed" | "service-not-allowed" | "bad-grammar" | "language-not-supported";\ntype SpeechSynthesisErrorCode = "canceled" | "interrupted" | "audio-busy" | "audio-hardware" | "network" | "synthesis-unavailable" | "synthesis-failed" | "language-unavailable" | "voice-unavailable" | "text-too-long" | "invalid-argument";\ntype SupportedType = "text/html" | "text/xml" | "application/xml" | "application/xhtml+xml" | "image/svg+xml";\ntype TextTrackKind = "subtitles" | "captions" | "descriptions" | "chapters" | "metadata";\ntype TextTrackMode = "disabled" | "hidden" | "showing";\ntype TouchType = "direct" | "stylus";\ntype Transport = "usb" | "nfc" | "ble";\ntype VRDisplayEventReason = "mounted" | "navigation" | "requested" | "unmounted";\ntype VideoFacingModeEnum = "user" | "environment" | "left" | "right";\ntype VisibilityState = "hidden" | "visible" | "prerender";\ntype WebGLPowerPreference = "default" | "low-power" | "high-performance";\ntype WorkerType = "classic" | "module";\ntype XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text";\n'},193:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/////////////////////////////\n/// DOM Iterable APIs\n/////////////////////////////\n\ninterface AudioParamMap extends ReadonlyMap<string, AudioParam> {\n}\n\ninterface AudioTrackList {\n    [Symbol.iterator](): IterableIterator<AudioTrack>;\n}\n\ninterface CSSRuleList {\n    [Symbol.iterator](): IterableIterator<CSSRule>;\n}\n\ninterface CSSStyleDeclaration {\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface ClientRectList {\n    [Symbol.iterator](): IterableIterator<ClientRect>;\n}\n\ninterface DOMRectList {\n    [Symbol.iterator](): IterableIterator<DOMRect>;\n}\n\ninterface DOMStringList {\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface DOMTokenList {\n    [Symbol.iterator](): IterableIterator<string>;\n    entries(): IterableIterator<[number, string]>;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<string>;\n}\n\ninterface DataTransferItemList {\n    [Symbol.iterator](): IterableIterator<DataTransferItem>;\n}\n\ninterface FileList {\n    [Symbol.iterator](): IterableIterator<File>;\n}\n\ninterface FormData {\n    [Symbol.iterator](): IterableIterator<[string, FormDataEntryValue]>;\n    /**\n     * Returns an array of key, value pairs for every entry in the list.\n     */\n    entries(): IterableIterator<[string, FormDataEntryValue]>;\n    /**\n     * Returns a list of keys in the list.\n     */\n    keys(): IterableIterator<string>;\n    /**\n     * Returns a list of values in the list.\n     */\n    values(): IterableIterator<FormDataEntryValue>;\n}\n\ninterface HTMLAllCollection {\n    [Symbol.iterator](): IterableIterator<Element>;\n}\n\ninterface HTMLCollectionBase {\n    [Symbol.iterator](): IterableIterator<Element>;\n}\n\ninterface HTMLCollectionOf<T extends Element> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n\ninterface HTMLFormElement {\n    [Symbol.iterator](): IterableIterator<Element>;\n}\n\ninterface HTMLSelectElement {\n    [Symbol.iterator](): IterableIterator<Element>;\n}\n\ninterface Headers {\n    [Symbol.iterator](): IterableIterator<[string, string]>;\n    /**\n     * Returns an iterator allowing to go through all key/value pairs contained in this object.\n     */\n    entries(): IterableIterator<[string, string]>;\n    /**\n     * Returns an iterator allowing to go through all keys of the key/value pairs contained in this object.\n     */\n    keys(): IterableIterator<string>;\n    /**\n     * Returns an iterator allowing to go through all values of the key/value pairs contained in this object.\n     */\n    values(): IterableIterator<string>;\n}\n\ninterface MediaList {\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface MimeTypeArray {\n    [Symbol.iterator](): IterableIterator<Plugin>;\n}\n\ninterface NamedNodeMap {\n    [Symbol.iterator](): IterableIterator<Attr>;\n}\n\ninterface NodeList {\n    [Symbol.iterator](): IterableIterator<Node>;\n    /**\n     * Returns an array of key, value pairs for every entry in the list.\n     */\n    entries(): IterableIterator<[number, Node]>;\n    /**\n     * Returns an list of keys in the list.\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the list.\n     */\n    values(): IterableIterator<Node>;\n}\n\ninterface NodeListOf<TNode extends Node> {\n    [Symbol.iterator](): IterableIterator<TNode>;\n    /**\n     * Returns an array of key, value pairs for every entry in the list.\n     */\n    entries(): IterableIterator<[number, TNode]>;\n    /**\n     * Returns an list of keys in the list.\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the list.\n     */\n    values(): IterableIterator<TNode>;\n}\n\ninterface Plugin {\n    [Symbol.iterator](): IterableIterator<MimeType>;\n}\n\ninterface PluginArray {\n    [Symbol.iterator](): IterableIterator<Plugin>;\n}\n\ninterface RTCStatsReport extends ReadonlyMap<string, any> {\n}\n\ninterface SVGLengthList {\n    [Symbol.iterator](): IterableIterator<SVGLength>;\n}\n\ninterface SVGNumberList {\n    [Symbol.iterator](): IterableIterator<SVGNumber>;\n}\n\ninterface SVGStringList {\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface SourceBufferList {\n    [Symbol.iterator](): IterableIterator<SourceBuffer>;\n}\n\ninterface SpeechGrammarList {\n    [Symbol.iterator](): IterableIterator<SpeechGrammar>;\n}\n\ninterface SpeechRecognitionResult {\n    [Symbol.iterator](): IterableIterator<SpeechRecognitionAlternative>;\n}\n\ninterface SpeechRecognitionResultList {\n    [Symbol.iterator](): IterableIterator<SpeechRecognitionResult>;\n}\n\ninterface StyleSheetList {\n    [Symbol.iterator](): IterableIterator<StyleSheet>;\n}\n\ninterface TextTrackCueList {\n    [Symbol.iterator](): IterableIterator<TextTrackCue>;\n}\n\ninterface TextTrackList {\n    [Symbol.iterator](): IterableIterator<TextTrack>;\n}\n\ninterface TouchList {\n    [Symbol.iterator](): IterableIterator<Touch>;\n}\n\ninterface URLSearchParams {\n    [Symbol.iterator](): IterableIterator<[string, string]>;\n    /**\n     * Returns an array of key, value pairs for every entry in the search params.\n     */\n    entries(): IterableIterator<[string, string]>;\n    /**\n     * Returns a list of keys in the search params.\n     */\n    keys(): IterableIterator<string>;\n    /**\n     * Returns a list of values in the search params.\n     */\n    values(): IterableIterator<string>;\n}\n\ninterface VideoTrackList {\n    [Symbol.iterator](): IterableIterator<VideoTrack>;\n}\n'},194:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface Map<K, V> {\n    clear(): void;\n    delete(key: K): boolean;\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    set(key: K, value: V): this;\n    readonly size: number;\n}\n\ninterface MapConstructor {\n    new(): Map<any, any>;\n    new<K, V>(entries?: ReadonlyArray<[K, V]> | null): Map<K, V>;\n    readonly prototype: Map<any, any>;\n}\ndeclare var Map: MapConstructor;\n\ninterface ReadonlyMap<K, V> {\n    forEach(callbackfn: (value: V, key: K, map: ReadonlyMap<K, V>) => void, thisArg?: any): void;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    readonly size: number;\n}\n\ninterface WeakMap<K extends object, V> {\n    delete(key: K): boolean;\n    get(key: K): V | undefined;\n    has(key: K): boolean;\n    set(key: K, value: V): this;\n}\n\ninterface WeakMapConstructor {\n    new <K extends object = object, V = any>(entries?: ReadonlyArray<[K, V]> | null): WeakMap<K, V>;\n    readonly prototype: WeakMap<object, any>;\n}\ndeclare var WeakMap: WeakMapConstructor;\n\ninterface Set<T> {\n    add(value: T): this;\n    clear(): void;\n    delete(value: T): boolean;\n    forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    readonly size: number;\n}\n\ninterface SetConstructor {\n    new <T = any>(values?: ReadonlyArray<T> | null): Set<T>;\n    readonly prototype: Set<any>;\n}\ndeclare var Set: SetConstructor;\n\ninterface ReadonlySet<T> {\n    forEach(callbackfn: (value: T, value2: T, set: ReadonlySet<T>) => void, thisArg?: any): void;\n    has(value: T): boolean;\n    readonly size: number;\n}\n\ninterface WeakSet<T extends object> {\n    add(value: T): this;\n    delete(value: T): boolean;\n    has(value: T): boolean;\n}\n\ninterface WeakSetConstructor {\n    new <T extends object = object>(values?: ReadonlyArray<T> | null): WeakSet<T>;\n    readonly prototype: WeakSet<object>;\n}\ndeclare var WeakSet: WeakSetConstructor;\n'},195:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface Array<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: T, start?: number, end?: number): this;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an array-like object.\n     * @param arrayLike An array-like object to convert to an array.\n     */\n    from<T>(arrayLike: ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param arrayLike An array-like object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of<T>(...items: T[]): T[];\n}\n\ninterface DateConstructor {\n    new (value: number | string | Date): Date;\n}\n\ninterface Function {\n    /**\n     * Returns the name of the function. Function names are read-only and can not be changed.\n     */\n    readonly name: string;\n}\n\ninterface Math {\n    /**\n     * Returns the number of leading zero bits in the 32-bit binary representation of a number.\n     * @param x A numeric expression.\n     */\n    clz32(x: number): number;\n\n    /**\n     * Returns the result of 32-bit multiplication of two numbers.\n     * @param x First number\n     * @param y Second number\n     */\n    imul(x: number, y: number): number;\n\n    /**\n     * Returns the sign of the x, indicating whether x is positive, negative or zero.\n     * @param x The numeric expression to test\n     */\n    sign(x: number): number;\n\n    /**\n     * Returns the base 10 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log10(x: number): number;\n\n    /**\n     * Returns the base 2 logarithm of a number.\n     * @param x A numeric expression.\n     */\n    log2(x: number): number;\n\n    /**\n     * Returns the natural logarithm of 1 + x.\n     * @param x A numeric expression.\n     */\n    log1p(x: number): number;\n\n    /**\n     * Returns the result of (e^x - 1), which is an implementation-dependent approximation to\n     * subtracting 1 from the exponential function of x (e raised to the power of x, where e\n     * is the base of the natural logarithms).\n     * @param x A numeric expression.\n     */\n    expm1(x: number): number;\n\n    /**\n     * Returns the hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    cosh(x: number): number;\n\n    /**\n     * Returns the hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    sinh(x: number): number;\n\n    /**\n     * Returns the hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    tanh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    acosh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    asinh(x: number): number;\n\n    /**\n     * Returns the inverse hyperbolic tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    atanh(x: number): number;\n\n    /**\n     * Returns the square root of the sum of squares of its arguments.\n     * @param values Values to compute the square root for.\n     *     If no arguments are passed, the result is +0.\n     *     If there is only one argument, the result is the absolute value.\n     *     If any argument is +Infinity or -Infinity, the result is +Infinity.\n     *     If any argument is NaN, the result is NaN.\n     *     If all arguments are either +0 or \u22120, the result is +0.\n     */\n    hypot(...values: number[]): number;\n\n    /**\n     * Returns the integral part of the a numeric expression, x, removing any fractional digits.\n     * If x is already an integer, the result is x.\n     * @param x A numeric expression.\n     */\n    trunc(x: number): number;\n\n    /**\n     * Returns the nearest single precision float representation of a number.\n     * @param x A numeric expression.\n     */\n    fround(x: number): number;\n\n    /**\n     * Returns an implementation-dependent approximation to the cube root of number.\n     * @param x A numeric expression.\n     */\n    cbrt(x: number): number;\n}\n\ninterface NumberConstructor {\n    /**\n     * The value of Number.EPSILON is the difference between 1 and the smallest value greater than 1\n     * that is representable as a Number value, which is approximately:\n     * 2.2204460492503130808472633361816 x 10\u200d\u2212\u200d16.\n     */\n    readonly EPSILON: number;\n\n    /**\n     * Returns true if passed value is finite.\n     * Unlike the global isFinite, Number.isFinite doesn\'t forcibly convert the parameter to a\n     * number. Only finite values of the type number, result in true.\n     * @param number A numeric value.\n     */\n    isFinite(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is an integer, false otherwise.\n     * @param number A numeric value.\n     */\n    isInteger(number: number): boolean;\n\n    /**\n     * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a\n     * number). Unlike the global isNaN(), Number.isNaN() doesn\'t forcefully convert the parameter\n     * to a number. Only values of the type number, that are also NaN, result in true.\n     * @param number A numeric value.\n     */\n    isNaN(number: number): boolean;\n\n    /**\n     * Returns true if the value passed is a safe integer.\n     * @param number A numeric value.\n     */\n    isSafeInteger(number: number): boolean;\n\n    /**\n     * The value of the largest integer n such that n and n + 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MAX_SAFE_INTEGER is 9007199254740991 2^53 \u2212 1.\n     */\n    readonly MAX_SAFE_INTEGER: number;\n\n    /**\n     * The value of the smallest integer n such that n and n \u2212 1 are both exactly representable as\n     * a Number value.\n     * The value of Number.MIN_SAFE_INTEGER is \u22129007199254740991 (\u2212(2^53 \u2212 1)).\n     */\n    readonly MIN_SAFE_INTEGER: number;\n\n    /**\n     * Converts a string to a floating-point number.\n     * @param string A string that contains a floating-point number.\n     */\n    parseFloat(string: string): number;\n\n    /**\n     * Converts A string to an integer.\n     * @param s A string to convert into a number.\n     * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n     * If this argument is not supplied, strings with a prefix of \'0x\' are considered hexadecimal.\n     * All other strings are considered decimal.\n     */\n    parseInt(string: string, radix?: number): number;\n}\n\ninterface ObjectConstructor {\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source The source object from which to copy properties.\n     */\n    assign<T, U>(target: T, source: U): T & U;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     */\n    assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param source1 The first source object from which to copy properties.\n     * @param source2 The second source object from which to copy properties.\n     * @param source3 The third source object from which to copy properties.\n     */\n    assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n\n    /**\n     * Copy the values of all of the enumerable own properties from one or more source objects to a\n     * target object. Returns the target object.\n     * @param target The target object to copy to.\n     * @param sources One or more source objects from which to copy properties\n     */\n    assign(target: object, ...sources: any[]): any;\n\n    /**\n     * Returns an array of all symbol properties found directly on object o.\n     * @param o Object to retrieve the symbols from.\n     */\n    getOwnPropertySymbols(o: any): symbol[];\n\n    /**\n     * Returns true if the values are the same value, false otherwise.\n     * @param value1 The first value.\n     * @param value2 The second value.\n     */\n    is(value1: any, value2: any): boolean;\n\n    /**\n     * Sets the prototype of a specified object o to  object proto or null. Returns the object o.\n     * @param o The object to change its prototype.\n     * @param proto The value of the new prototype or null.\n     */\n    setPrototypeOf(o: any, proto: object | null): any;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find<S extends T>(predicate: (this: void, value: T, index: number, obj: ReadonlyArray<T>) => value is S, thisArg?: any): S | undefined;\n    find(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): T | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: T, index: number, obj: ReadonlyArray<T>) => boolean, thisArg?: any): number;\n}\n\ninterface RegExp {\n    /**\n     * Returns a string indicating the flags of the regular expression in question. This field is read-only.\n     * The characters in this string are sequenced and concatenated in the following order:\n     *\n     *    - "g" for global\n     *    - "i" for ignoreCase\n     *    - "m" for multiline\n     *    - "u" for unicode\n     *    - "y" for sticky\n     *\n     * If no flags are set, the value is the empty string.\n     */\n    readonly flags: string;\n\n    /**\n     * Returns a Boolean value indicating the state of the sticky flag (y) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly sticky: boolean;\n\n    /**\n     * Returns a Boolean value indicating the state of the Unicode flag (u) used with a regular\n     * expression. Default is false. Read-only.\n     */\n    readonly unicode: boolean;\n}\n\ninterface RegExpConstructor {\n    new (pattern: RegExp, flags?: string): RegExp;\n    (pattern: RegExp, flags?: string): RegExp;\n}\n\ninterface String {\n    /**\n     * Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\n     * value of the UTF-16 encoded code point starting at the string element at position pos in\n     * the String resulting from converting this object to a String.\n     * If there is no element at that position, the result is undefined.\n     * If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.\n     */\n    codePointAt(pos: number): number | undefined;\n\n    /**\n     * Returns true if searchString appears as a substring of the result of converting this\n     * object to a String, at one or more positions that are\n     * greater than or equal to position; otherwise, returns false.\n     * @param searchString search string\n     * @param position If position is undefined, 0 is assumed, so as to search all of the String.\n     */\n    includes(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * endPosition \u2013 length(this). Otherwise returns false.\n     */\n    endsWith(searchString: string, endPosition?: number): boolean;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: "NFC", "NFD", "NFKC", or "NFKD", If not specified default\n     * is "NFC"\n     */\n    normalize(form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;\n\n    /**\n     * Returns the String value result of normalizing the string into the normalization form\n     * named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.\n     * @param form Applicable values: "NFC", "NFD", "NFKC", or "NFKD", If not specified default\n     * is "NFC"\n     */\n    normalize(form?: string): string;\n\n    /**\n     * Returns a String value that is made from count copies appended together. If count is 0,\n     * the empty string is returned.\n     * @param count number of copies to append\n     */\n    repeat(count: number): string;\n\n    /**\n     * Returns true if the sequence of elements of searchString converted to a String is the\n     * same as the corresponding elements of this object (converted to a String) starting at\n     * position. Otherwise returns false.\n     */\n    startsWith(searchString: string, position?: number): boolean;\n\n    /**\n     * Returns an <a> HTML anchor element and sets the name attribute to the text value\n     * @param name\n     */\n    anchor(name: string): string;\n\n    /** Returns a <big> HTML element */\n    big(): string;\n\n    /** Returns a <blink> HTML element */\n    blink(): string;\n\n    /** Returns a <b> HTML element */\n    bold(): string;\n\n    /** Returns a <tt> HTML element */\n    fixed(): string;\n\n    /** Returns a <font> HTML element and sets the color attribute value */\n    fontcolor(color: string): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: number): string;\n\n    /** Returns a <font> HTML element and sets the size attribute value */\n    fontsize(size: string): string;\n\n    /** Returns an <i> HTML element */\n    italics(): string;\n\n    /** Returns an <a> HTML element and sets the href attribute value */\n    link(url: string): string;\n\n    /** Returns a <small> HTML element */\n    small(): string;\n\n    /** Returns a <strike> HTML element */\n    strike(): string;\n\n    /** Returns a <sub> HTML element */\n    sub(): string;\n\n    /** Returns a <sup> HTML element */\n    sup(): string;\n}\n\ninterface StringConstructor {\n    /**\n     * Return the String value whose elements are, in order, the elements in the List elements.\n     * If length is 0, the empty string is returned.\n     */\n    fromCodePoint(...codePoints: number[]): string;\n\n    /**\n     * String.raw is intended for use as a tag function of a Tagged Template String. When called\n     * as such the first argument will be a well formed template call site object and the rest\n     * parameter will contain the substitution values.\n     * @param template A well-formed template string call site representation.\n     * @param substitutions A set of substitution values.\n     */\n    raw(template: TemplateStringsArray, ...substitutions: any[]): string;\n}\n'},196:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es5" />\n/// <reference lib="es2015.core" />\n/// <reference lib="es2015.collection" />\n/// <reference lib="es2015.generator" />\n/// <reference lib="es2015.promise" />\n/// <reference lib="es2015.iterable" />\n/// <reference lib="es2015.proxy" />\n/// <reference lib="es2015.reflect" />\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.symbol.wellknown" />\n'},197:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface Generator extends Iterator<any> { }\n\ninterface GeneratorFunction {\n    /**\n     * Creates a new Generator object.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: any[]): Generator;\n    /**\n     * Creates a new Generator object.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: any[]): Generator;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Generator;\n}\n\ninterface GeneratorFunctionConstructor {\n    /**\n     * Creates a new Generator function.\n     * @param args A list of arguments the function accepts.\n     */\n    new (...args: string[]): GeneratorFunction;\n    /**\n     * Creates a new Generator function.\n     * @param args A list of arguments the function accepts.\n     */\n    (...args: string[]): GeneratorFunction;\n    /**\n     * The length of the arguments.\n     */\n    readonly length: number;\n    /**\n     * Returns the name of the function.\n     */\n    readonly name: string;\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: GeneratorFunction;\n}\n'},198:function(e,n){e.exports="/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n/// <reference lib=\"es2015.symbol\" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that returns the default iterator for an object. Called by the semantics of the\n     * for-of statement.\n     */\n    readonly iterator: symbol;\n}\n\ninterface IteratorResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n    return?(value?: any): IteratorResult<T>;\n    throw?(e?: any): IteratorResult<T>;\n}\n\ninterface Iterable<T> {\n    [Symbol.iterator](): Iterator<T>;\n}\n\ninterface IterableIterator<T> extends Iterator<T> {\n    [Symbol.iterator](): IterableIterator<T>;\n}\n\ninterface Array<T> {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ArrayConstructor {\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     */\n    from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];\n\n    /**\n     * Creates an array from an iterable object.\n     * @param iterable An iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];\n}\n\ninterface ReadonlyArray<T> {\n    /** Iterator of values in the array. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, T]>;\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface IArguments {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<any>;\n}\n\ninterface Map<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface ReadonlyMap<K, V> {\n    /** Returns an iterable of entries in the map. */\n    [Symbol.iterator](): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the map.\n     */\n    entries(): IterableIterator<[K, V]>;\n\n    /**\n     * Returns an iterable of keys in the map\n     */\n    keys(): IterableIterator<K>;\n\n    /**\n     * Returns an iterable of values in the map\n     */\n    values(): IterableIterator<V>;\n}\n\ninterface MapConstructor {\n    new <K, V>(iterable: Iterable<[K, V]>): Map<K, V>;\n}\n\ninterface WeakMap<K extends object, V> { }\n\ninterface WeakMapConstructor {\n    new <K extends object, V>(iterable: Iterable<[K, V]>): WeakMap<K, V>;\n}\n\ninterface Set<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface ReadonlySet<T> {\n    /** Iterates over values in the set. */\n    [Symbol.iterator](): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of [v,v] pairs for every value `v` in the set.\n     */\n    entries(): IterableIterator<[T, T]>;\n\n    /**\n     * Despite its name, returns an iterable of the values in the set,\n     */\n    keys(): IterableIterator<T>;\n\n    /**\n     * Returns an iterable of values in the set.\n     */\n    values(): IterableIterator<T>;\n}\n\ninterface SetConstructor {\n    new <T>(iterable: Iterable<T>): Set<T>;\n}\n\ninterface WeakSet<T extends object> { }\n\ninterface WeakSetConstructor {\n    new <T extends object = object>(iterable: Iterable<T>): WeakSet<T>;\n}\n\ninterface Promise<T> { }\n\ninterface PromiseConstructor {\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<TAll>(values: Iterable<TAll | PromiseLike<TAll>>): Promise<TAll[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\n}\n\ndeclare namespace Reflect {\n    function enumerate(target: object): IterableIterator<any>;\n}\n\ninterface String {\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<string>;\n}\n\ninterface Int8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int8ArrayConstructor {\n    new (elements: Iterable<number>): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n}\n\ninterface Uint8Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ArrayConstructor {\n    new (elements: Iterable<number>): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n}\n\ninterface Uint8ClampedArray {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    new (elements: Iterable<number>): Uint8ClampedArray;\n\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\n\ninterface Int16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int16ArrayConstructor {\n    new (elements: Iterable<number>): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n}\n\ninterface Uint16Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint16ArrayConstructor {\n    new (elements: Iterable<number>): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n}\n\ninterface Int32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Int32ArrayConstructor {\n    new (elements: Iterable<number>): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n}\n\ninterface Uint32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Uint32ArrayConstructor {\n    new (elements: Iterable<number>): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n}\n\ninterface Float32Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float32ArrayConstructor {\n    new (elements: Iterable<number>): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n}\n\ninterface Float64Array {\n    [Symbol.iterator](): IterableIterator<number>;\n    /**\n     * Returns an array of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, number]>;\n    /**\n     * Returns an list of keys in the array\n     */\n    keys(): IterableIterator<number>;\n    /**\n     * Returns an list of values in the array\n     */\n    values(): IterableIterator<number>;\n}\n\ninterface Float64ArrayConstructor {\n    new (elements: Iterable<number>): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of 'this' used to invoke the mapfn.\n     */\n    from(arrayLike: Iterable<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n}\n"},199:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface PromiseConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Promise<any>;\n\n    /**\n     * Creates a new Promise.\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\n     * and a reject callback used to reject the promise with a provided reason or error.\n     */\n    new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;\n\n    /**\n     * Creates a Promise that is resolved with an array of results when all of the provided Promises\n     * resolve, or rejected when any Promise is rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<T1 | T2 | T3 | T4 | T5 | T6 | T7>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<T1 | T2 | T3 | T4 | T5 | T6>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>]): Promise<T1 | T2 | T3 | T4 | T5>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>]): Promise<T1 | T2 | T3 | T4>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<T1 | T2 | T3>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<T1 | T2>;\n\n    /**\n     * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n     * or rejected.\n     * @param values An array of Promises.\n     * @returns A new Promise.\n     */\n    race<T>(values: (T | PromiseLike<T>)[]): Promise<T>;\n\n    /**\n     * Creates a new rejected promise for the provided reason.\n     * @param reason The reason the promise was rejected.\n     * @returns A new rejected Promise.\n     */\n    reject<T = never>(reason?: any): Promise<T>;\n\n    /**\n     * Creates a new resolved promise for the provided value.\n     * @param value A promise.\n     * @returns A promise whose internal state matches the provided promise.\n     */\n    resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\n    /**\n     * Creates a new resolved promise .\n     * @returns A resolved promise.\n     */\n    resolve(): Promise<void>;\n}\n\ndeclare var Promise: PromiseConstructor;\n'},200:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface ProxyHandler<T extends object> {\n    getPrototypeOf? (target: T): object | null;\n    setPrototypeOf? (target: T, v: any): boolean;\n    isExtensible? (target: T): boolean;\n    preventExtensions? (target: T): boolean;\n    getOwnPropertyDescriptor? (target: T, p: PropertyKey): PropertyDescriptor | undefined;\n    has? (target: T, p: PropertyKey): boolean;\n    get? (target: T, p: PropertyKey, receiver: any): any;\n    set? (target: T, p: PropertyKey, value: any, receiver: any): boolean;\n    deleteProperty? (target: T, p: PropertyKey): boolean;\n    defineProperty? (target: T, p: PropertyKey, attributes: PropertyDescriptor): boolean;\n    enumerate? (target: T): PropertyKey[];\n    ownKeys? (target: T): PropertyKey[];\n    apply? (target: T, thisArg: any, argArray?: any): any;\n    construct? (target: T, argArray: any, newTarget?: any): object;\n}\n\ninterface ProxyConstructor {\n    revocable<T extends object>(target: T, handler: ProxyHandler<T>): { proxy: T; revoke: () => void; };\n    new <T extends object>(target: T, handler: ProxyHandler<T>): T;\n}\ndeclare var Proxy: ProxyConstructor;\n'},201:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ndeclare namespace Reflect {\n    function apply(target: Function, thisArgument: any, argumentsList: ArrayLike<any>): any;\n    function construct(target: Function, argumentsList: ArrayLike<any>, newTarget?: any): any;\n    function defineProperty(target: object, propertyKey: PropertyKey, attributes: PropertyDescriptor): boolean;\n    function deleteProperty(target: object, propertyKey: PropertyKey): boolean;\n    function get(target: object, propertyKey: PropertyKey, receiver?: any): any;\n    function getOwnPropertyDescriptor(target: object, propertyKey: PropertyKey): PropertyDescriptor | undefined;\n    function getPrototypeOf(target: object): object;\n    function has(target: object, propertyKey: PropertyKey): boolean;\n    function isExtensible(target: object): boolean;\n    function ownKeys(target: object): PropertyKey[];\n    function preventExtensions(target: object): boolean;\n    function set(target: object, propertyKey: PropertyKey, value: any, receiver?: any): boolean;\n    function setPrototypeOf(target: object, proto: any): boolean;\n}\n'},202:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface SymbolConstructor {\n    /**\n     * A reference to the prototype.\n     */\n    readonly prototype: Symbol;\n\n    /**\n     * Returns a new unique Symbol value.\n     * @param  description Description of the new Symbol object.\n     */\n    (description?: string | number): symbol;\n\n    /**\n     * Returns a Symbol object from the global symbol registry matching the given key if found.\n     * Otherwise, returns a new symbol with this key.\n     * @param key key to search for.\n     */\n    for(key: string): symbol;\n\n    /**\n     * Returns a key from the global symbol registry matching the given Symbol if found.\n     * Otherwise, returns a undefined.\n     * @param sym Symbol to find the key for.\n     */\n    keyFor(sym: symbol): string | undefined;\n}\n\ndeclare var Symbol: SymbolConstructor;'},203:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es2015.symbol" />\n\ninterface SymbolConstructor {\n    /**\n     * A method that determines if a constructor object recognizes an object as one of the\n     * constructor\u2019s instances. Called by the semantics of the instanceof operator.\n     */\n    readonly hasInstance: symbol;\n\n    /**\n     * A Boolean value that if true indicates that an object should flatten to its array elements\n     * by Array.prototype.concat.\n     */\n    readonly isConcatSpreadable: symbol;\n\n    /**\n     * A regular expression method that matches the regular expression against a string. Called\n     * by the String.prototype.match method.\n     */\n    readonly match: symbol;\n\n    /**\n     * A regular expression method that replaces matched substrings of a string. Called by the\n     * String.prototype.replace method.\n     */\n    readonly replace: symbol;\n\n    /**\n     * A regular expression method that returns the index within a string that matches the\n     * regular expression. Called by the String.prototype.search method.\n     */\n    readonly search: symbol;\n\n    /**\n     * A function valued property that is the constructor function that is used to create\n     * derived objects.\n     */\n    readonly species: symbol;\n\n    /**\n     * A regular expression method that splits a string at the indices that match the regular\n     * expression. Called by the String.prototype.split method.\n     */\n    readonly split: symbol;\n\n    /**\n     * A method that converts an object to a corresponding primitive value.\n     * Called by the ToPrimitive abstract operation.\n     */\n    readonly toPrimitive: symbol;\n\n    /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */\n    readonly toStringTag: symbol;\n\n    /**\n     * An Object whose own property names are property names that are excluded from the \'with\'\n     * environment bindings of the associated objects.\n     */\n    readonly unscopables: symbol;\n}\n\ninterface Symbol {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Array<T> {\n    /**\n     * Returns an object whose properties have the value \'true\'\n     * when they will be absent when used in a \'with\' statement.\n     */\n    [Symbol.unscopables](): {\n        copyWithin: boolean;\n        entries: boolean;\n        fill: boolean;\n        find: boolean;\n        findIndex: boolean;\n        keys: boolean;\n        values: boolean;\n    };\n}\n\ninterface Date {\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: "default"): string;\n    /**\n     * Converts a Date object to a string.\n     */\n    [Symbol.toPrimitive](hint: "string"): string;\n    /**\n     * Converts a Date object to a number.\n     */\n    [Symbol.toPrimitive](hint: "number"): number;\n    /**\n     * Converts a Date object to a string or number.\n     *\n     * @param hint The strings "number", "string", or "default" to specify what primitive to return.\n     *\n     * @throws {TypeError} If \'hint\' was given something other than "number", "string", or "default".\n     * @returns A number if \'hint\' was "number", a string if \'hint\' was "string" or "default".\n     */\n    [Symbol.toPrimitive](hint: string): string | number;\n}\n\ninterface Map<K, V> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface WeakMap<K extends object, V> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Set<T> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface WeakSet<T extends object> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface JSON {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Function {\n    /**\n     * Determines whether the given value inherits from this function if this function was used\n     * as a constructor function.\n     *\n     * A constructor function can control which objects are recognized as its instances by\n     * \'instanceof\' by overriding this method.\n     */\n    [Symbol.hasInstance](value: any): boolean;\n}\n\ninterface GeneratorFunction {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Math {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface PromiseConstructor {\n    readonly [Symbol.species]: PromiseConstructor;\n}\n\ninterface RegExp {\n    /**\n     * Matches a string with this regular expression, and returns an array containing the results of\n     * that search.\n     * @param string A string to search within.\n     */\n    [Symbol.match](string: string): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replaceValue A String object or string literal containing the text to replace for every\n     *                     successful match of this regular expression.\n     */\n    [Symbol.replace](string: string, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using this regular expression.\n     * @param string A String object or string literal whose contents matching against\n     *               this regular expression will be replaced\n     * @param replacer A function that returns the replacement text.\n     */\n    [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the position beginning first substring match in a regular expression search\n     * using this regular expression.\n     *\n     * @param string The string to search within.\n     */\n    [Symbol.search](string: string): number;\n\n    /**\n     * Returns an array of substrings that were delimited by strings in the original input that\n     * match against this regular expression.\n     *\n     * If the regular expression contains capturing parentheses, then each time this\n     * regular expression matches, the results (including any undefined results) of the\n     * capturing parentheses are spliced.\n     *\n     * @param string string value to split\n     * @param limit if not undefined, the output array is truncated so that it contains no more\n     * than \'limit\' elements.\n     */\n    [Symbol.split](string: string, limit?: number): string[];\n}\n\ninterface RegExpConstructor {\n    readonly [Symbol.species]: RegExpConstructor;\n}\n\ninterface String {\n    /**\n     * Matches a string an object that supports being matched against, and returns an array containing the results of that search.\n     * @param matcher An object that supports being matched against.\n     */\n    match(matcher: { [Symbol.match](string: string): RegExpMatchArray | null; }): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using an object that supports replacement within a string.\n     * @param searchValue A object can search for and replace matches within a string.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param searcher An object which supports searching within a string.\n     */\n    search(searcher: { [Symbol.search](string: string): number; }): number;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param splitter An object that can split a string.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[];\n}\n\ninterface ArrayBuffer {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface DataView {\n    readonly [Symbol.toStringTag]: string;\n}\n\ninterface Int8Array {\n    readonly [Symbol.toStringTag]: "Int8Array";\n}\n\ninterface Uint8Array {\n    readonly [Symbol.toStringTag]: "UInt8Array";\n}\n\ninterface Uint8ClampedArray {\n    readonly [Symbol.toStringTag]: "Uint8ClampedArray";\n}\n\ninterface Int16Array {\n    readonly [Symbol.toStringTag]: "Int16Array";\n}\n\ninterface Uint16Array {\n    readonly [Symbol.toStringTag]: "Uint16Array";\n}\n\ninterface Int32Array {\n    readonly [Symbol.toStringTag]: "Int32Array";\n}\n\ninterface Uint32Array {\n    readonly [Symbol.toStringTag]: "Uint32Array";\n}\n\ninterface Float32Array {\n    readonly [Symbol.toStringTag]: "Float32Array";\n}\n\ninterface Float64Array {\n    readonly [Symbol.toStringTag]: "Float64Array";\n}\n\ninterface ArrayConstructor {\n    readonly [Symbol.species]: ArrayConstructor;\n}\ninterface MapConstructor {\n    readonly [Symbol.species]: MapConstructor;\n}\ninterface SetConstructor {\n    readonly [Symbol.species]: SetConstructor;\n}\ninterface ArrayBufferConstructor {\n    readonly [Symbol.species]: ArrayBufferConstructor;\n}'},204:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface Array<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface ReadonlyArray<T> {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: T, fromIndex?: number): boolean;\n}\n\ninterface Int8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint8ClampedArray {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint16Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Int32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Uint32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float32Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}\n\ninterface Float64Array {\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: number, fromIndex?: number): boolean;\n}'},205:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es2015" />\n/// <reference lib="es2016.array.include" />'},206:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es2016" />\n/// <reference lib="es2017.object" />\n/// <reference lib="es2017.sharedmemory" />\n/// <reference lib="es2017.string" />\n/// <reference lib="es2017.intl" />\n/// <reference lib="es2017.typedarrays" />\n'},207:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface ObjectConstructor {\n    /**\n     * Returns an array of values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    values<T>(o: { [s: string]: T } |  ArrayLike<T>): T[];\n\n    /**\n     * Returns an array of values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    values(o: {}): any[];\n\n    /**\n     * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries<T>(o: { [s: string]: T } | ArrayLike<T>): [string, T][];\n\n    /**\n     * Returns an array of key/values of the enumerable properties of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    entries(o: {}): [string, any][];\n\n    /**\n     * Returns an object containing all own property descriptors of an object\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    getOwnPropertyDescriptors<T>(o: T): {[P in keyof T]: TypedPropertyDescriptor<T[P]>} & { [x: string]: PropertyDescriptor };\n}\n'},208:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.symbol.wellknown" />\n\ninterface SharedArrayBuffer {\n    /**\n     * Read-only. The length of the ArrayBuffer (in bytes).\n     */\n    readonly byteLength: number;\n\n    /*\n     * The SharedArrayBuffer constructor\'s length property whose value is 1.\n     */\n    length: number;\n    /**\n     * Returns a section of an SharedArrayBuffer.\n     */\n    slice(begin: number, end?: number): SharedArrayBuffer;\n    readonly [Symbol.species]: SharedArrayBuffer;\n    readonly [Symbol.toStringTag]: "SharedArrayBuffer";\n}\n\ninterface SharedArrayBufferConstructor {\n    readonly prototype: SharedArrayBuffer;\n    new (byteLength: number): SharedArrayBuffer;\n}\ndeclare var SharedArrayBuffer: SharedArrayBufferConstructor;\n\ninterface ArrayBufferTypes {\n    SharedArrayBuffer: SharedArrayBuffer;\n}\n\ninterface Atomics {\n    /**\n     * Adds a value to the value at the given position in the array, returning the original value.\n     * Until this atomic operation completes, any other read or write operation against the array\n     * will block.\n     */\n    add(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * Stores the bitwise AND of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or\n     * write operation against the array will block.\n     */\n    and(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * Replaces the value at the given position in the array if the original value equals the given\n     * expected value, returning the original value. Until this atomic operation completes, any\n     * other read or write operation against the array will block.\n     */\n    compareExchange(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, expectedValue: number, replacementValue: number): number;\n\n    /**\n     * Replaces the value at the given position in the array, returning the original value. Until\n     * this atomic operation completes, any other read or write operation against the array will\n     * block.\n     */\n    exchange(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * Returns a value indicating whether high-performance algorithms can use atomic operations\n     * (`true`) or must use locks (`false`) for the given number of bytes-per-element of a typed\n     * array.\n     */\n    isLockFree(size: number): boolean;\n\n    /**\n     * Returns the value at the given position in the array. Until this atomic operation completes,\n     * any other read or write operation against the array will block.\n     */\n    load(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number): number;\n\n    /**\n     * Stores the bitwise OR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    or(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * Stores a value at the given position in the array, returning the new value. Until this\n     * atomic operation completes, any other read or write operation against the array will block.\n     */\n    store(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * Subtracts a value from the value at the given position in the array, returning the original\n     * value. Until this atomic operation completes, any other read or write operation against the\n     * array will block.\n     */\n    sub(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    /**\n     * If the value at the given position in the array is equal to the provided value, the current\n     * agent is put to sleep causing execution to suspend until the timeout expires (returning\n     * `"timed-out"`) or until the agent is awoken (returning `"ok"`); otherwise, returns\n     * `"not-equal"`.\n     */\n    wait(typedArray: Int32Array, index: number, value: number, timeout?: number): "ok" | "not-equal" | "timed-out";\n\n    /**\n     * Wakes up sleeping agents that are waiting on the given index of the array, returning the\n     * number of agents that were awoken.\n     */\n    wake(typedArray: Int32Array, index: number, count: number): number;\n\n    /**\n     * Stores the bitwise XOR of a value with the value at the given position in the array,\n     * returning the original value. Until this atomic operation completes, any other read or write\n     * operation against the array will block.\n     */\n    xor(typedArray: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, index: number, value: number): number;\n\n    readonly [Symbol.toStringTag]: "Atomics";\n}\n\ndeclare var Atomics: Atomics;'},209:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\ninterface String {\n    /**\n     * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n     * The padding is applied from the start (left) of the current string.\n     *\n     * @param maxLength The length of the resulting string once the current string has been padded.\n     *        If this parameter is smaller than the current string\'s length, the current string will be returned as it is.\n     *\n     * @param fillString The string to pad the current string with.\n     *        If this string is too long, it will be truncated and the left-most part will be applied.\n     *        The default value for this parameter is " " (U+0020).\n     */\n    padStart(maxLength: number, fillString?: string): string;\n\n    /**\n     * Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\n     * The padding is applied from the end (right) of the current string.\n     *\n     * @param maxLength The length of the resulting string once the current string has been padded.\n     *        If this parameter is smaller than the current string\'s length, the current string will be returned as it is.\n     *\n     * @param fillString The string to pad the current string with.\n     *        If this string is too long, it will be truncated and the left-most part will be applied.\n     *        The default value for this parameter is " " (U+0020).\n     */\n    padEnd(maxLength: number, fillString?: string): string;\n}\n'},210:function(e,n){e.exports="/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib=\"true\"/>\n\n\n/////////////////////////////\n/// ECMAScript APIs\n/////////////////////////////\n\ndeclare const NaN: number;\ndeclare const Infinity: number;\n\n/**\n  * Evaluates JavaScript code and executes it.\n  * @param x A String value that contains valid JavaScript code.\n  */\ndeclare function eval(x: string): any;\n\n/**\n  * Converts A string to an integer.\n  * @param s A string to convert into a number.\n  * @param radix A value between 2 and 36 that specifies the base of the number in numString.\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n  * All other strings are considered decimal.\n  */\ndeclare function parseInt(s: string, radix?: number): number;\n\n/**\n  * Converts a string to a floating-point number.\n  * @param string A string that contains a floating-point number.\n  */\ndeclare function parseFloat(string: string): number;\n\n/**\n  * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\n  * @param number A numeric value.\n  */\ndeclare function isNaN(number: number): boolean;\n\n/**\n  * Determines whether a supplied number is finite.\n  * @param number Any numeric value.\n  */\ndeclare function isFinite(number: number): boolean;\n\n/**\n  * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n  * @param encodedURI A value representing an encoded URI.\n  */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n  * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n  * @param encodedURIComponent A value representing an encoded URI component.\n  */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n  * Encodes a text string as a valid Uniform Resource Identifier (URI)\n  * @param uri A value representing an encoded URI.\n  */\ndeclare function encodeURI(uri: string): string;\n\n/**\n  * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n  * @param uriComponent A value representing an encoded URI component.\n  */\ndeclare function encodeURIComponent(uriComponent: string): string;\n\n/**\n  * Computes a new string in which certain characters have been replaced by a hexadecimal escape sequence.\n  * @param string A string value\n  */\ndeclare function escape(string: string): string;\n\n/**\n  * Computes a new string in which hexadecimal escape sequences are replaced with the character that it represents.\n  * @param string A string value\n  */\ndeclare function unescape(string: string): string;\n\ninterface Symbol {\n  /** Returns a string representation of an object. */\n  toString(): string;\n\n  /** Returns the primitive value of the specified object. */\n  valueOf(): symbol;\n}\n\ndeclare type PropertyKey = string | number | symbol;\n\ninterface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n\ninterface PropertyDescriptorMap {\n    [s: string]: PropertyDescriptor;\n}\n\ninterface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n      * Determines whether an object has a property with the specified name.\n      * @param v A property name.\n      */\n    hasOwnProperty(v: PropertyKey): boolean;\n\n    /**\n      * Determines whether an object exists in another object's prototype chain.\n      * @param v Another object whose prototype chain is to be checked.\n      */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n      * Determines whether a specified property is enumerable.\n      * @param v A property name.\n      */\n    propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /**\n      * Returns the prototype of an object.\n      * @param o The object that references the prototype.\n      */\n    getPrototypeOf(o: any): any;\n\n    /**\n      * Gets the own property descriptor of the specified object.\n      * An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype.\n      * @param o Object that contains the property.\n      * @param p Name of the property.\n    */\n    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;\n\n    /**\n      * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n      * on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions.\n      * @param o Object that contains the own properties.\n      */\n    getOwnPropertyNames(o: any): string[];\n\n    /**\n      * Creates an object that has the specified prototype or that has null prototype.\n      * @param o Object to use as a prototype. May be null.\n      */\n    create(o: object | null): any;\n\n    /**\n      * Creates an object that has the specified prototype, and that optionally contains specified properties.\n      * @param o Object to use as a prototype. May be null\n      * @param properties JavaScript object that contains one or more property descriptors.\n      */\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Adds a property to an object, or modifies attributes of an existing property.\n      * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\n      * @param p The property name.\n      * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n      */\n    defineProperty(o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): any;\n\n    /**\n      * Adds one or more properties to an object, and/or modifies attributes of existing properties.\n      * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\n      * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\n      */\n    defineProperties(o: any, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n      * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    seal<T>(o: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(a: T[]): ReadonlyArray<T>;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T extends Function>(f: T): T;\n\n    /**\n      * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n      * @param o Object on which to lock the attributes.\n      */\n    freeze<T>(o: T): Readonly<T>;\n\n    /**\n      * Prevents the addition of new properties to an object.\n      * @param o Object to make non-extensible.\n      */\n    preventExtensions<T>(o: T): T;\n\n    /**\n      * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isSealed(o: any): boolean;\n\n    /**\n      * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\n      * @param o Object to test.\n      */\n    isFrozen(o: any): boolean;\n\n    /**\n      * Returns a value that indicates whether new properties can be added to an object.\n      * @param o Object to test.\n      */\n    isExtensible(o: any): boolean;\n\n    /**\n      * Returns the names of the enumerable properties and methods of an object.\n      * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n      */\n    keys(o: {}): string[];\n}\n\n/**\n  * Provides functionality common to all JavaScript objects.\n  */\ndeclare const Object: ObjectConstructor;\n\n/**\n  * Creates a new function.\n  */\ninterface Function {\n    /**\n      * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n      * @param thisArg The object to be used as the this object.\n      * @param argArray A set of arguments to be passed to the function.\n      */\n    apply(this: Function, thisArg: any, argArray?: any): any;\n\n    /**\n      * Calls a method of an object, substituting another object for the current object.\n      * @param thisArg The object to be used as the current object.\n      * @param argArray A list of arguments to be passed to the method.\n      */\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg An object to which the this keyword can refer inside the new function.\n      * @param argArray A list of arguments to be passed to the new function.\n      */\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /** Returns a string representation of a function. */\n    toString(): string;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    /**\n      * Creates a new function.\n      * @param args A list of arguments the function accepts.\n      */\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare const Function: FunctionConstructor;\n\ninterface CallableFunction extends Function {\n    /**\n      * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n      * @param thisArg The object to be used as the this object.\n      * @param args An array of argument values to be passed to the function.\n      */\n    apply<T, R>(this: (this: T) => R, thisArg: T): R;\n    apply<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\n\n    /**\n      * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\n      * @param thisArg The object to be used as the this object.\n      * @param args Argument values to be passed to the function.\n      */\n    call<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg The object to be used as the this object.\n      * @param args Arguments to bind to the parameters of the function.\n      */\n    bind<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T): (...args: A) => R;\n    bind<T, A0, A extends any[], R>(this: (this: T, arg0: A0, ...args: A) => R, thisArg: T, arg0: A0): (...args: A) => R;\n    bind<T, A0, A1, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1): (...args: A) => R;\n    bind<T, A0, A1, A2, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2): (...args: A) => R;\n    bind<T, A0, A1, A2, A3, A extends any[], R>(this: (this: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R, thisArg: T, arg0: A0, arg1: A1, arg2: A2, arg3: A3): (...args: A) => R;\n    bind<T, AX, R>(this: (this: T, ...args: AX[]) => R, thisArg: T, ...args: AX[]): (...args: AX[]) => R;\n}\n\ninterface NewableFunction extends Function {\n    /**\n      * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n      * @param thisArg The object to be used as the this object.\n      * @param args An array of argument values to be passed to the function.\n      */\n    apply<T>(this: new () => T, thisArg: T): void;\n    apply<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\n\n    /**\n      * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\n      * @param thisArg The object to be used as the this object.\n      * @param args Argument values to be passed to the function.\n      */\n    call<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\n\n    /**\n      * For a given function, creates a bound function that has the same body as the original function.\n      * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n      * @param thisArg The object to be used as the this object.\n      * @param args Arguments to bind to the parameters of the function.\n      */\n    bind<A extends any[], R>(this: new (...args: A) => R, thisArg: any): new (...args: A) => R;\n    bind<A0, A extends any[], R>(this: new (arg0: A0, ...args: A) => R, thisArg: any, arg0: A0): new (...args: A) => R;\n    bind<A0, A1, A extends any[], R>(this: new (arg0: A0, arg1: A1, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1): new (...args: A) => R;\n    bind<A0, A1, A2, A extends any[], R>(this: new (arg0: A0, arg1: A1, arg2: A2, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1, arg2: A2): new (...args: A) => R;\n    bind<A0, A1, A2, A3, A extends any[], R>(this: new (arg0: A0, arg1: A1, arg2: A2, arg3: A3, ...args: A) => R, thisArg: any, arg0: A0, arg1: A1, arg2: A2, arg3: A3): new (...args: A) => R;\n    bind<AX, R>(this: new (...args: AX[]) => R, thisArg: any, ...args: AX[]): new (...args: AX[]) => R;\n}\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\ninterface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /**\n      * Returns the character at the specified index.\n      * @param pos The zero-based index of the desired character.\n      */\n    charAt(pos: number): string;\n\n    /**\n      * Returns the Unicode value of the character at the specified location.\n      * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n      */\n    charCodeAt(index: number): number;\n\n    /**\n      * Returns a string that contains the concatenation of two or more strings.\n      * @param strings The strings to append to the end of the string.\n      */\n    concat(...strings: string[]): string;\n\n    /**\n      * Returns the position of the first occurrence of a substring.\n      * @param searchString The substring to search for in the string\n      * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n      */\n    indexOf(searchString: string, position?: number): number;\n\n    /**\n      * Returns the last occurrence of a substring in the string.\n      * @param searchString The substring to search for.\n      * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n      */\n    lastIndexOf(searchString: string, position?: number): number;\n\n    /**\n      * Determines whether two strings are equivalent in the current locale.\n      * @param that String to compare to target string\n      */\n    localeCompare(that: string): number;\n\n    /**\n      * Matches a string with a regular expression, and returns an array containing the results of that search.\n      * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n      */\n    match(regexp: string | RegExp): RegExpMatchArray | null;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.\n      */\n    replace(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n      * Replaces text in a string, using a regular expression or search string.\n      * @param searchValue A string to search for.\n      * @param replacer A function that returns the replacement text.\n      */\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n      * Finds the first substring match in a regular expression search.\n      * @param regexp The regular expression pattern and applicable flags.\n      */\n    search(regexp: string | RegExp): number;\n\n    /**\n      * Returns a section of a string.\n      * @param start The index to the beginning of the specified portion of stringObj.\n      * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\n      * If this value is not specified, the substring continues to the end of stringObj.\n      */\n    slice(start?: number, end?: number): string;\n\n    /**\n      * Split a string into substrings using the specified separator and return them as an array.\n      * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n      * @param limit A value used to limit the number of elements returned in the array.\n      */\n    split(separator: string | RegExp, limit?: number): string[];\n\n    /**\n      * Returns the substring at the specified location within a String object.\n      * @param start The zero-based index number indicating the beginning of the substring.\n      * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\n      * If end is omitted, the characters from start through the end of the original string are returned.\n      */\n    substring(start: number, end?: number): string;\n\n    /** Converts all the alphabetic characters in a string to lowercase. */\n    toLowerCase(): string;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment's current locale. */\n    toLocaleLowerCase(): string;\n\n    /** Converts all the alphabetic characters in a string to uppercase. */\n    toUpperCase(): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale. */\n    toLocaleUpperCase(): string;\n\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\n    trim(): string;\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    // IE extensions\n    /**\n      * Gets a substring beginning at the specified location and having the specified length.\n      * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n      * @param length The number of characters to include in the returned substring.\n      */\n    substr(from: number, length?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): string;\n\n    readonly [index: number]: string;\n}\n\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n    fromCharCode(...codes: number[]): string;\n}\n\n/**\n  * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\n  */\ndeclare const String: StringConstructor;\n\ninterface Boolean {\n    /** Returns the primitive value of the specified object. */\n    valueOf(): boolean;\n}\n\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    (value?: any): boolean;\n    readonly prototype: Boolean;\n}\n\ndeclare const Boolean: BooleanConstructor;\n\ninterface Number {\n    /**\n      * Returns a string representation of an object.\n      * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\n      */\n    toString(radix?: number): string;\n\n    /**\n      * Returns a string representing a number in fixed-point notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toFixed(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented in exponential notation.\n      * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n      */\n    toExponential(fractionDigits?: number): string;\n\n    /**\n      * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n      * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\n      */\n    toPrecision(precision?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): number;\n}\n\ninterface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n      * A value that is not a number.\n      * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n      */\n    readonly NaN: number;\n\n    /**\n      * A value that is less than the largest negative number that can be represented in JavaScript.\n      * JavaScript displays NEGATIVE_INFINITY values as -infinity.\n      */\n    readonly NEGATIVE_INFINITY: number;\n\n    /**\n      * A value greater than the largest number that can be represented in JavaScript.\n      * JavaScript displays POSITIVE_INFINITY values as infinity.\n      */\n    readonly POSITIVE_INFINITY: number;\n}\n\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\ndeclare const Number: NumberConstructor;\n\ninterface TemplateStringsArray extends ReadonlyArray<string> {\n    readonly raw: ReadonlyArray<string>;\n}\n\n/**\n * The type of `import.meta`.\n * \n * If you need to declare that a given property exists on `import.meta`,\n * this type may be augmented via interface merging.\n */\ninterface ImportMeta {\n}\n\ninterface Math {\n    /** The mathematical constant e. This is Euler's number, the base of natural logarithms. */\n    readonly E: number;\n    /** The natural logarithm of 10. */\n    readonly LN10: number;\n    /** The natural logarithm of 2. */\n    readonly LN2: number;\n    /** The base-2 logarithm of e. */\n    readonly LOG2E: number;\n    /** The base-10 logarithm of e. */\n    readonly LOG10E: number;\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\n    readonly PI: number;\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\n    readonly SQRT1_2: number;\n    /** The square root of 2. */\n    readonly SQRT2: number;\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    abs(x: number): number;\n    /**\n      * Returns the arc cosine (or inverse cosine) of a number.\n      * @param x A numeric expression.\n      */\n    acos(x: number): number;\n    /**\n      * Returns the arcsine of a number.\n      * @param x A numeric expression.\n      */\n    asin(x: number): number;\n    /**\n      * Returns the arctangent of a number.\n      * @param x A numeric expression for which the arctangent is needed.\n      */\n    atan(x: number): number;\n    /**\n      * Returns the angle (in radians) from the X axis to a point.\n      * @param y A numeric expression representing the cartesian y-coordinate.\n      * @param x A numeric expression representing the cartesian x-coordinate.\n      */\n    atan2(y: number, x: number): number;\n    /**\n      * Returns the smallest integer greater than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    ceil(x: number): number;\n    /**\n      * Returns the cosine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    cos(x: number): number;\n    /**\n      * Returns e (the base of natural logarithms) raised to a power.\n      * @param x A numeric expression representing the power of e.\n      */\n    exp(x: number): number;\n    /**\n      * Returns the greatest integer less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    floor(x: number): number;\n    /**\n      * Returns the natural logarithm (base e) of a number.\n      * @param x A numeric expression.\n      */\n    log(x: number): number;\n    /**\n      * Returns the larger of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    max(...values: number[]): number;\n    /**\n      * Returns the smaller of a set of supplied numeric expressions.\n      * @param values Numeric expressions to be evaluated.\n      */\n    min(...values: number[]): number;\n    /**\n      * Returns the value of a base expression taken to a specified power.\n      * @param x The base value of the expression.\n      * @param y The exponent value of the expression.\n      */\n    pow(x: number, y: number): number;\n    /** Returns a pseudorandom number between 0 and 1. */\n    random(): number;\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    round(x: number): number;\n    /**\n      * Returns the sine of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    sin(x: number): number;\n    /**\n      * Returns the square root of a number.\n      * @param x A numeric expression.\n      */\n    sqrt(x: number): number;\n    /**\n      * Returns the tangent of a number.\n      * @param x A numeric expression that contains an angle measured in radians.\n      */\n    tan(x: number): number;\n}\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare const Math: Math;\n\n/** Enables basic storage and retrieval of dates and times. */\ninterface Date {\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\n    toString(): string;\n    /** Returns a date as a string value. */\n    toDateString(): string;\n    /** Returns a time as a string value. */\n    toTimeString(): string;\n    /** Returns a value as a string value appropriate to the host environment's current locale. */\n    toLocaleString(): string;\n    /** Returns a date as a string value appropriate to the host environment's current locale. */\n    toLocaleDateString(): string;\n    /** Returns a time as a string value appropriate to the host environment's current locale. */\n    toLocaleTimeString(): string;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    valueOf(): number;\n    /** Gets the time value in milliseconds. */\n    getTime(): number;\n    /** Gets the year, using local time. */\n    getFullYear(): number;\n    /** Gets the year using Universal Coordinated Time (UTC). */\n    getUTCFullYear(): number;\n    /** Gets the month, using local time. */\n    getMonth(): number;\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMonth(): number;\n    /** Gets the day-of-the-month, using local time. */\n    getDate(): number;\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\n    getUTCDate(): number;\n    /** Gets the day of the week, using local time. */\n    getDay(): number;\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\n    getUTCDay(): number;\n    /** Gets the hours in a date, using local time. */\n    getHours(): number;\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\n    getUTCHours(): number;\n    /** Gets the minutes of a Date object, using local time. */\n    getMinutes(): number;\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMinutes(): number;\n    /** Gets the seconds of a Date object, using local time. */\n    getSeconds(): number;\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCSeconds(): number;\n    /** Gets the milliseconds of a Date, using local time. */\n    getMilliseconds(): number;\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMilliseconds(): number;\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\n    getTimezoneOffset(): number;\n    /**\n      * Sets the date and time value in the Date object.\n      * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\n      */\n    setTime(time: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using local time.\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setMilliseconds(ms: number): number;\n    /**\n      * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param ms A numeric value equal to the millisecond value.\n      */\n    setUTCMilliseconds(ms: number): number;\n\n    /**\n      * Sets the seconds value in the Date object using local time.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCSeconds(sec: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using local time.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hour value in the Date object using local time.\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\n      * @param hours A numeric value equal to the hours value.\n      * @param min A numeric value equal to the minutes value.\n      * @param sec A numeric value equal to the seconds value.\n      * @param ms A numeric value equal to the milliseconds value.\n      */\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n      * Sets the numeric day-of-the-month value of the Date object using local time.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setDate(date: number): number;\n    /**\n      * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCDate(date: number): number;\n    /**\n      * Sets the month value in the Date object using local time.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\n      */\n    setMonth(month: number, date?: number): number;\n    /**\n      * Sets the month value in the Date object using Universal Coordinated Time (UTC).\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n      * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\n      */\n    setUTCMonth(month: number, date?: number): number;\n    /**\n      * Sets the year of the Date object using local time.\n      * @param year A numeric value for the year.\n      * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\n      * @param date A numeric value equal for the day of the month.\n      */\n    setFullYear(year: number, month?: number, date?: number): number;\n    /**\n      * Sets the year value in the Date object using Universal Coordinated Time (UTC).\n      * @param year A numeric value equal to the year.\n      * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\n      * @param date A numeric value equal to the day of the month.\n      */\n    setUTCFullYear(year: number, month?: number, date?: number): number;\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\n    toUTCString(): string;\n    /** Returns a date as a string value in ISO format. */\n    toISOString(): string;\n    /** Used by the JSON.stringify method to enable the transformation of an object's data for JavaScript Object Notation (JSON) serialization. */\n    toJSON(key?: any): string;\n}\n\ninterface DateConstructor {\n    new(): Date;\n    new(value: number | string): Date;\n    new(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n    (): string;\n    readonly prototype: Date;\n    /**\n      * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\n      * @param s A date string\n      */\n    parse(s: string): number;\n    /**\n      * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\n      * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n      * @param month The month as an number between 0 and 11 (January to December).\n      * @param date The date as an number between 1 and 31.\n      * @param hours Must be supplied if minutes is supplied. An number from 0 to 23 (midnight to 11pm) that specifies the hour.\n      * @param minutes Must be supplied if seconds is supplied. An number from 0 to 59 that specifies the minutes.\n      * @param seconds Must be supplied if milliseconds is supplied. An number from 0 to 59 that specifies the seconds.\n      * @param ms An number from 0 to 999 that specifies the milliseconds.\n      */\n    UTC(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\n    now(): number;\n}\n\ndeclare const Date: DateConstructor;\n\ninterface RegExpMatchArray extends Array<string> {\n    index?: number;\n    input?: string;\n}\n\ninterface RegExpExecArray extends Array<string> {\n    index: number;\n    input: string;\n}\n\ninterface RegExp {\n    /**\n      * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\n      * @param string The String object or string literal on which to perform the search.\n      */\n    exec(string: string): RegExpExecArray | null;\n\n    /**\n      * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\n      * @param string String on which to perform the search.\n      */\n    test(string: string): boolean;\n\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\n    readonly source: string;\n\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\n    readonly global: boolean;\n\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\n    readonly ignoreCase: boolean;\n\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\n    readonly multiline: boolean;\n\n    lastIndex: number;\n\n    // Non-standard extensions\n    compile(): this;\n}\n\ninterface RegExpConstructor {\n    new(pattern: RegExp | string): RegExp;\n    new(pattern: string, flags?: string): RegExp;\n    (pattern: RegExp | string): RegExp;\n    (pattern: string, flags?: string): RegExp;\n    readonly prototype: RegExp;\n\n    // Non-standard extensions\n    $1: string;\n    $2: string;\n    $3: string;\n    $4: string;\n    $5: string;\n    $6: string;\n    $7: string;\n    $8: string;\n    $9: string;\n    lastMatch: string;\n}\n\ndeclare const RegExp: RegExpConstructor;\n\ninterface Error {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\ninterface ErrorConstructor {\n    new(message?: string): Error;\n    (message?: string): Error;\n    readonly prototype: Error;\n}\n\ndeclare const Error: ErrorConstructor;\n\ninterface EvalError extends Error {\n}\n\ninterface EvalErrorConstructor {\n    new(message?: string): EvalError;\n    (message?: string): EvalError;\n    readonly prototype: EvalError;\n}\n\ndeclare const EvalError: EvalErrorConstructor;\n\ninterface RangeError extends Error {\n}\n\ninterface RangeErrorConstructor {\n    new(message?: string): RangeError;\n    (message?: string): RangeError;\n    readonly prototype: RangeError;\n}\n\ndeclare const RangeError: RangeErrorConstructor;\n\ninterface ReferenceError extends Error {\n}\n\ninterface ReferenceErrorConstructor {\n    new(message?: string): ReferenceError;\n    (message?: string): ReferenceError;\n    readonly prototype: ReferenceError;\n}\n\ndeclare const ReferenceError: ReferenceErrorConstructor;\n\ninterface SyntaxError extends Error {\n}\n\ninterface SyntaxErrorConstructor {\n    new(message?: string): SyntaxError;\n    (message?: string): SyntaxError;\n    readonly prototype: SyntaxError;\n}\n\ndeclare const SyntaxError: SyntaxErrorConstructor;\n\ninterface TypeError extends Error {\n}\n\ninterface TypeErrorConstructor {\n    new(message?: string): TypeError;\n    (message?: string): TypeError;\n    readonly prototype: TypeError;\n}\n\ndeclare const TypeError: TypeErrorConstructor;\n\ninterface URIError extends Error {\n}\n\ninterface URIErrorConstructor {\n    new(message?: string): URIError;\n    (message?: string): URIError;\n    readonly prototype: URIError;\n}\n\ndeclare const URIError: URIErrorConstructor;\n\ninterface JSON {\n    /**\n      * Converts a JavaScript Object Notation (JSON) string into an object.\n      * @param text A valid JSON string.\n      * @param reviver A function that transforms the results. This function is called for each member of the object.\n      * If a member contains nested objects, the nested objects are transformed before the parent object is.\n      */\n    parse(text: string, reviver?: (key: any, value: any) => any): any;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer A function that transforms the results.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (key: string, value: any) => any, space?: string | number): string;\n    /**\n      * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n      * @param value A JavaScript value, usually an object or array, to be converted.\n      * @param replacer An array of strings and numbers that acts as a approved list for selecting the object properties that will be stringified.\n      * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n      */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\n\n/**\n  * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\n  */\ndeclare const JSON: JSON;\n\n\n/////////////////////////////\n/// ECMAScript Array API (specially handled by compiler)\n/////////////////////////////\n\ninterface ReadonlyArray<T> {\n    /**\n      * Gets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    readonly length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: ReadonlyArray<T>) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ReadonlyArray<T>) => U, initialValue: U): U;\n\n    readonly [n: number]: T;\n}\n\ninterface ConcatArray<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}\n\ninterface Array<T> {\n    /**\n      * Gets or sets the length of the array. This is a number one higher than the highest element defined in an array.\n      */\n    length: number;\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n    /**\n      * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n      */\n    toLocaleString(): string;\n    /**\n      * Removes the last element from an array and returns it.\n      */\n    pop(): T | undefined;\n    /**\n      * Appends new elements to an array, and returns the new length of the array.\n      * @param items New elements of the Array.\n      */\n    push(...items: T[]): number;\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n      * Combines two or more arrays.\n      * @param items Additional items to add to the end of array1.\n      */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): T[];\n    /**\n      * Removes the first element from an array and returns it.\n      */\n    shift(): T | undefined;\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): T[];\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n      * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n      * @param start The zero-based location in the array from which to start removing elements.\n      * @param deleteCount The number of elements to remove.\n      * @param items Elements to insert into the array in place of the deleted elements.\n      */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n      * Inserts new elements at the start of an array.\n      * @param items  Elements to insert at the start of the Array.\n      */\n    unshift(...items: T[]): number;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Returns the index of the last occurrence of a specified value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n      */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}\n\ninterface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is Array<any>;\n    readonly prototype: Array<any>;\n}\n\ndeclare const Array: ArrayConstructor;\n\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\ndeclare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\n\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\n}\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}\n\ninterface ArrayLike<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n}\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n/**\n * Extract from T those types that are assignable to U\n */\ntype Extract<T, U> = T extends U ? T : never;\n\n/**\n * Exclude null and undefined from T\n */\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any[]) => any> = T extends (...args: any[]) => infer R ? R : any;\n\n/**\n * Obtain the return type of a constructor function type\n */\ntype InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : any;\n\n/**\n * Marker for contextual 'this' type\n */\ninterface ThisType<T> { }\n\n/**\n  * Represents a raw buffer of binary data, which is used to store data for the\n  * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n  * but can be passed to a typed array or DataView Object to interpret the raw\n  * buffer as needed.\n  */\ninterface ArrayBuffer {\n    /**\n      * Read-only. The length of the ArrayBuffer (in bytes).\n      */\n    readonly byteLength: number;\n\n    /**\n      * Returns a section of an ArrayBuffer.\n      */\n    slice(begin: number, end?: number): ArrayBuffer;\n}\n\n/**\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\n */\ninterface ArrayBufferTypes {\n    ArrayBuffer: ArrayBuffer;\n}\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\n\ninterface ArrayBufferConstructor {\n    readonly prototype: ArrayBuffer;\n    new(byteLength: number): ArrayBuffer;\n    isView(arg: any): arg is ArrayBufferView;\n}\ndeclare const ArrayBuffer: ArrayBufferConstructor;\n\ninterface ArrayBufferView {\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    byteOffset: number;\n}\n\ninterface DataView {\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    /**\n      * Gets the Float32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Float64 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Int8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt8(byteOffset: number): number;\n\n    /**\n      * Gets the Int16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\n    /**\n      * Gets the Int32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint8 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint8(byteOffset: number): number;\n\n    /**\n      * Gets the Uint16 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Gets the Uint32 value at the specified byte offset from the start of the view. There is\n      * no alignment constraint; multi-byte values may be fetched from any offset.\n      * @param byteOffset The place in the buffer at which the value should be retrieved.\n      */\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n      * Stores an Float32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Float64 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setInt8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Int16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Int32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint8 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      */\n    setUint8(byteOffset: number, value: number): void;\n\n    /**\n      * Stores an Uint16 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n      * Stores an Uint32 value at the specified byte offset from the start of the view.\n      * @param byteOffset The place in the buffer at which the value should be set.\n      * @param value The value to set.\n      * @param littleEndian If false or undefined, a big-endian value should be written,\n      * otherwise a little-endian value should be written.\n      */\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\n}\n\ninterface DataViewConstructor {\n    new(buffer: ArrayBufferLike, byteOffset?: number, byteLength?: number): DataView;\n}\ndeclare const DataView: DataViewConstructor;\n\n/**\n  * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Int8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\ninterface Int8ArrayConstructor {\n    readonly prototype: Int8Array;\n    new(length: number): Int8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int8Array;\n\n\n}\ndeclare const Int8Array: Int8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ArrayConstructor {\n    readonly prototype: Uint8Array;\n    new(length: number): Uint8Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8Array;\n\n}\ndeclare const Uint8Array: Uint8ArrayConstructor;\n\n/**\n  * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n  * If the requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint8ClampedArray {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint8ClampedArray;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint8ClampedArray;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    readonly prototype: Uint8ClampedArray;\n    new(length: number): Uint8ClampedArray;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint8ClampedArray;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint8ClampedArray;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint8ClampedArray;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\ndeclare const Uint8ClampedArray: Uint8ClampedArrayConstructor;\n\n/**\n  * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int16ArrayConstructor {\n    readonly prototype: Int16Array;\n    new(length: number): Int16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int16Array;\n\n\n}\ndeclare const Int16Array: Int16ArrayConstructor;\n\n/**\n  * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint16Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint16Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint16Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint16Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint16Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint16ArrayConstructor {\n    readonly prototype: Uint16Array;\n    new(length: number): Uint16Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint16Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint16Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint16Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint16Array;\n\n\n}\ndeclare const Uint16Array: Uint16ArrayConstructor;\n/**\n  * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Int32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Int32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Int32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Int32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Int32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Int32ArrayConstructor {\n    readonly prototype: Int32Array;\n    new(length: number): Int32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Int32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Int32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Int32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Int32Array;\n\n}\ndeclare const Int32Array: Int32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n  * requested number of bytes could not be allocated an exception is raised.\n  */\ninterface Uint32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Uint32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Uint32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Uint32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Uint32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Uint32ArrayConstructor {\n    readonly prototype: Uint32Array;\n    new(length: number): Uint32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Uint32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Uint32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Uint32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Uint32Array;\n\n}\ndeclare const Uint32Array: Uint32ArrayConstructor;\n\n/**\n  * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n  * of bytes could not be allocated an exception is raised.\n  */\ninterface Float32Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float32Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float32Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float32Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float32Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float32ArrayConstructor {\n    readonly prototype: Float32Array;\n    new(length: number): Float32Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float32Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float32Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float32Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float32Array;\n\n\n}\ndeclare const Float32Array: Float32ArrayConstructor;\n\n/**\n  * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n  * number of bytes could not be allocated an exception is raised.\n  */\ninterface Float64Array {\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * The ArrayBuffer instance referenced by the array.\n      */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n      * The length in bytes of the array.\n      */\n    readonly byteLength: number;\n\n    /**\n      * The offset in bytes of the array.\n      */\n    readonly byteOffset: number;\n\n    /**\n      * Returns the this object after copying a section of the array identified by start and end\n      * to the same array starting at position target\n      * @param target If target is negative, it is treated as length+target where length is the\n      * length of the array.\n      * @param start If start is negative, it is treated as length+start. If end is negative, it\n      * is treated as length+end.\n      * @param end If not specified, length of the this object is used as its default value.\n      */\n    copyWithin(target: number, start: number, end?: number): this;\n\n    /**\n      * Determines whether all the members of an array satisfy the specified test.\n      * @param callbackfn A function that accepts up to three arguments. The every method calls\n      * the callbackfn function for each element in array1 until the callbackfn returns false,\n      * or until the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    every(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n        * Returns the this object after filling the section identified by start and end with value\n        * @param value value to fill array section with\n        * @param start index to start filling the array at. If start is negative, it is treated as\n        * length+start where length is the length of the array.\n        * @param end index to stop filling the array at. If end is negative, it is treated as\n        * length+end.\n        */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n      * Returns the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to three arguments. The filter method calls\n      * the callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    filter(callbackfn: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\n\n    /**\n      * Returns the value of the first element in the array where predicate is true, and undefined\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found, find\n      * immediately returns that element value. Otherwise, find returns undefined.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    find(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n      * Returns the index of the first element in the array where predicate is true, and -1\n      * otherwise.\n      * @param predicate find calls predicate once for each element of the array, in ascending\n      * order, until it finds one where predicate returns true. If such an element is found,\n      * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n      * @param thisArg If provided, it will be used as the this value for each invocation of\n      * predicate. If it is not provided, undefined is used instead.\n      */\n    findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number;\n\n    /**\n      * Performs the specified action for each element in an array.\n      * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\n\n    /**\n      * Returns the index of the first occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      *  search starts at index 0.\n      */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * Adds all the elements of an array separated by the specified separator string.\n      * @param separator A string used to separate one element of an array from the next in the\n      * resulting String. If omitted, the array elements are separated with a comma.\n      */\n    join(separator?: string): string;\n\n    /**\n      * Returns the index of the last occurrence of a value in an array.\n      * @param searchElement The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n      * search starts at index 0.\n      */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n      * The length of the array.\n      */\n    readonly length: number;\n\n    /**\n      * Calls a defined callback function on each element of an array, and returns an array that\n      * contains the results.\n      * @param callbackfn A function that accepts up to three arguments. The map method calls the\n      * callbackfn function one time for each element in the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    map(callbackfn: (value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array. The return value of\n      * the callback function is the accumulated result, and is provided as an argument in the next\n      * call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n      * callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an\n      * argument instead of an array value.\n      */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n      * Calls the specified callback function for all the elements in an array, in descending order.\n      * The return value of the callback function is the accumulated result, and is provided as an\n      * argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n      * the callbackfn function one time for each element in the array.\n      * @param initialValue If initialValue is specified, it is used as the initial value to start\n      * the accumulation. The first call to the callbackfn function provides this value as an argument\n      * instead of an array value.\n      */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n      * Reverses the elements in an Array.\n      */\n    reverse(): Float64Array;\n\n    /**\n      * Sets a value or an array of values.\n      * @param array A typed or untyped array of values to set.\n      * @param offset The index in the current array at which the values are to be written.\n      */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n      * Returns a section of an array.\n      * @param start The beginning of the specified portion of the array.\n      * @param end The end of the specified portion of the array.\n      */\n    slice(start?: number, end?: number): Float64Array;\n\n    /**\n      * Determines whether the specified callback function returns true for any element of an array.\n      * @param callbackfn A function that accepts up to three arguments. The some method calls the\n      * callbackfn function for each element in array1 until the callbackfn returns true, or until\n      * the end of the array.\n      * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n      * If thisArg is omitted, undefined is used as the this value.\n      */\n    some(callbackfn: (value: number, index: number, array: Float64Array) => boolean, thisArg?: any): boolean;\n\n    /**\n      * Sorts an array.\n      * @param compareFn The name of the function used to determine the order of the elements. If\n      * omitted, the elements are sorted in ascending, ASCII character order.\n      */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n      * Gets a new Float64Array view of the ArrayBuffer store for this array, referencing the elements\n      * at begin, inclusive, up to end, exclusive.\n      * @param begin The index of the beginning of the array.\n      * @param end The index of the end of the array.\n      */\n    subarray(begin: number, end?: number): Float64Array;\n\n    /**\n      * Converts a number to a string by using the current locale.\n      */\n    toLocaleString(): string;\n\n    /**\n      * Returns a string representation of an array.\n      */\n    toString(): string;\n\n    [index: number]: number;\n}\n\ninterface Float64ArrayConstructor {\n    readonly prototype: Float64Array;\n    new(length: number): Float64Array;\n    new(arrayOrArrayBuffer: ArrayLike<number> | ArrayBufferLike): Float64Array;\n    new(buffer: ArrayBufferLike, byteOffset: number, length?: number): Float64Array;\n\n    /**\n      * The size in bytes of each element in the array.\n      */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n      * Returns a new array from a set of elements.\n      * @param items A set of elements to include in the new array object.\n      */\n    of(...items: number[]): Float64Array;\n\n    /**\n      * Creates an array from an array-like or iterable object.\n      * @param arrayLike An array-like or iterable object to convert to an array.\n      * @param mapfn A mapping function to call on every element of the array.\n      * @param thisArg Value of 'this' used to invoke the mapfn.\n      */\n    from(arrayLike: ArrayLike<number>, mapfn?: (v: number, k: number) => number, thisArg?: any): Float64Array;\n\n}\ndeclare const Float64Array: Float64ArrayConstructor;\n\n/////////////////////////////\n/// ECMAScript Internationalization API\n/////////////////////////////\n\ndeclare namespace Intl {\n    interface CollatorOptions {\n        usage?: string;\n        localeMatcher?: string;\n        numeric?: boolean;\n        caseFirst?: string;\n        sensitivity?: string;\n        ignorePunctuation?: boolean;\n    }\n\n    interface ResolvedCollatorOptions {\n        locale: string;\n        usage: string;\n        sensitivity: string;\n        ignorePunctuation: boolean;\n        collation: string;\n        caseFirst: string;\n        numeric: boolean;\n    }\n\n    interface Collator {\n        compare(x: string, y: string): number;\n        resolvedOptions(): ResolvedCollatorOptions;\n    }\n    var Collator: {\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\n        (locales?: string | string[], options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\n    };\n\n    interface NumberFormatOptions {\n        localeMatcher?: string;\n        style?: string;\n        currency?: string;\n        currencyDisplay?: string;\n        useGrouping?: boolean;\n        minimumIntegerDigits?: number;\n        minimumFractionDigits?: number;\n        maximumFractionDigits?: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        locale: string;\n        numberingSystem: string;\n        style: string;\n        currency?: string;\n        currencyDisplay?: string;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n        useGrouping: boolean;\n    }\n\n    interface NumberFormat {\n        format(value: number): string;\n        resolvedOptions(): ResolvedNumberFormatOptions;\n    }\n    var NumberFormat: {\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\n    };\n\n    interface DateTimeFormatOptions {\n        localeMatcher?: string;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n        formatMatcher?: string;\n        hour12?: boolean;\n        timeZone?: string;\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        locale: string;\n        calendar: string;\n        numberingSystem: string;\n        timeZone: string;\n        hour12?: boolean;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n    }\n\n    interface DateTimeFormat {\n        format(date?: Date | number): string;\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\n    }\n    var DateTimeFormat: {\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\n    };\n}\n\ninterface String {\n    /**\n      * Determines whether two strings are equivalent in the current or specified locale.\n      * @param that String to compare to target string\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n      * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n      */\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\n}\n\ninterface Number {\n    /**\n      * Converts a number to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Date {\n    /**\n      * Converts a date and time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n    /**\n      * Converts a date to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n      * Converts a time to a string by using the current or specified locale.\n      * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n      * @param options An object that contains one or more properties that specify comparison options.\n      */\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n}\n"},211:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/// <reference lib="es2015" />\n/// <reference lib="dom" />\n/// <reference lib="dom.iterable" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n'},212:function(e,n){e.exports='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\n/// <reference no-default-lib="true"/>\n\n\n/////////////////////////////\n/// Worker APIs\n/////////////////////////////\n\ninterface AddEventListenerOptions extends EventListenerOptions {\n    once?: boolean;\n    passive?: boolean;\n}\n\ninterface AesCbcParams extends Algorithm {\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface AesCtrParams extends Algorithm {\n    counter: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    length: number;\n}\n\ninterface AesDerivedKeyParams extends Algorithm {\n    length: number;\n}\n\ninterface AesGcmParams extends Algorithm {\n    additionalData?: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    tagLength?: number;\n}\n\ninterface AesKeyAlgorithm extends KeyAlgorithm {\n    length: number;\n}\n\ninterface AesKeyGenParams extends Algorithm {\n    length: number;\n}\n\ninterface Algorithm {\n    name: string;\n}\n\ninterface BlobPropertyBag {\n    endings?: EndingType;\n    type?: string;\n}\n\ninterface CacheQueryOptions {\n    cacheName?: string;\n    ignoreMethod?: boolean;\n    ignoreSearch?: boolean;\n    ignoreVary?: boolean;\n}\n\ninterface ClientQueryOptions {\n    includeUncontrolled?: boolean;\n    type?: ClientTypes;\n}\n\ninterface CloseEventInit extends EventInit {\n    code?: number;\n    reason?: string;\n    wasClean?: boolean;\n}\n\ninterface CryptoKeyPair {\n    privateKey?: CryptoKey;\n    publicKey?: CryptoKey;\n}\n\ninterface CustomEventInit<T = any> extends EventInit {\n    detail?: T;\n}\n\ninterface DOMMatrix2DInit {\n    a?: number;\n    b?: number;\n    c?: number;\n    d?: number;\n    e?: number;\n    f?: number;\n    m11?: number;\n    m12?: number;\n    m21?: number;\n    m22?: number;\n    m41?: number;\n    m42?: number;\n}\n\ninterface DOMMatrixInit extends DOMMatrix2DInit {\n    is2D?: boolean;\n    m13?: number;\n    m14?: number;\n    m23?: number;\n    m24?: number;\n    m31?: number;\n    m32?: number;\n    m33?: number;\n    m34?: number;\n    m43?: number;\n    m44?: number;\n}\n\ninterface DOMPointInit {\n    w?: number;\n    x?: number;\n    y?: number;\n    z?: number;\n}\n\ninterface DOMQuadInit {\n    p1?: DOMPointInit;\n    p2?: DOMPointInit;\n    p3?: DOMPointInit;\n    p4?: DOMPointInit;\n}\n\ninterface DOMRectInit {\n    height?: number;\n    width?: number;\n    x?: number;\n    y?: number;\n}\n\ninterface EcKeyGenParams extends Algorithm {\n    namedCurve: NamedCurve;\n}\n\ninterface EcKeyImportParams extends Algorithm {\n    namedCurve: NamedCurve;\n}\n\ninterface EcdhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface EcdsaParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface ErrorEventInit extends EventInit {\n    colno?: number;\n    error?: any;\n    filename?: string;\n    lineno?: number;\n    message?: string;\n}\n\ninterface EventInit {\n    bubbles?: boolean;\n    cancelable?: boolean;\n    composed?: boolean;\n}\n\ninterface EventListenerOptions {\n    capture?: boolean;\n}\n\ninterface ExtendableEventInit extends EventInit {\n}\n\ninterface ExtendableMessageEventInit extends ExtendableEventInit {\n    data?: any;\n    lastEventId?: string;\n    origin?: string;\n    ports?: MessagePort[];\n    source?: Client | ServiceWorker | MessagePort | null;\n}\n\ninterface FetchEventInit extends ExtendableEventInit {\n    clientId?: string;\n    preloadResponse?: Promise<any>;\n    request: Request;\n    resultingClientId?: string;\n    targetClientId?: string;\n}\n\ninterface FilePropertyBag extends BlobPropertyBag {\n    lastModified?: number;\n}\n\ninterface GetNotificationOptions {\n    tag?: string;\n}\n\ninterface HmacImportParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    length?: number;\n}\n\ninterface HmacKeyGenParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    length?: number;\n}\n\ninterface IDBIndexParameters {\n    multiEntry?: boolean;\n    unique?: boolean;\n}\n\ninterface IDBObjectStoreParameters {\n    autoIncrement?: boolean;\n    keyPath?: string | string[] | null;\n}\n\ninterface IDBVersionChangeEventInit extends EventInit {\n    newVersion?: number | null;\n    oldVersion?: number;\n}\n\ninterface JsonWebKey {\n    alg?: string;\n    crv?: string;\n    d?: string;\n    dp?: string;\n    dq?: string;\n    e?: string;\n    ext?: boolean;\n    k?: string;\n    key_ops?: string[];\n    kty?: string;\n    n?: string;\n    oth?: RsaOtherPrimesInfo[];\n    p?: string;\n    q?: string;\n    qi?: string;\n    use?: string;\n    x?: string;\n    y?: string;\n}\n\ninterface KeyAlgorithm {\n    name: string;\n}\n\ninterface MessageEventInit extends EventInit {\n    data?: any;\n    lastEventId?: string;\n    origin?: string;\n    ports?: MessagePort[];\n    source?: MessageEventSource | null;\n}\n\ninterface NavigationPreloadState {\n    enabled?: boolean;\n    headerValue?: string;\n}\n\ninterface NotificationAction {\n    action: string;\n    icon?: string;\n    title: string;\n}\n\ninterface NotificationEventInit extends ExtendableEventInit {\n    action?: string;\n    notification: Notification;\n}\n\ninterface NotificationOptions {\n    actions?: NotificationAction[];\n    badge?: string;\n    body?: string;\n    data?: any;\n    dir?: NotificationDirection;\n    icon?: string;\n    image?: string;\n    lang?: string;\n    renotify?: boolean;\n    requireInteraction?: boolean;\n    silent?: boolean;\n    tag?: string;\n    timestamp?: number;\n    vibrate?: VibratePattern;\n}\n\ninterface Pbkdf2Params extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n    iterations: number;\n    salt: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface PerformanceObserverInit {\n    buffered?: boolean;\n    entryTypes: string[];\n}\n\ninterface PipeOptions {\n    preventAbort?: boolean;\n    preventCancel?: boolean;\n    preventClose?: boolean;\n}\n\ninterface ProgressEventInit extends EventInit {\n    lengthComputable?: boolean;\n    loaded?: number;\n    total?: number;\n}\n\ninterface PromiseRejectionEventInit extends EventInit {\n    promise: Promise<any>;\n    reason?: any;\n}\n\ninterface PushEventInit extends ExtendableEventInit {\n    data?: PushMessageDataInit;\n}\n\ninterface PushSubscriptionChangeInit extends ExtendableEventInit {\n    newSubscription?: PushSubscription;\n    oldSubscription?: PushSubscription;\n}\n\ninterface PushSubscriptionJSON {\n    endpoint?: string;\n    expirationTime?: number | null;\n    keys?: Record<string, string>;\n}\n\ninterface PushSubscriptionOptionsInit {\n    applicationServerKey?: BufferSource | string | null;\n    userVisibleOnly?: boolean;\n}\n\ninterface QueuingStrategy<T = any> {\n    highWaterMark?: number;\n    size?: QueuingStrategySizeCallback<T>;\n}\n\ninterface RegistrationOptions {\n    scope?: string;\n    type?: WorkerType;\n    updateViaCache?: ServiceWorkerUpdateViaCache;\n}\n\ninterface RequestInit {\n    body?: BodyInit | null;\n    cache?: RequestCache;\n    credentials?: RequestCredentials;\n    headers?: HeadersInit;\n    integrity?: string;\n    keepalive?: boolean;\n    method?: string;\n    mode?: RequestMode;\n    redirect?: RequestRedirect;\n    referrer?: string;\n    referrerPolicy?: ReferrerPolicy;\n    signal?: AbortSignal | null;\n    window?: any;\n}\n\ninterface ResponseInit {\n    headers?: HeadersInit;\n    status?: number;\n    statusText?: string;\n}\n\ninterface RsaHashedImportParams extends Algorithm {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface RsaHashedKeyGenParams extends RsaKeyGenParams {\n    hash: HashAlgorithmIdentifier;\n}\n\ninterface RsaKeyGenParams extends Algorithm {\n    modulusLength: number;\n    publicExponent: BigInteger;\n}\n\ninterface RsaOaepParams extends Algorithm {\n    label?: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface RsaOtherPrimesInfo {\n    d?: string;\n    r?: string;\n    t?: string;\n}\n\ninterface RsaPssParams extends Algorithm {\n    saltLength: number;\n}\n\ninterface StorageEstimate {\n    quota?: number;\n    usage?: number;\n}\n\ninterface SyncEventInit extends ExtendableEventInit {\n    lastChance?: boolean;\n    tag: string;\n}\n\ninterface TextDecodeOptions {\n    stream?: boolean;\n}\n\ninterface TextDecoderOptions {\n    fatal?: boolean;\n    ignoreBOM?: boolean;\n}\n\ninterface Transformer<I = any, O = any> {\n    flush?: TransformStreamDefaultControllerCallback<O>;\n    readableType?: undefined;\n    start?: TransformStreamDefaultControllerCallback<O>;\n    transform?: TransformStreamDefaultControllerTransformCallback<I, O>;\n    writableType?: undefined;\n}\n\ninterface UnderlyingByteSource {\n    autoAllocateChunkSize?: number;\n    cancel?: ReadableStreamErrorCallback;\n    pull?: ReadableByteStreamControllerCallback;\n    start?: ReadableByteStreamControllerCallback;\n    type: "bytes";\n}\n\ninterface UnderlyingSink<W = any> {\n    abort?: WritableStreamErrorCallback;\n    close?: WritableStreamDefaultControllerCloseCallback;\n    start?: WritableStreamDefaultControllerStartCallback;\n    type?: undefined;\n    write?: WritableStreamDefaultControllerWriteCallback<W>;\n}\n\ninterface UnderlyingSource<R = any> {\n    cancel?: ReadableStreamErrorCallback;\n    pull?: ReadableStreamDefaultControllerCallback<R>;\n    start?: ReadableStreamDefaultControllerCallback<R>;\n    type?: undefined;\n}\n\ninterface WebGLContextAttributes {\n    alpha?: GLboolean;\n    antialias?: GLboolean;\n    depth?: GLboolean;\n    failIfMajorPerformanceCaveat?: boolean;\n    powerPreference?: WebGLPowerPreference;\n    premultipliedAlpha?: GLboolean;\n    preserveDrawingBuffer?: GLboolean;\n    stencil?: GLboolean;\n}\n\ninterface WebGLContextEventInit extends EventInit {\n    statusMessage?: string;\n}\n\ninterface WorkerOptions {\n    credentials?: RequestCredentials;\n    name?: string;\n    type?: WorkerType;\n}\n\ninterface EventListener {\n    (evt: Event): void;\n}\n\ninterface ANGLE_instanced_arrays {\n    drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei): void;\n    drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei): void;\n    vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint): void;\n    readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: GLenum;\n}\n\ninterface AbortController {\n    /**\n     * Returns the AbortSignal object associated with this object.\n     */\n    readonly signal: AbortSignal;\n    /**\n     * Invoking this method will set this object\'s AbortSignal\'s aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort(): void;\n}\n\ndeclare var AbortController: {\n    prototype: AbortController;\n    new(): AbortController;\n};\n\ninterface AbortSignalEventMap {\n    "abort": ProgressEvent;\n}\n\ninterface AbortSignal extends EventTarget {\n    /**\n     * Returns true if this AbortSignal\'s AbortController has signaled to abort, and false\n     * otherwise.\n     */\n    readonly aborted: boolean;\n    onabort: ((this: AbortSignal, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AbortSignalEventMap>(type: K, listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var AbortSignal: {\n    prototype: AbortSignal;\n    new(): AbortSignal;\n};\n\ninterface AbstractWorkerEventMap {\n    "error": ErrorEvent;\n}\n\ninterface AbstractWorker {\n    onerror: ((this: AbstractWorker, ev: ErrorEvent) => any) | null;\n    addEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof AbstractWorkerEventMap>(type: K, listener: (this: AbstractWorker, ev: AbstractWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface AesCfbParams extends Algorithm {\n    iv: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface AesCmacParams extends Algorithm {\n    length: number;\n}\n\ninterface Blob {\n    readonly size: number;\n    readonly type: string;\n    slice(start?: number, end?: number, contentType?: string): Blob;\n}\n\ndeclare var Blob: {\n    prototype: Blob;\n    new(blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;\n};\n\ninterface Body {\n    readonly body: ReadableStream<Uint8Array> | null;\n    readonly bodyUsed: boolean;\n    arrayBuffer(): Promise<ArrayBuffer>;\n    blob(): Promise<Blob>;\n    formData(): Promise<FormData>;\n    json(): Promise<any>;\n    text(): Promise<string>;\n}\n\ninterface BroadcastChannelEventMap {\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface BroadcastChannel extends EventTarget {\n    /**\n     * Returns the channel name (as passed to the constructor).\n     */\n    readonly name: string;\n    onmessage: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n    /**\n     * Closes the BroadcastChannel object, opening it up to garbage collection.\n     */\n    close(): void;\n    /**\n     * Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays.\n     */\n    postMessage(message: any): void;\n    addEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof BroadcastChannelEventMap>(type: K, listener: (this: BroadcastChannel, ev: BroadcastChannelEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var BroadcastChannel: {\n    prototype: BroadcastChannel;\n    new(name: string): BroadcastChannel;\n};\n\ninterface BroadcastChannelEventMap {\n    message: MessageEvent;\n    messageerror: MessageEvent;\n}\n\ninterface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView> {\n    highWaterMark: number;\n    size(chunk: ArrayBufferView): number;\n}\n\ndeclare var ByteLengthQueuingStrategy: {\n    prototype: ByteLengthQueuingStrategy;\n    new(options: { highWaterMark: number }): ByteLengthQueuingStrategy;\n};\n\ninterface Cache {\n    add(request: RequestInfo): Promise<void>;\n    addAll(requests: RequestInfo[]): Promise<void>;\n    delete(request: RequestInfo, options?: CacheQueryOptions): Promise<boolean>;\n    keys(request?: RequestInfo, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response | undefined>;\n    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n    put(request: RequestInfo, response: Response): Promise<void>;\n}\n\ndeclare var Cache: {\n    prototype: Cache;\n    new(): Cache;\n};\n\ninterface CacheStorage {\n    delete(cacheName: string): Promise<boolean>;\n    has(cacheName: string): Promise<boolean>;\n    keys(): Promise<string[]>;\n    match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response | undefined>;\n    open(cacheName: string): Promise<Cache>;\n}\n\ndeclare var CacheStorage: {\n    prototype: CacheStorage;\n    new(): CacheStorage;\n};\n\ninterface CanvasGradient {\n    /**\n     * Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset\n     * at one end of the gradient, 1.0 is the offset at the other end.\n     * Throws an "IndexSizeError" DOMException if the offset\n     * is out of range. Throws a "SyntaxError" DOMException if\n     * the color cannot be parsed.\n     */\n    addColorStop(offset: number, color: string): void;\n}\n\ndeclare var CanvasGradient: {\n    prototype: CanvasGradient;\n    new(): CanvasGradient;\n};\n\ninterface CanvasPath {\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n    closePath(): void;\n    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    lineTo(x: number, y: number): void;\n    moveTo(x: number, y: number): void;\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n    rect(x: number, y: number, w: number, h: number): void;\n}\n\ninterface CanvasPattern {\n    /**\n     * Sets the transformation matrix that will be used when rendering the pattern during a fill or\n     * stroke painting operation.\n     */\n    setTransform(transform?: DOMMatrix2DInit): void;\n}\n\ndeclare var CanvasPattern: {\n    prototype: CanvasPattern;\n    new(): CanvasPattern;\n};\n\ninterface Client {\n    readonly id: string;\n    readonly type: ClientTypes;\n    readonly url: string;\n    postMessage(message: any, transfer?: Transferable[]): void;\n}\n\ndeclare var Client: {\n    prototype: Client;\n    new(): Client;\n};\n\ninterface Clients {\n    claim(): Promise<void>;\n    get(id: string): Promise<any>;\n    matchAll(options?: ClientQueryOptions): Promise<ReadonlyArray<Client>>;\n    openWindow(url: string): Promise<WindowClient | null>;\n}\n\ndeclare var Clients: {\n    prototype: Clients;\n    new(): Clients;\n};\n\ninterface CloseEvent extends Event {\n    readonly code: number;\n    readonly reason: string;\n    readonly wasClean: boolean;\n    /** @deprecated */\n    initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;\n}\n\ndeclare var CloseEvent: {\n    prototype: CloseEvent;\n    new(type: string, eventInitDict?: CloseEventInit): CloseEvent;\n};\n\ninterface ConcatParams extends Algorithm {\n    algorithmId: Uint8Array;\n    hash?: string | Algorithm;\n    partyUInfo: Uint8Array;\n    partyVInfo: Uint8Array;\n    privateInfo?: Uint8Array;\n    publicInfo?: Uint8Array;\n}\n\ninterface Console {\n    memory: any;\n    assert(condition?: boolean, message?: string, ...data: any[]): void;\n    clear(): void;\n    count(label?: string): void;\n    debug(message?: any, ...optionalParams: any[]): void;\n    dir(value?: any, ...optionalParams: any[]): void;\n    dirxml(value: any): void;\n    error(message?: any, ...optionalParams: any[]): void;\n    exception(message?: string, ...optionalParams: any[]): void;\n    group(groupTitle?: string, ...optionalParams: any[]): void;\n    groupCollapsed(groupTitle?: string, ...optionalParams: any[]): void;\n    groupEnd(): void;\n    info(message?: any, ...optionalParams: any[]): void;\n    log(message?: any, ...optionalParams: any[]): void;\n    markTimeline(label?: string): void;\n    profile(reportName?: string): void;\n    profileEnd(reportName?: string): void;\n    table(...tabularData: any[]): void;\n    time(label?: string): void;\n    timeEnd(label?: string): void;\n    timeStamp(label?: string): void;\n    timeline(label?: string): void;\n    timelineEnd(label?: string): void;\n    trace(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n}\n\ndeclare var Console: {\n    prototype: Console;\n    new(): Console;\n};\n\ninterface CountQueuingStrategy extends QueuingStrategy {\n    highWaterMark: number;\n    size(chunk: any): 1;\n}\n\ndeclare var CountQueuingStrategy: {\n    prototype: CountQueuingStrategy;\n    new(options: { highWaterMark: number }): CountQueuingStrategy;\n};\n\ninterface Crypto {\n    readonly subtle: SubtleCrypto;\n    getRandomValues<T extends Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | null>(array: T): T;\n}\n\ndeclare var Crypto: {\n    prototype: Crypto;\n    new(): Crypto;\n};\n\ninterface CryptoKey {\n    readonly algorithm: KeyAlgorithm;\n    readonly extractable: boolean;\n    readonly type: KeyType;\n    readonly usages: KeyUsage[];\n}\n\ndeclare var CryptoKey: {\n    prototype: CryptoKey;\n    new(): CryptoKey;\n};\n\ninterface CustomEvent<T = any> extends Event {\n    /**\n     * Returns any custom data event was created with.\n     * Typically used for synthetic events.\n     */\n    readonly detail: T;\n    initCustomEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, detailArg: T): void;\n}\n\ndeclare var CustomEvent: {\n    prototype: CustomEvent;\n    new<T>(typeArg: string, eventInitDict?: CustomEventInit<T>): CustomEvent<T>;\n};\n\ninterface DOMException {\n    readonly code: number;\n    readonly message: string;\n    readonly name: string;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n}\n\ndeclare var DOMException: {\n    prototype: DOMException;\n    new(message?: string, name?: string): DOMException;\n    readonly ABORT_ERR: number;\n    readonly DATA_CLONE_ERR: number;\n    readonly DOMSTRING_SIZE_ERR: number;\n    readonly HIERARCHY_REQUEST_ERR: number;\n    readonly INDEX_SIZE_ERR: number;\n    readonly INUSE_ATTRIBUTE_ERR: number;\n    readonly INVALID_ACCESS_ERR: number;\n    readonly INVALID_CHARACTER_ERR: number;\n    readonly INVALID_MODIFICATION_ERR: number;\n    readonly INVALID_NODE_TYPE_ERR: number;\n    readonly INVALID_STATE_ERR: number;\n    readonly NAMESPACE_ERR: number;\n    readonly NETWORK_ERR: number;\n    readonly NOT_FOUND_ERR: number;\n    readonly NOT_SUPPORTED_ERR: number;\n    readonly NO_DATA_ALLOWED_ERR: number;\n    readonly NO_MODIFICATION_ALLOWED_ERR: number;\n    readonly QUOTA_EXCEEDED_ERR: number;\n    readonly SECURITY_ERR: number;\n    readonly SYNTAX_ERR: number;\n    readonly TIMEOUT_ERR: number;\n    readonly TYPE_MISMATCH_ERR: number;\n    readonly URL_MISMATCH_ERR: number;\n    readonly VALIDATION_ERR: number;\n    readonly WRONG_DOCUMENT_ERR: number;\n};\n\ninterface DOMMatrix extends DOMMatrixReadOnly {\n    a: number;\n    b: number;\n    c: number;\n    d: number;\n    e: number;\n    f: number;\n    m11: number;\n    m12: number;\n    m13: number;\n    m14: number;\n    m21: number;\n    m22: number;\n    m23: number;\n    m24: number;\n    m31: number;\n    m32: number;\n    m33: number;\n    m34: number;\n    m41: number;\n    m42: number;\n    m43: number;\n    m44: number;\n    invertSelf(): DOMMatrix;\n    multiplySelf(other?: DOMMatrixInit): DOMMatrix;\n    preMultiplySelf(other?: DOMMatrixInit): DOMMatrix;\n    rotateAxisAngleSelf(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;\n    rotateFromVectorSelf(x?: number, y?: number): DOMMatrix;\n    rotateSelf(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;\n    scale3dSelf(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    scaleSelf(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    skewXSelf(sx?: number): DOMMatrix;\n    skewYSelf(sy?: number): DOMMatrix;\n    translateSelf(tx?: number, ty?: number, tz?: number): DOMMatrix;\n}\n\ndeclare var DOMMatrix: {\n    prototype: DOMMatrix;\n    new(init?: string | number[]): DOMMatrix;\n    fromFloat32Array(array32: Float32Array): DOMMatrix;\n    fromFloat64Array(array64: Float64Array): DOMMatrix;\n    fromMatrix(other?: DOMMatrixInit): DOMMatrix;\n};\n\ninterface DOMMatrixReadOnly {\n    readonly a: number;\n    readonly b: number;\n    readonly c: number;\n    readonly d: number;\n    readonly e: number;\n    readonly f: number;\n    readonly is2D: boolean;\n    readonly isIdentity: boolean;\n    readonly m11: number;\n    readonly m12: number;\n    readonly m13: number;\n    readonly m14: number;\n    readonly m21: number;\n    readonly m22: number;\n    readonly m23: number;\n    readonly m24: number;\n    readonly m31: number;\n    readonly m32: number;\n    readonly m33: number;\n    readonly m34: number;\n    readonly m41: number;\n    readonly m42: number;\n    readonly m43: number;\n    readonly m44: number;\n    flipX(): DOMMatrix;\n    flipY(): DOMMatrix;\n    inverse(): DOMMatrix;\n    multiply(other?: DOMMatrixInit): DOMMatrix;\n    rotate(rotX?: number, rotY?: number, rotZ?: number): DOMMatrix;\n    rotateAxisAngle(x?: number, y?: number, z?: number, angle?: number): DOMMatrix;\n    rotateFromVector(x?: number, y?: number): DOMMatrix;\n    scale(scaleX?: number, scaleY?: number, scaleZ?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    scale3d(scale?: number, originX?: number, originY?: number, originZ?: number): DOMMatrix;\n    skewX(sx?: number): DOMMatrix;\n    skewY(sy?: number): DOMMatrix;\n    toFloat32Array(): Float32Array;\n    toFloat64Array(): Float64Array;\n    toJSON(): any;\n    transformPoint(point?: DOMPointInit): DOMPoint;\n    translate(tx?: number, ty?: number, tz?: number): DOMMatrix;\n}\n\ndeclare var DOMMatrixReadOnly: {\n    prototype: DOMMatrixReadOnly;\n    new(init?: string | number[]): DOMMatrixReadOnly;\n    fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly;\n    fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly;\n    fromMatrix(other?: DOMMatrixInit): DOMMatrixReadOnly;\n};\n\ninterface DOMPoint extends DOMPointReadOnly {\n    w: number;\n    x: number;\n    y: number;\n    z: number;\n}\n\ndeclare var DOMPoint: {\n    prototype: DOMPoint;\n    new(x?: number, y?: number, z?: number, w?: number): DOMPoint;\n    fromPoint(other?: DOMPointInit): DOMPoint;\n};\n\ninterface DOMPointReadOnly {\n    readonly w: number;\n    readonly x: number;\n    readonly y: number;\n    readonly z: number;\n    matrixTransform(matrix?: DOMMatrixInit): DOMPoint;\n    toJSON(): any;\n}\n\ndeclare var DOMPointReadOnly: {\n    prototype: DOMPointReadOnly;\n    new(x?: number, y?: number, z?: number, w?: number): DOMPointReadOnly;\n    fromPoint(other?: DOMPointInit): DOMPointReadOnly;\n};\n\ninterface DOMQuad {\n    readonly p1: DOMPoint;\n    readonly p2: DOMPoint;\n    readonly p3: DOMPoint;\n    readonly p4: DOMPoint;\n    getBounds(): DOMRect;\n    toJSON(): any;\n}\n\ndeclare var DOMQuad: {\n    prototype: DOMQuad;\n    new(p1?: DOMPointInit, p2?: DOMPointInit, p3?: DOMPointInit, p4?: DOMPointInit): DOMQuad;\n    fromQuad(other?: DOMQuadInit): DOMQuad;\n    fromRect(other?: DOMRectInit): DOMQuad;\n};\n\ninterface DOMRect extends DOMRectReadOnly {\n    height: number;\n    width: number;\n    x: number;\n    y: number;\n}\n\ndeclare var DOMRect: {\n    prototype: DOMRect;\n    new(x?: number, y?: number, width?: number, height?: number): DOMRect;\n    fromRect(other?: DOMRectInit): DOMRect;\n};\n\ninterface DOMRectReadOnly {\n    readonly bottom: number;\n    readonly height: number;\n    readonly left: number;\n    readonly right: number;\n    readonly top: number;\n    readonly width: number;\n    readonly x: number;\n    readonly y: number;\n    toJSON(): any;\n}\n\ndeclare var DOMRectReadOnly: {\n    prototype: DOMRectReadOnly;\n    new(x?: number, y?: number, width?: number, height?: number): DOMRectReadOnly;\n    fromRect(other?: DOMRectInit): DOMRectReadOnly;\n};\n\ninterface DOMStringList {\n    /**\n     * Returns the number of strings in strings.\n     */\n    readonly length: number;\n    /**\n     * Returns true if strings contains string, and false\n     * otherwise.\n     */\n    contains(string: string): boolean;\n    /**\n     * Returns the string with index index from strings.\n     */\n    item(index: number): string | null;\n    [index: number]: string;\n}\n\ndeclare var DOMStringList: {\n    prototype: DOMStringList;\n    new(): DOMStringList;\n};\n\ninterface DedicatedWorkerGlobalScopeEventMap extends WorkerGlobalScopeEventMap {\n    "message": MessageEvent;\n}\n\ninterface DedicatedWorkerGlobalScope extends WorkerGlobalScope {\n    onmessage: ((this: DedicatedWorkerGlobalScope, ev: MessageEvent) => any) | null;\n    close(): void;\n    postMessage(message: any, transfer?: Transferable[]): void;\n    addEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type: K, listener: (this: DedicatedWorkerGlobalScope, ev: DedicatedWorkerGlobalScopeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type: K, listener: (this: DedicatedWorkerGlobalScope, ev: DedicatedWorkerGlobalScopeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var DedicatedWorkerGlobalScope: {\n    prototype: DedicatedWorkerGlobalScope;\n    new(): DedicatedWorkerGlobalScope;\n};\n\ninterface DhImportKeyParams extends Algorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface DhKeyAlgorithm extends KeyAlgorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface DhKeyDeriveParams extends Algorithm {\n    public: CryptoKey;\n}\n\ninterface DhKeyGenParams extends Algorithm {\n    generator: Uint8Array;\n    prime: Uint8Array;\n}\n\ninterface EXT_blend_minmax {\n    readonly MAX_EXT: GLenum;\n    readonly MIN_EXT: GLenum;\n}\n\ninterface EXT_frag_depth {\n}\n\ninterface EXT_sRGB {\n    readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: GLenum;\n    readonly SRGB8_ALPHA8_EXT: GLenum;\n    readonly SRGB_ALPHA_EXT: GLenum;\n    readonly SRGB_EXT: GLenum;\n}\n\ninterface EXT_shader_texture_lod {\n}\n\ninterface EXT_texture_filter_anisotropic {\n    readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT: GLenum;\n    readonly TEXTURE_MAX_ANISOTROPY_EXT: GLenum;\n}\n\ninterface ErrorEvent extends Event {\n    readonly colno: number;\n    readonly error: any;\n    readonly filename: string;\n    readonly lineno: number;\n    readonly message: string;\n}\n\ndeclare var ErrorEvent: {\n    prototype: ErrorEvent;\n    new(type: string, eventInitDict?: ErrorEventInit): ErrorEvent;\n};\n\ninterface Event {\n    /**\n     * Returns true or false depending on how event was initialized. True if event goes through its target\'s ancestors in reverse tree order, and false otherwise.\n     */\n    readonly bubbles: boolean;\n    cancelBubble: boolean;\n    readonly cancelable: boolean;\n    /**\n     * Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.\n     */\n    readonly composed: boolean;\n    /**\n     * Returns the object whose event listener\'s callback is currently being\n     * invoked.\n     */\n    readonly currentTarget: EventTarget | null;\n    readonly defaultPrevented: boolean;\n    readonly eventPhase: number;\n    /**\n     * Returns true if event was dispatched by the user agent, and\n     * false otherwise.\n     */\n    readonly isTrusted: boolean;\n    returnValue: boolean;\n    /**\n     * Returns the object to which event is dispatched (its target).\n     */\n    readonly target: EventTarget | null;\n    /**\n     * Returns the event\'s timestamp as the number of milliseconds measured relative to\n     * the time origin.\n     */\n    readonly timeStamp: number;\n    /**\n     * Returns the type of event, e.g.\n     * "click", "hashchange", or\n     * "submit".\n     */\n    readonly type: string;\n    composedPath(): EventTarget[];\n    initEvent(type: string, bubbles?: boolean, cancelable?: boolean): void;\n    preventDefault(): void;\n    /**\n     * Invoking this method prevents event from reaching\n     * any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any\n     * other objects.\n     */\n    stopImmediatePropagation(): void;\n    /**\n     * When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.\n     */\n    stopPropagation(): void;\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n    readonly NONE: number;\n}\n\ndeclare var Event: {\n    prototype: Event;\n    new(type: string, eventInitDict?: EventInit): Event;\n    readonly AT_TARGET: number;\n    readonly BUBBLING_PHASE: number;\n    readonly CAPTURING_PHASE: number;\n    readonly NONE: number;\n};\n\ninterface EventListenerObject {\n    handleEvent(evt: Event): void;\n}\n\ninterface EventSource extends EventTarget {\n    readonly CLOSED: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n    onerror: (evt: MessageEvent) => any;\n    onmessage: (evt: MessageEvent) => any;\n    onopen: (evt: MessageEvent) => any;\n    readonly readyState: number;\n    readonly url: string;\n    readonly withCredentials: boolean;\n    close(): void;\n}\n\ndeclare var EventSource: {\n    prototype: EventSource;\n    new(url: string, eventSourceInitDict?: EventSourceInit): EventSource;\n};\n\ninterface EventSourceInit {\n    readonly withCredentials: boolean;\n}\n\ninterface EventTarget {\n    /**\n     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.\n     * The options argument sets listener-specific options. For compatibility this can be a\n     * boolean, in which case the method behaves exactly as if the value was specified as options\'s capture.\n     * When set to true, options\'s capture prevents callback from being invoked when the event\'s eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event\'s eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event\'s eventPhase attribute value is AT_TARGET.\n     * When set to true, options\'s passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in \xa72.8 Observing event listeners.\n     * When set to true, options\'s once indicates that the callback will only be invoked once after which the event listener will\n     * be removed.\n     * The event listener is appended to target\'s event listener list and is not appended if it has the same type, callback, and capture.\n     */\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void;\n    /**\n     * Dispatches a synthetic event event to target and returns true\n     * if either event\'s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n     */\n    dispatchEvent(event: Event): boolean;\n    /**\n     * Removes the event listener in target\'s event listener list with the same type, callback, and options.\n     */\n    removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;\n}\n\ndeclare var EventTarget: {\n    prototype: EventTarget;\n    new(): EventTarget;\n};\n\ninterface ExtendableEvent extends Event {\n    waitUntil(f: Promise<any>): void;\n}\n\ndeclare var ExtendableEvent: {\n    prototype: ExtendableEvent;\n    new(type: string, eventInitDict?: ExtendableEventInit): ExtendableEvent;\n};\n\ninterface ExtendableMessageEvent extends ExtendableEvent {\n    readonly data: any;\n    readonly lastEventId: string;\n    readonly origin: string;\n    readonly ports: ReadonlyArray<MessagePort>;\n    readonly source: Client | ServiceWorker | MessagePort | null;\n}\n\ndeclare var ExtendableMessageEvent: {\n    prototype: ExtendableMessageEvent;\n    new(type: string, eventInitDict?: ExtendableMessageEventInit): ExtendableMessageEvent;\n};\n\ninterface FetchEvent extends ExtendableEvent {\n    readonly clientId: string;\n    readonly preloadResponse: Promise<any>;\n    readonly request: Request;\n    readonly resultingClientId: string;\n    readonly targetClientId: string;\n    respondWith(r: Promise<Response>): void;\n}\n\ndeclare var FetchEvent: {\n    prototype: FetchEvent;\n    new(type: string, eventInitDict: FetchEventInit): FetchEvent;\n};\n\ninterface File extends Blob {\n    readonly lastModified: number;\n    readonly name: string;\n}\n\ndeclare var File: {\n    prototype: File;\n    new(fileBits: BlobPart[], fileName: string, options?: FilePropertyBag): File;\n};\n\ninterface FileList {\n    readonly length: number;\n    item(index: number): File | null;\n    [index: number]: File;\n}\n\ndeclare var FileList: {\n    prototype: FileList;\n    new(): FileList;\n};\n\ninterface FileReaderEventMap {\n    "abort": ProgressEvent;\n    "error": ProgressEvent;\n    "load": ProgressEvent;\n    "loadend": ProgressEvent;\n    "loadstart": ProgressEvent;\n    "progress": ProgressEvent;\n}\n\ninterface FileReader extends EventTarget {\n    readonly error: DOMException | null;\n    onabort: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onerror: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onload: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: FileReader, ev: ProgressEvent) => any) | null;\n    readonly readyState: number;\n    readonly result: string | ArrayBuffer | null;\n    abort(): void;\n    readAsArrayBuffer(blob: Blob): void;\n    readAsBinaryString(blob: Blob): void;\n    readAsDataURL(blob: Blob): void;\n    readAsText(blob: Blob, encoding?: string): void;\n    readonly DONE: number;\n    readonly EMPTY: number;\n    readonly LOADING: number;\n    addEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof FileReaderEventMap>(type: K, listener: (this: FileReader, ev: FileReaderEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var FileReader: {\n    prototype: FileReader;\n    new(): FileReader;\n    readonly DONE: number;\n    readonly EMPTY: number;\n    readonly LOADING: number;\n};\n\ninterface FileReaderSync {\n    readAsArrayBuffer(blob: Blob): ArrayBuffer;\n    readAsBinaryString(blob: Blob): string;\n    readAsDataURL(blob: Blob): string;\n    readAsText(blob: Blob, encoding?: string): string;\n}\n\ndeclare var FileReaderSync: {\n    prototype: FileReaderSync;\n    new(): FileReaderSync;\n};\n\ninterface FormData {\n    append(name: string, value: string | Blob, fileName?: string): void;\n    delete(name: string): void;\n    get(name: string): FormDataEntryValue | null;\n    getAll(name: string): FormDataEntryValue[];\n    has(name: string): boolean;\n    set(name: string, value: string | Blob, fileName?: string): void;\n    forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData) => void, thisArg?: any): void;\n}\n\ndeclare var FormData: {\n    prototype: FormData;\n    new(): FormData;\n};\n\ninterface GlobalFetch {\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n}\n\ninterface Headers {\n    append(name: string, value: string): void;\n    delete(name: string): void;\n    get(name: string): string | null;\n    has(name: string): boolean;\n    set(name: string, value: string): void;\n    forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: any): void;\n}\n\ndeclare var Headers: {\n    prototype: Headers;\n    new(init?: HeadersInit): Headers;\n};\n\ninterface HkdfCtrParams extends Algorithm {\n    context: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n    hash: string | Algorithm;\n    label: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n}\n\ninterface IDBArrayKey extends Array<IDBValidKey> {\n}\n\ninterface IDBCursor {\n    /**\n     * Returns the direction ("next", "nextunique", "prev" or "prevunique")\n     * of the cursor.\n     */\n    readonly direction: IDBCursorDirection;\n    /**\n     * Returns the key of the cursor.\n     * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n     */\n    readonly key: IDBValidKey | IDBKeyRange;\n    /**\n     * Returns the effective key of the cursor.\n     * Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished.\n     */\n    readonly primaryKey: IDBValidKey | IDBKeyRange;\n    /**\n     * Returns the IDBObjectStore or IDBIndex the cursor was opened from.\n     */\n    readonly source: IDBObjectStore | IDBIndex;\n    /**\n     * Advances the cursor through the next count records in\n     * range.\n     */\n    advance(count: number): void;\n    /**\n     * Advances the cursor to the next record in range matching or\n     * after key.\n     */\n    continue(key?: IDBValidKey | IDBKeyRange): void;\n    /**\n     * Advances the cursor to the next record in range matching\n     * or after key and primaryKey. Throws an "InvalidAccessError" DOMException if the source is not an index.\n     */\n    continuePrimaryKey(key: IDBValidKey | IDBKeyRange, primaryKey: IDBValidKey | IDBKeyRange): void;\n    /**\n     * Delete the record pointed at by the cursor with a new value.\n     * If successful, request\'s result will be undefined.\n     */\n    delete(): IDBRequest<undefined>;\n    /**\n     * Updated the record pointed at by the cursor with a new value.\n     * Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.\n     * If successful, request\'s result will be the record\'s key.\n     */\n    update(value: any): IDBRequest<IDBValidKey>;\n}\n\ndeclare var IDBCursor: {\n    prototype: IDBCursor;\n    new(): IDBCursor;\n};\n\ninterface IDBCursorWithValue extends IDBCursor {\n    /**\n     * Returns the cursor\'s current value.\n     */\n    readonly value: any;\n}\n\ndeclare var IDBCursorWithValue: {\n    prototype: IDBCursorWithValue;\n    new(): IDBCursorWithValue;\n};\n\ninterface IDBDatabaseEventMap {\n    "abort": Event;\n    "close": Event;\n    "error": Event;\n    "versionchange": IDBVersionChangeEvent;\n}\n\ninterface IDBDatabase extends EventTarget {\n    /**\n     * Returns the name of the database.\n     */\n    readonly name: string;\n    /**\n     * Returns a list of the names of object stores in the database.\n     */\n    readonly objectStoreNames: DOMStringList;\n    onabort: ((this: IDBDatabase, ev: Event) => any) | null;\n    onclose: ((this: IDBDatabase, ev: Event) => any) | null;\n    onerror: ((this: IDBDatabase, ev: Event) => any) | null;\n    onversionchange: ((this: IDBDatabase, ev: IDBVersionChangeEvent) => any) | null;\n    /**\n     * Returns the version of the database.\n     */\n    readonly version: number;\n    /**\n     * Closes the connection once all running transactions have finished.\n     */\n    close(): void;\n    /**\n     * Creates a new object store with the given name and options and returns a new IDBObjectStore.\n     * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n     */\n    createObjectStore(name: string, optionalParameters?: IDBObjectStoreParameters): IDBObjectStore;\n    /**\n     * Deletes the object store with the given name.\n     * Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.\n     */\n    deleteObjectStore(name: string): void;\n    /**\n     * Returns a new transaction with the given mode ("readonly" or "readwrite")\n     * and scope which can be a single object store name or an array of names.\n     */\n    transaction(storeNames: string | string[], mode?: IDBTransactionMode): IDBTransaction;\n    addEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBDatabaseEventMap>(type: K, listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBDatabase: {\n    prototype: IDBDatabase;\n    new(): IDBDatabase;\n};\n\ninterface IDBFactory {\n    /**\n     * Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if\n     * the keys are equal.\n     * Throws a "DataError" DOMException if either input is not a valid key.\n     */\n    cmp(first: any, second: any): number;\n    /**\n     * Attempts to delete the named database. If the\n     * database already exists and there are open connections that don\'t close in response to a versionchange event, the request will be blocked until all they close. If the request\n     * is successful request\'s result will be null.\n     */\n    deleteDatabase(name: string): IDBOpenDBRequest;\n    /**\n     * Attempts to open a connection to the named database with the specified version. If the database already exists\n     * with a lower version and there are open connections that don\'t close in response to a versionchange event, the request will be blocked until all they close, then an upgrade\n     * will occur. If the database already exists with a higher\n     * version the request will fail. If the request is\n     * successful request\'s result will\n     * be the connection.\n     */\n    open(name: string, version?: number): IDBOpenDBRequest;\n}\n\ndeclare var IDBFactory: {\n    prototype: IDBFactory;\n    new(): IDBFactory;\n};\n\ninterface IDBIndex {\n    readonly keyPath: string | string[];\n    readonly multiEntry: boolean;\n    /**\n     * Updates the name of the store to newName.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    name: string;\n    /**\n     * Returns the IDBObjectStore the index belongs to.\n     */\n    readonly objectStore: IDBObjectStore;\n    readonly unique: boolean;\n    /**\n     * Retrieves the number of records matching the given key or key range in query.\n     * If successful, request\'s result will be the\n     * count.\n     */\n    count(key?: IDBValidKey | IDBKeyRange): IDBRequest<number>;\n    /**\n     * Retrieves the value of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the value, or undefined if there was no matching record.\n     */\n    get(key: IDBValidKey | IDBKeyRange): IDBRequest<any | undefined>;\n    /**\n     * Retrieves the values of the records matching the given key or key range in query (up to count if given).\n     * If successful, request\'s result will be an Array of the values.\n     */\n    getAll(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<any[]>;\n    /**\n     * Retrieves the keys of records matching the given key or key range in query (up to count if given).\n     * If successful, request\'s result will be an Array of the keys.\n     */\n    getAllKeys(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<IDBValidKey[]>;\n    /**\n     * Retrieves the key of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the key, or undefined if there was no matching record.\n     */\n    getKey(key: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined>;\n    /**\n     * Opens a cursor over the records matching query,\n     * ordered by direction. If query is null, all records in index are matched.\n     * If successful, request\'s result will be an IDBCursorWithValue, or null if there were no matching records.\n     */\n    openCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursorWithValue | null>;\n    /**\n     * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in index are matched.\n     * If successful, request\'s result will be an IDBCursor, or null if there were no matching records.\n     */\n    openKeyCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursor | null>;\n}\n\ndeclare var IDBIndex: {\n    prototype: IDBIndex;\n    new(): IDBIndex;\n};\n\ninterface IDBKeyRange {\n    /**\n     * Returns lower bound, or undefined if none.\n     */\n    readonly lower: any;\n    /**\n     * Returns true if the lower open flag is set, and false otherwise.\n     */\n    readonly lowerOpen: boolean;\n    /**\n     * Returns upper bound, or undefined if none.\n     */\n    readonly upper: any;\n    /**\n     * Returns true if the upper open flag is set, and false otherwise.\n     */\n    readonly upperOpen: boolean;\n    /**\n     * Returns true if key is included in the range, and false otherwise.\n     */\n    includes(key: any): boolean;\n}\n\ndeclare var IDBKeyRange: {\n    prototype: IDBKeyRange;\n    new(): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange spanning from lower to upper.\n     * If lowerOpen is true, lower is not included in the range.\n     * If upperOpen is true, upper is not included in the range.\n     */\n    bound(lower: any, upper: any, lowerOpen?: boolean, upperOpen?: boolean): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange starting at key with no\n     * upper bound. If open is true, key is not included in the\n     * range.\n     */\n    lowerBound(lower: any, open?: boolean): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange spanning only key.\n     */\n    only(value: any): IDBKeyRange;\n    /**\n     * Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range.\n     */\n    upperBound(upper: any, open?: boolean): IDBKeyRange;\n};\n\ninterface IDBObjectStore {\n    /**\n     * Returns true if the store has a key generator, and false otherwise.\n     */\n    readonly autoIncrement: boolean;\n    /**\n     * Returns a list of the names of indexes in the store.\n     */\n    readonly indexNames: DOMStringList;\n    /**\n     * Returns the key path of the store, or null if none.\n     */\n    readonly keyPath: string | string[];\n    /**\n     * Updates the name of the store to newName.\n     * Throws "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    name: string;\n    /**\n     * Returns the associated transaction.\n     */\n    readonly transaction: IDBTransaction;\n    add(value: any, key?: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;\n    /**\n     * Deletes all records in store.\n     * If successful, request\'s result will\n     * be undefined.\n     */\n    clear(): IDBRequest<undefined>;\n    /**\n     * Retrieves the number of records matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the count.\n     */\n    count(key?: IDBValidKey | IDBKeyRange): IDBRequest<number>;\n    /**\n     * Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be\n     * satisfied with the data already in store the upgrade\n     * transaction will abort with\n     * a "ConstraintError" DOMException.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    createIndex(name: string, keyPath: string | string[], options?: IDBIndexParameters): IDBIndex;\n    /**\n     * Deletes records in store with the given key or in the given key range in query.\n     * If successful, request\'s result will\n     * be undefined.\n     */\n    delete(key: IDBValidKey | IDBKeyRange): IDBRequest<undefined>;\n    /**\n     * Deletes the index in store with the given name.\n     * Throws an "InvalidStateError" DOMException if not called within an upgrade\n     * transaction.\n     */\n    deleteIndex(name: string): void;\n    /**\n     * Retrieves the value of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the value, or undefined if there was no matching record.\n     */\n    get(query: IDBValidKey | IDBKeyRange): IDBRequest<any | undefined>;\n    /**\n     * Retrieves the values of the records matching the\n     * given key or key range in query (up to count if given).\n     * If successful, request\'s result will\n     * be an Array of the values.\n     */\n    getAll(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<any[]>;\n    /**\n     * Retrieves the keys of records matching the\n     * given key or key range in query (up to count if given).\n     * If successful, request\'s result will\n     * be an Array of the keys.\n     */\n    getAllKeys(query?: IDBValidKey | IDBKeyRange, count?: number): IDBRequest<IDBValidKey[]>;\n    /**\n     * Retrieves the key of the first record matching the\n     * given key or key range in query.\n     * If successful, request\'s result will be the key, or undefined if there was no matching record.\n     */\n    getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey | undefined>;\n    index(name: string): IDBIndex;\n    /**\n     * Opens a cursor over the records matching query,\n     * ordered by direction. If query is null, all records in store are matched.\n     * If successful, request\'s result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.\n     */\n    openCursor(range?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursorWithValue | null>;\n    /**\n     * Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in store are matched.\n     * If successful, request\'s result will be an IDBCursor pointing at the first matching record, or\n     * null if there were no matching records.\n     */\n    openKeyCursor(query?: IDBValidKey | IDBKeyRange, direction?: IDBCursorDirection): IDBRequest<IDBCursor | null>;\n    put(value: any, key?: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey>;\n}\n\ndeclare var IDBObjectStore: {\n    prototype: IDBObjectStore;\n    new(): IDBObjectStore;\n};\n\ninterface IDBOpenDBRequestEventMap extends IDBRequestEventMap {\n    "blocked": Event;\n    "upgradeneeded": IDBVersionChangeEvent;\n}\n\ninterface IDBOpenDBRequest extends IDBRequest<IDBDatabase> {\n    onblocked: ((this: IDBOpenDBRequest, ev: Event) => any) | null;\n    onupgradeneeded: ((this: IDBOpenDBRequest, ev: IDBVersionChangeEvent) => any) | null;\n    addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBOpenDBRequestEventMap>(type: K, listener: (this: IDBOpenDBRequest, ev: IDBOpenDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBOpenDBRequest: {\n    prototype: IDBOpenDBRequest;\n    new(): IDBOpenDBRequest;\n};\n\ninterface IDBRequestEventMap {\n    "error": Event;\n    "success": Event;\n}\n\ninterface IDBRequest<T = any> extends EventTarget {\n    /**\n     * When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws\n     * a "InvalidStateError" DOMException if the request is still pending.\n     */\n    readonly error: DOMException | null;\n    onerror: ((this: IDBRequest<T>, ev: Event) => any) | null;\n    onsuccess: ((this: IDBRequest<T>, ev: Event) => any) | null;\n    /**\n     * Returns "pending" until a request is complete,\n     * then returns "done".\n     */\n    readonly readyState: IDBRequestReadyState;\n    /**\n     * When a request is completed, returns the result,\n     * or undefined if the request failed. Throws a\n     * "InvalidStateError" DOMException if the request is still pending.\n     */\n    readonly result: T;\n    /**\n     * Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if is was an open\n     * request.\n     */\n    readonly source: IDBObjectStore | IDBIndex | IDBCursor;\n    /**\n     * Returns the IDBTransaction the request was made within.\n     * If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise.\n     */\n    readonly transaction: IDBTransaction | null;\n    addEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest<T>, ev: IDBRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBRequestEventMap>(type: K, listener: (this: IDBRequest<T>, ev: IDBRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBRequest: {\n    prototype: IDBRequest;\n    new(): IDBRequest;\n};\n\ninterface IDBTransactionEventMap {\n    "abort": Event;\n    "complete": Event;\n    "error": Event;\n}\n\ninterface IDBTransaction extends EventTarget {\n    /**\n     * Returns the transaction\'s connection.\n     */\n    readonly db: IDBDatabase;\n    /**\n     * If the transaction was aborted, returns the\n     * error (a DOMException) providing the reason.\n     */\n    readonly error: DOMException;\n    /**\n     * Returns the mode the transaction was created with\n     * ("readonly" or "readwrite"), or "versionchange" for\n     * an upgrade transaction.\n     */\n    readonly mode: IDBTransactionMode;\n    /**\n     * Returns a list of the names of object stores in the\n     * transaction\'s scope. For an upgrade transaction this is all object stores in the database.\n     */\n    readonly objectStoreNames: DOMStringList;\n    onabort: ((this: IDBTransaction, ev: Event) => any) | null;\n    oncomplete: ((this: IDBTransaction, ev: Event) => any) | null;\n    onerror: ((this: IDBTransaction, ev: Event) => any) | null;\n    /**\n     * Aborts the transaction. All pending requests will fail with\n     * a "AbortError" DOMException and all changes made to the database will be\n     * reverted.\n     */\n    abort(): void;\n    /**\n     * Returns an IDBObjectStore in the transaction\'s scope.\n     */\n    objectStore(name: string): IDBObjectStore;\n    addEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof IDBTransactionEventMap>(type: K, listener: (this: IDBTransaction, ev: IDBTransactionEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var IDBTransaction: {\n    prototype: IDBTransaction;\n    new(): IDBTransaction;\n};\n\ninterface IDBVersionChangeEvent extends Event {\n    readonly newVersion: number | null;\n    readonly oldVersion: number;\n}\n\ndeclare var IDBVersionChangeEvent: {\n    prototype: IDBVersionChangeEvent;\n    new(type: string, eventInitDict?: IDBVersionChangeEventInit): IDBVersionChangeEvent;\n};\n\ninterface ImageBitmap {\n    /**\n     * Returns the intrinsic height of the image, in CSS\n     * pixels.\n     */\n    readonly height: number;\n    /**\n     * Returns the intrinsic width of the image, in CSS\n     * pixels.\n     */\n    readonly width: number;\n    /**\n     * Releases imageBitmap\'s underlying bitmap data.\n     */\n    close(): void;\n}\n\ndeclare var ImageBitmap: {\n    prototype: ImageBitmap;\n    new(): ImageBitmap;\n};\n\ninterface ImageBitmapOptions {\n    colorSpaceConversion?: "none" | "default";\n    imageOrientation?: "none" | "flipY";\n    premultiplyAlpha?: "none" | "premultiply" | "default";\n    resizeHeight?: number;\n    resizeQuality?: "pixelated" | "low" | "medium" | "high";\n    resizeWidth?: number;\n}\n\ninterface ImageData {\n    /**\n     * Returns the one-dimensional array containing the data in RGBA order, as integers in the\n     * range 0 to 255.\n     */\n    readonly data: Uint8ClampedArray;\n    /**\n     * Returns the actual dimensions of the data in the ImageData object, in\n     * pixels.\n     */\n    readonly height: number;\n    readonly width: number;\n}\n\ndeclare var ImageData: {\n    prototype: ImageData;\n    new(width: number, height: number): ImageData;\n    new(array: Uint8ClampedArray, width: number, height: number): ImageData;\n};\n\ninterface MessageChannel {\n    readonly port1: MessagePort;\n    readonly port2: MessagePort;\n}\n\ndeclare var MessageChannel: {\n    prototype: MessageChannel;\n    new(): MessageChannel;\n};\n\ninterface MessageEvent extends Event {\n    /**\n     * Returns the data of the message.\n     */\n    readonly data: any;\n    /**\n     * Returns the last event ID string, for\n     * server-sent events.\n     */\n    readonly lastEventId: string;\n    /**\n     * Returns the origin of the message, for server-sent events and\n     * cross-document messaging.\n     */\n    readonly origin: string;\n    /**\n     * Returns the MessagePort array sent with the message, for cross-document\n     * messaging and channel messaging.\n     */\n    readonly ports: ReadonlyArray<MessagePort>;\n    /**\n     * Returns the WindowProxy of the source window, for cross-document\n     * messaging, and the MessagePort being attached, in the connect event fired at\n     * SharedWorkerGlobalScope objects.\n     */\n    readonly source: MessageEventSource | null;\n}\n\ndeclare var MessageEvent: {\n    prototype: MessageEvent;\n    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;\n};\n\ninterface MessagePortEventMap {\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface MessagePort extends EventTarget {\n    onmessage: ((this: MessagePort, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: MessagePort, ev: MessageEvent) => any) | null;\n    /**\n     * Disconnects the port, so that it is no longer active.\n     */\n    close(): void;\n    /**\n     * Posts a message through the channel. Objects listed in transfer are\n     * transferred, not just cloned, meaning that they are no longer usable on the sending side.\n     * Throws a "DataCloneError" DOMException if\n     * transfer contains duplicate objects or port, or if message\n     * could not be cloned.\n     */\n    postMessage(message: any, transfer?: Transferable[]): void;\n    /**\n     * Begins dispatching messages received on the port.\n     */\n    start(): void;\n    addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var MessagePort: {\n    prototype: MessagePort;\n    new(): MessagePort;\n};\n\ninterface NavigationPreloadManager {\n    disable(): Promise<void>;\n    enable(): Promise<void>;\n    getState(): Promise<NavigationPreloadState>;\n    setHeaderValue(value: string): Promise<void>;\n}\n\ndeclare var NavigationPreloadManager: {\n    prototype: NavigationPreloadManager;\n    new(): NavigationPreloadManager;\n};\n\ninterface NavigatorBeacon {\n    sendBeacon(url: string, data?: Blob | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | FormData | string | null): boolean;\n}\n\ninterface NavigatorConcurrentHardware {\n    readonly hardwareConcurrency: number;\n}\n\ninterface NavigatorID {\n    readonly appCodeName: string;\n    readonly appName: string;\n    readonly appVersion: string;\n    readonly platform: string;\n    readonly product: string;\n    readonly productSub: string;\n    readonly userAgent: string;\n    readonly vendor: string;\n    readonly vendorSub: string;\n}\n\ninterface NavigatorOnLine {\n    readonly onLine: boolean;\n}\n\ninterface NavigatorStorage {\n    readonly storage: StorageManager;\n}\n\ninterface NotificationEventMap {\n    "click": Event;\n    "close": Event;\n    "error": Event;\n    "show": Event;\n}\n\ninterface Notification extends EventTarget {\n    readonly actions: ReadonlyArray<NotificationAction>;\n    readonly badge: string;\n    readonly body: string;\n    readonly data: any;\n    readonly dir: NotificationDirection;\n    readonly icon: string;\n    readonly image: string;\n    readonly lang: string;\n    onclick: ((this: Notification, ev: Event) => any) | null;\n    onclose: ((this: Notification, ev: Event) => any) | null;\n    onerror: ((this: Notification, ev: Event) => any) | null;\n    onshow: ((this: Notification, ev: Event) => any) | null;\n    readonly renotify: boolean;\n    readonly requireInteraction: boolean;\n    readonly silent: boolean;\n    readonly tag: string;\n    readonly timestamp: number;\n    readonly title: string;\n    readonly vibrate: ReadonlyArray<number>;\n    close(): void;\n    addEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof NotificationEventMap>(type: K, listener: (this: Notification, ev: NotificationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Notification: {\n    prototype: Notification;\n    new(title: string, options?: NotificationOptions): Notification;\n    readonly maxActions: number;\n    readonly permission: NotificationPermission;\n};\n\ninterface NotificationEvent extends ExtendableEvent {\n    readonly action: string;\n    readonly notification: Notification;\n}\n\ndeclare var NotificationEvent: {\n    prototype: NotificationEvent;\n    new(type: string, eventInitDict: NotificationEventInit): NotificationEvent;\n};\n\ninterface OES_element_index_uint {\n}\n\ninterface OES_standard_derivatives {\n    readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES: GLenum;\n}\n\ninterface OES_texture_float {\n}\n\ninterface OES_texture_float_linear {\n}\n\ninterface OES_texture_half_float {\n    readonly HALF_FLOAT_OES: GLenum;\n}\n\ninterface OES_texture_half_float_linear {\n}\n\ninterface OES_vertex_array_object {\n    bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): void;\n    createVertexArrayOES(): WebGLVertexArrayObjectOES | null;\n    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): void;\n    isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES | null): GLboolean;\n    readonly VERTEX_ARRAY_BINDING_OES: GLenum;\n}\n\ninterface Path2D extends CanvasPath {\n    addPath(path: Path2D, transform?: DOMMatrix2DInit): void;\n}\n\ndeclare var Path2D: {\n    prototype: Path2D;\n    new(path?: Path2D | string): Path2D;\n};\n\ninterface PerformanceEventMap {\n    "resourcetimingbufferfull": Event;\n}\n\ninterface Performance extends EventTarget {\n    onresourcetimingbufferfull: ((this: Performance, ev: Event) => any) | null;\n    readonly timeOrigin: number;\n    clearMarks(markName?: string): void;\n    clearMeasures(measureName?: string): void;\n    clearResourceTimings(): void;\n    getEntries(): PerformanceEntryList;\n    getEntriesByName(name: string, type?: string): PerformanceEntryList;\n    getEntriesByType(type: string): PerformanceEntryList;\n    mark(markName: string): void;\n    measure(measureName: string, startMark?: string, endMark?: string): void;\n    now(): number;\n    setResourceTimingBufferSize(maxSize: number): void;\n    toJSON(): any;\n    addEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof PerformanceEventMap>(type: K, listener: (this: Performance, ev: PerformanceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Performance: {\n    prototype: Performance;\n    new(): Performance;\n};\n\ninterface PerformanceEntry {\n    readonly duration: number;\n    readonly entryType: string;\n    readonly name: string;\n    readonly startTime: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceEntry: {\n    prototype: PerformanceEntry;\n    new(): PerformanceEntry;\n};\n\ninterface PerformanceMark extends PerformanceEntry {\n}\n\ndeclare var PerformanceMark: {\n    prototype: PerformanceMark;\n    new(): PerformanceMark;\n};\n\ninterface PerformanceMeasure extends PerformanceEntry {\n}\n\ndeclare var PerformanceMeasure: {\n    prototype: PerformanceMeasure;\n    new(): PerformanceMeasure;\n};\n\ninterface PerformanceObserver {\n    disconnect(): void;\n    observe(options: PerformanceObserverInit): void;\n    takeRecords(): PerformanceEntryList;\n}\n\ndeclare var PerformanceObserver: {\n    prototype: PerformanceObserver;\n    new(callback: PerformanceObserverCallback): PerformanceObserver;\n};\n\ninterface PerformanceObserverEntryList {\n    getEntries(): PerformanceEntryList;\n    getEntriesByName(name: string, type?: string): PerformanceEntryList;\n    getEntriesByType(type: string): PerformanceEntryList;\n}\n\ndeclare var PerformanceObserverEntryList: {\n    prototype: PerformanceObserverEntryList;\n    new(): PerformanceObserverEntryList;\n};\n\ninterface PerformanceResourceTiming extends PerformanceEntry {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly decodedBodySize: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly encodedBodySize: number;\n    readonly fetchStart: number;\n    readonly initiatorType: string;\n    readonly nextHopProtocol: string;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly secureConnectionStart: number;\n    readonly transferSize: number;\n    readonly workerStart: number;\n    toJSON(): any;\n}\n\ndeclare var PerformanceResourceTiming: {\n    prototype: PerformanceResourceTiming;\n    new(): PerformanceResourceTiming;\n};\n\ninterface ProgressEvent extends Event {\n    readonly lengthComputable: boolean;\n    readonly loaded: number;\n    readonly total: number;\n}\n\ndeclare var ProgressEvent: {\n    prototype: ProgressEvent;\n    new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;\n};\n\ninterface PromiseRejectionEvent extends Event {\n    readonly promise: Promise<any>;\n    readonly reason: any;\n}\n\ndeclare var PromiseRejectionEvent: {\n    prototype: PromiseRejectionEvent;\n    new(type: string, eventInitDict: PromiseRejectionEventInit): PromiseRejectionEvent;\n};\n\ninterface PushEvent extends ExtendableEvent {\n    readonly data: PushMessageData | null;\n}\n\ndeclare var PushEvent: {\n    prototype: PushEvent;\n    new(type: string, eventInitDict?: PushEventInit): PushEvent;\n};\n\ninterface PushManager {\n    getSubscription(): Promise<PushSubscription | null>;\n    permissionState(options?: PushSubscriptionOptionsInit): Promise<PushPermissionState>;\n    subscribe(options?: PushSubscriptionOptionsInit): Promise<PushSubscription>;\n}\n\ndeclare var PushManager: {\n    prototype: PushManager;\n    new(): PushManager;\n    readonly supportedContentEncodings: ReadonlyArray<string>;\n};\n\ninterface PushMessageData {\n    arrayBuffer(): ArrayBuffer;\n    blob(): Blob;\n    json(): any;\n    text(): string;\n}\n\ndeclare var PushMessageData: {\n    prototype: PushMessageData;\n    new(): PushMessageData;\n};\n\ninterface PushSubscription {\n    readonly endpoint: string;\n    readonly expirationTime: number | null;\n    readonly options: PushSubscriptionOptions;\n    getKey(name: PushEncryptionKeyName): ArrayBuffer | null;\n    toJSON(): PushSubscriptionJSON;\n    unsubscribe(): Promise<boolean>;\n}\n\ndeclare var PushSubscription: {\n    prototype: PushSubscription;\n    new(): PushSubscription;\n};\n\ninterface PushSubscriptionChangeEvent extends ExtendableEvent {\n    readonly newSubscription: PushSubscription | null;\n    readonly oldSubscription: PushSubscription | null;\n}\n\ndeclare var PushSubscriptionChangeEvent: {\n    prototype: PushSubscriptionChangeEvent;\n    new(type: string, eventInitDict?: PushSubscriptionChangeInit): PushSubscriptionChangeEvent;\n};\n\ninterface PushSubscriptionOptions {\n    readonly applicationServerKey: ArrayBuffer | null;\n    readonly userVisibleOnly: boolean;\n}\n\ndeclare var PushSubscriptionOptions: {\n    prototype: PushSubscriptionOptions;\n    new(): PushSubscriptionOptions;\n};\n\ninterface ReadableByteStreamController {\n    readonly byobRequest: ReadableStreamBYOBRequest | undefined;\n    readonly desiredSize: number | null;\n    close(): void;\n    enqueue(chunk: ArrayBufferView): void;\n    error(error?: any): void;\n}\n\ninterface ReadableStream<R = any> {\n    readonly locked: boolean;\n    cancel(reason?: any): Promise<void>;\n    getReader(options: { mode: "byob" }): ReadableStreamBYOBReader;\n    getReader(): ReadableStreamDefaultReader<R>;\n    pipeThrough<T>({ writable, readable }: { writable: WritableStream<R>, readable: ReadableStream<T> }, options?: PipeOptions): ReadableStream<T>;\n    pipeTo(dest: WritableStream<R>, options?: PipeOptions): Promise<void>;\n    tee(): [ReadableStream<R>, ReadableStream<R>];\n}\n\ndeclare var ReadableStream: {\n    prototype: ReadableStream;\n    new(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number, size?: undefined }): ReadableStream<Uint8Array>;\n    new<R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;\n};\n\ninterface ReadableStreamBYOBReader {\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n    read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>;\n    releaseLock(): void;\n}\n\ndeclare var ReadableStreamBYOBReader: {\n    prototype: ReadableStreamBYOBReader;\n    new(stream: ReadableStream<Uint8Array>): ReadableStreamBYOBReader;\n};\n\ninterface ReadableStreamBYOBRequest {\n    readonly view: ArrayBufferView;\n    respond(bytesWritten: number): void;\n    respondWithNewView(view: ArrayBufferView): void;\n}\n\ninterface ReadableStreamDefaultController<R = any> {\n    readonly desiredSize: number | null;\n    close(): void;\n    enqueue(chunk: R): void;\n    error(error?: any): void;\n}\n\ninterface ReadableStreamDefaultReader<R = any> {\n    readonly closed: Promise<void>;\n    cancel(reason?: any): Promise<void>;\n    read(): Promise<ReadableStreamReadResult<R>>;\n    releaseLock(): void;\n}\n\ninterface ReadableStreamReadResult<T> {\n    done: boolean;\n    value: T;\n}\n\ninterface ReadableStreamReader<R = any> {\n    cancel(): Promise<void>;\n    read(): Promise<ReadableStreamReadResult<R>>;\n    releaseLock(): void;\n}\n\ndeclare var ReadableStreamReader: {\n    prototype: ReadableStreamReader;\n    new(): ReadableStreamReader;\n};\n\ninterface Request extends Body {\n    /**\n     * Returns the cache mode associated with request, which is a string indicating\n     * how the request will interact with the browser\'s cache when fetching.\n     */\n    readonly cache: RequestCache;\n    /**\n     * Returns the credentials mode associated with request, which is a string\n     * indicating whether credentials will be sent with the request always, never, or only when sent to a\n     * same-origin URL.\n     */\n    readonly credentials: RequestCredentials;\n    /**\n     * Returns the kind of resource requested by request, e.g., "document" or\n     * "script".\n     */\n    readonly destination: RequestDestination;\n    /**\n     * Returns a Headers object consisting of the headers associated with request.\n     * Note that headers added in the network layer by the user agent will not be accounted for in this\n     * object, e.g., the "Host" header.\n     */\n    readonly headers: Headers;\n    /**\n     * Returns request\'s subresource integrity metadata, which is a cryptographic hash of\n     * the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]\n     */\n    readonly integrity: string;\n    /**\n     * Returns a boolean indicating whether or not request is for a history\n     * navigation (a.k.a. back-foward navigation).\n     */\n    readonly isHistoryNavigation: boolean;\n    /**\n     * Returns a boolean indicating whether or not request is for a reload navigation.\n     */\n    readonly isReloadNavigation: boolean;\n    /**\n     * Returns a boolean indicating whether or not request can outlive the global in which\n     * it was created.\n     */\n    readonly keepalive: boolean;\n    /**\n     * Returns request\'s HTTP method, which is "GET" by default.\n     */\n    readonly method: string;\n    /**\n     * Returns the mode associated with request, which is a string indicating\n     * whether the request will use CORS, or will be restricted to same-origin URLs.\n     */\n    readonly mode: RequestMode;\n    /**\n     * Returns the redirect mode associated with request, which is a string\n     * indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.\n     */\n    readonly redirect: RequestRedirect;\n    /**\n     * Returns the referrer of request. Its value can be a same-origin URL if\n     * explicitly set in init, the empty string to indicate no referrer, and\n     * "about:client" when defaulting to the global\'s default. This is used during\n     * fetching to determine the value of the `Referer` header of the request being made.\n     */\n    readonly referrer: string;\n    /**\n     * Returns the referrer policy associated with request. This is used during\n     * fetching to compute the value of the request\'s referrer.\n     */\n    readonly referrerPolicy: ReferrerPolicy;\n    /**\n     * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort\n     * event handler.\n     */\n    readonly signal: AbortSignal;\n    /**\n     * Returns the URL of request as a string.\n     */\n    readonly url: string;\n    clone(): Request;\n}\n\ndeclare var Request: {\n    prototype: Request;\n    new(input: RequestInfo, init?: RequestInit): Request;\n};\n\ninterface Response extends Body {\n    readonly headers: Headers;\n    readonly ok: boolean;\n    readonly redirected: boolean;\n    readonly status: number;\n    readonly statusText: string;\n    readonly trailer: Promise<Headers>;\n    readonly type: ResponseType;\n    readonly url: string;\n    clone(): Response;\n}\n\ndeclare var Response: {\n    prototype: Response;\n    new(body?: BodyInit | null, init?: ResponseInit): Response;\n    error(): Response;\n    redirect(url: string, status?: number): Response;\n};\n\ninterface ServiceWorkerEventMap extends AbstractWorkerEventMap {\n    "statechange": Event;\n}\n\ninterface ServiceWorker extends EventTarget, AbstractWorker {\n    onstatechange: ((this: ServiceWorker, ev: Event) => any) | null;\n    readonly scriptURL: string;\n    readonly state: ServiceWorkerState;\n    postMessage(message: any, transfer?: Transferable[]): void;\n    addEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerEventMap>(type: K, listener: (this: ServiceWorker, ev: ServiceWorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorker: {\n    prototype: ServiceWorker;\n    new(): ServiceWorker;\n};\n\ninterface ServiceWorkerContainerEventMap {\n    "controllerchange": Event;\n    "message": MessageEvent;\n    "messageerror": MessageEvent;\n}\n\ninterface ServiceWorkerContainer extends EventTarget {\n    readonly controller: ServiceWorker | null;\n    oncontrollerchange: ((this: ServiceWorkerContainer, ev: Event) => any) | null;\n    onmessage: ((this: ServiceWorkerContainer, ev: MessageEvent) => any) | null;\n    onmessageerror: ((this: ServiceWorkerContainer, ev: MessageEvent) => any) | null;\n    readonly ready: Promise<ServiceWorkerRegistration>;\n    getRegistration(clientURL?: string): Promise<ServiceWorkerRegistration | undefined>;\n    getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>;\n    register(scriptURL: string, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;\n    startMessages(): void;\n    addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerContainerEventMap>(type: K, listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorkerContainer: {\n    prototype: ServiceWorkerContainer;\n    new(): ServiceWorkerContainer;\n};\n\ninterface ServiceWorkerGlobalScopeEventMap extends WorkerGlobalScopeEventMap {\n    "activate": ExtendableEvent;\n    "fetch": FetchEvent;\n    "install": ExtendableEvent;\n    "message": ExtendableMessageEvent;\n    "messageerror": MessageEvent;\n    "notificationclick": NotificationEvent;\n    "notificationclose": NotificationEvent;\n    "push": PushEvent;\n    "pushsubscriptionchange": PushSubscriptionChangeEvent;\n    "sync": SyncEvent;\n}\n\ninterface ServiceWorkerGlobalScope extends WorkerGlobalScope {\n    readonly clients: Clients;\n    onactivate: ((this: ServiceWorkerGlobalScope, ev: ExtendableEvent) => any) | null;\n    onfetch: ((this: ServiceWorkerGlobalScope, ev: FetchEvent) => any) | null;\n    oninstall: ((this: ServiceWorkerGlobalScope, ev: ExtendableEvent) => any) | null;\n    onmessage: ((this: ServiceWorkerGlobalScope, ev: ExtendableMessageEvent) => any) | null;\n    onmessageerror: ((this: ServiceWorkerGlobalScope, ev: MessageEvent) => any) | null;\n    onnotificationclick: ((this: ServiceWorkerGlobalScope, ev: NotificationEvent) => any) | null;\n    onnotificationclose: ((this: ServiceWorkerGlobalScope, ev: NotificationEvent) => any) | null;\n    onpush: ((this: ServiceWorkerGlobalScope, ev: PushEvent) => any) | null;\n    onpushsubscriptionchange: ((this: ServiceWorkerGlobalScope, ev: PushSubscriptionChangeEvent) => any) | null;\n    onsync: ((this: ServiceWorkerGlobalScope, ev: SyncEvent) => any) | null;\n    readonly registration: ServiceWorkerRegistration;\n    skipWaiting(): Promise<void>;\n    addEventListener<K extends keyof ServiceWorkerGlobalScopeEventMap>(type: K, listener: (this: ServiceWorkerGlobalScope, ev: ServiceWorkerGlobalScopeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerGlobalScopeEventMap>(type: K, listener: (this: ServiceWorkerGlobalScope, ev: ServiceWorkerGlobalScopeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorkerGlobalScope: {\n    prototype: ServiceWorkerGlobalScope;\n    new(): ServiceWorkerGlobalScope;\n};\n\ninterface ServiceWorkerRegistrationEventMap {\n    "updatefound": Event;\n}\n\ninterface ServiceWorkerRegistration extends EventTarget {\n    readonly active: ServiceWorker | null;\n    readonly installing: ServiceWorker | null;\n    readonly navigationPreload: NavigationPreloadManager;\n    onupdatefound: ((this: ServiceWorkerRegistration, ev: Event) => any) | null;\n    readonly pushManager: PushManager;\n    readonly scope: string;\n    readonly sync: SyncManager;\n    readonly updateViaCache: ServiceWorkerUpdateViaCache;\n    readonly waiting: ServiceWorker | null;\n    getNotifications(filter?: GetNotificationOptions): Promise<Notification[]>;\n    showNotification(title: string, options?: NotificationOptions): Promise<void>;\n    unregister(): Promise<boolean>;\n    update(): Promise<void>;\n    addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type: K, listener: (this: ServiceWorkerRegistration, ev: ServiceWorkerRegistrationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var ServiceWorkerRegistration: {\n    prototype: ServiceWorkerRegistration;\n    new(): ServiceWorkerRegistration;\n};\n\ninterface StorageManager {\n    estimate(): Promise<StorageEstimate>;\n    persisted(): Promise<boolean>;\n}\n\ndeclare var StorageManager: {\n    prototype: StorageManager;\n    new(): StorageManager;\n};\n\ninterface SubtleCrypto {\n    decrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    deriveBits(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, length: number): PromiseLike<ArrayBuffer>;\n    deriveKey(algorithm: string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: string | AesDerivedKeyParams | HmacImportParams | ConcatParams | HkdfCtrParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    digest(algorithm: string | Algorithm, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    encrypt(algorithm: string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    exportKey(format: "jwk", key: CryptoKey): PromiseLike<JsonWebKey>;\n    exportKey(format: "raw" | "pkcs8" | "spki", key: CryptoKey): PromiseLike<ArrayBuffer>;\n    exportKey(format: string, key: CryptoKey): PromiseLike<JsonWebKey | ArrayBuffer>;\n    generateKey(algorithm: string, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair | CryptoKey>;\n    generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams | DhKeyGenParams, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKeyPair>;\n    generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: "jwk", keyData: JsonWebKey, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: "raw" | "pkcs8" | "spki", keyData: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    importKey(format: string, keyData: JsonWebKey | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, algorithm: string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    sign(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<ArrayBuffer>;\n    unwrapKey(format: string, wrappedKey: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, unwrappingKey: CryptoKey, unwrapAlgorithm: string | Algorithm, unwrappedKeyAlgorithm: string | Algorithm, extractable: boolean, keyUsages: string[]): PromiseLike<CryptoKey>;\n    verify(algorithm: string | RsaPssParams | EcdsaParams | AesCmacParams, key: CryptoKey, signature: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer, data: Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer): PromiseLike<boolean>;\n    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: string | Algorithm): PromiseLike<ArrayBuffer>;\n}\n\ndeclare var SubtleCrypto: {\n    prototype: SubtleCrypto;\n    new(): SubtleCrypto;\n};\n\ninterface SyncEvent extends ExtendableEvent {\n    readonly lastChance: boolean;\n    readonly tag: string;\n}\n\ndeclare var SyncEvent: {\n    prototype: SyncEvent;\n    new(type: string, init: SyncEventInit): SyncEvent;\n};\n\ninterface SyncManager {\n    getTags(): Promise<string[]>;\n    register(tag: string): Promise<void>;\n}\n\ndeclare var SyncManager: {\n    prototype: SyncManager;\n    new(): SyncManager;\n};\n\ninterface TextDecoder {\n    /**\n     * Returns encoding\'s name, lowercased.\n     */\n    readonly encoding: string;\n    /**\n     * Returns true if error mode is "fatal", and false\n     * otherwise.\n     */\n    readonly fatal: boolean;\n    /**\n     * Returns true if ignore BOM flag is set, and false otherwise.\n     */\n    readonly ignoreBOM: boolean;\n    /**\n     * Returns the result of running encoding\'s decoder. The\n     * method can be invoked zero or more times with options\'s stream set to\n     * true, and then once without options\'s stream (or set to false), to process\n     * a fragmented stream. If the invocation without options\'s stream (or set to\n     * false) has no input, it\'s clearest to omit both arguments.\n     * var string = "", decoder = new TextDecoder(encoding), buffer;\n     * while(buffer = next_chunk()) {\n     * string += decoder.decode(buffer, {stream:true});\n     * }\n     * string += decoder.decode(); // end-of-stream\n     * If the error mode is "fatal" and encoding\'s decoder returns error, throws a TypeError.\n     */\n    decode(input?: BufferSource, options?: TextDecodeOptions): string;\n}\n\ndeclare var TextDecoder: {\n    prototype: TextDecoder;\n    new(label?: string, options?: TextDecoderOptions): TextDecoder;\n};\n\ninterface TextEncoder {\n    /**\n     * Returns "utf-8".\n     */\n    readonly encoding: string;\n    /**\n     * Returns the result of running UTF-8\'s encoder.\n     */\n    encode(input?: string): Uint8Array;\n}\n\ndeclare var TextEncoder: {\n    prototype: TextEncoder;\n    new(): TextEncoder;\n};\n\ninterface TextMetrics {\n    readonly actualBoundingBoxAscent: number;\n    readonly actualBoundingBoxDescent: number;\n    readonly actualBoundingBoxLeft: number;\n    readonly actualBoundingBoxRight: number;\n    readonly alphabeticBaseline: number;\n    readonly emHeightAscent: number;\n    readonly emHeightDescent: number;\n    readonly fontBoundingBoxAscent: number;\n    readonly fontBoundingBoxDescent: number;\n    readonly hangingBaseline: number;\n    /**\n     * Returns the measurement described below.\n     */\n    readonly ideographicBaseline: number;\n    readonly width: number;\n}\n\ndeclare var TextMetrics: {\n    prototype: TextMetrics;\n    new(): TextMetrics;\n};\n\ninterface TransformStream<I = any, O = any> {\n    readonly readable: ReadableStream<O>;\n    readonly writable: WritableStream<I>;\n}\n\ndeclare var TransformStream: {\n    prototype: TransformStream;\n    new<I = any, O = any>(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>): TransformStream<I, O>;\n};\n\ninterface TransformStreamDefaultController<O = any> {\n    readonly desiredSize: number | null;\n    enqueue(chunk: O): void;\n    error(reason?: any): void;\n    terminate(): void;\n}\n\ninterface URL {\n    hash: string;\n    host: string;\n    hostname: string;\n    href: string;\n    readonly origin: string;\n    password: string;\n    pathname: string;\n    port: string;\n    protocol: string;\n    search: string;\n    readonly searchParams: URLSearchParams;\n    username: string;\n    toJSON(): string;\n}\n\ndeclare var URL: {\n    prototype: URL;\n    new(url: string, base?: string | URL): URL;\n    createObjectURL(object: any): string;\n    revokeObjectURL(url: string): void;\n};\n\ninterface URLSearchParams {\n    /**\n     * Appends a specified key/value pair as a new search parameter.\n     */\n    append(name: string, value: string): void;\n    /**\n     * Deletes the given search parameter, and its associated value, from the list of all search parameters.\n     */\n    delete(name: string): void;\n    /**\n     * Returns the first value associated to the given search parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Returns all the values association with a given search parameter.\n     */\n    getAll(name: string): string[];\n    /**\n     * Returns a Boolean indicating if such a search parameter exists.\n     */\n    has(name: string): boolean;\n    /**\n     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.\n     */\n    set(name: string, value: string): void;\n    sort(): void;\n    forEach(callbackfn: (value: string, key: string, parent: URLSearchParams) => void, thisArg?: any): void;\n}\n\ndeclare var URLSearchParams: {\n    prototype: URLSearchParams;\n    new(init?: string[][] | Record<string, string> | string | URLSearchParams): URLSearchParams;\n};\n\ninterface WEBGL_color_buffer_float {\n    readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: GLenum;\n    readonly RGBA32F_EXT: GLenum;\n    readonly UNSIGNED_NORMALIZED_EXT: GLenum;\n}\n\ninterface WEBGL_compressed_texture_astc {\n    getSupportedProfiles(): string[];\n    readonly COMPRESSED_RGBA_ASTC_10x10_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_10x8_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_12x10_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_12x12_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_4x4_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_5x4_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_5x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_6x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_6x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x5_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x6_KHR: GLenum;\n    readonly COMPRESSED_RGBA_ASTC_8x8_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: GLenum;\n    readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: GLenum;\n}\n\ninterface WEBGL_compressed_texture_s3tc {\n    readonly COMPRESSED_RGBA_S3TC_DXT1_EXT: GLenum;\n    readonly COMPRESSED_RGBA_S3TC_DXT3_EXT: GLenum;\n    readonly COMPRESSED_RGBA_S3TC_DXT5_EXT: GLenum;\n    readonly COMPRESSED_RGB_S3TC_DXT1_EXT: GLenum;\n}\n\ninterface WEBGL_compressed_texture_s3tc_srgb {\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: GLenum;\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: GLenum;\n    readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: GLenum;\n    readonly COMPRESSED_SRGB_S3TC_DXT1_EXT: GLenum;\n}\n\ninterface WEBGL_debug_renderer_info {\n    readonly UNMASKED_RENDERER_WEBGL: GLenum;\n    readonly UNMASKED_VENDOR_WEBGL: GLenum;\n}\n\ninterface WEBGL_debug_shaders {\n    getTranslatedShaderSource(shader: WebGLShader): string;\n}\n\ninterface WEBGL_depth_texture {\n    readonly UNSIGNED_INT_24_8_WEBGL: GLenum;\n}\n\ninterface WEBGL_draw_buffers {\n    drawBuffersWEBGL(buffers: GLenum[]): void;\n    readonly COLOR_ATTACHMENT0_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT10_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT11_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT12_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT13_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT14_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT15_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT1_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT2_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT3_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT4_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT5_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT6_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT7_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT8_WEBGL: GLenum;\n    readonly COLOR_ATTACHMENT9_WEBGL: GLenum;\n    readonly DRAW_BUFFER0_WEBGL: GLenum;\n    readonly DRAW_BUFFER10_WEBGL: GLenum;\n    readonly DRAW_BUFFER11_WEBGL: GLenum;\n    readonly DRAW_BUFFER12_WEBGL: GLenum;\n    readonly DRAW_BUFFER13_WEBGL: GLenum;\n    readonly DRAW_BUFFER14_WEBGL: GLenum;\n    readonly DRAW_BUFFER15_WEBGL: GLenum;\n    readonly DRAW_BUFFER1_WEBGL: GLenum;\n    readonly DRAW_BUFFER2_WEBGL: GLenum;\n    readonly DRAW_BUFFER3_WEBGL: GLenum;\n    readonly DRAW_BUFFER4_WEBGL: GLenum;\n    readonly DRAW_BUFFER5_WEBGL: GLenum;\n    readonly DRAW_BUFFER6_WEBGL: GLenum;\n    readonly DRAW_BUFFER7_WEBGL: GLenum;\n    readonly DRAW_BUFFER8_WEBGL: GLenum;\n    readonly DRAW_BUFFER9_WEBGL: GLenum;\n    readonly MAX_COLOR_ATTACHMENTS_WEBGL: GLenum;\n    readonly MAX_DRAW_BUFFERS_WEBGL: GLenum;\n}\n\ninterface WEBGL_lose_context {\n    loseContext(): void;\n    restoreContext(): void;\n}\n\ninterface WebGLActiveInfo {\n    readonly name: string;\n    readonly size: GLint;\n    readonly type: GLenum;\n}\n\ndeclare var WebGLActiveInfo: {\n    prototype: WebGLActiveInfo;\n    new(): WebGLActiveInfo;\n};\n\ninterface WebGLBuffer extends WebGLObject {\n}\n\ndeclare var WebGLBuffer: {\n    prototype: WebGLBuffer;\n    new(): WebGLBuffer;\n};\n\ninterface WebGLContextEvent extends Event {\n    readonly statusMessage: string;\n}\n\ndeclare var WebGLContextEvent: {\n    prototype: WebGLContextEvent;\n    new(type: string, eventInit?: WebGLContextEventInit): WebGLContextEvent;\n};\n\ninterface WebGLFramebuffer extends WebGLObject {\n}\n\ndeclare var WebGLFramebuffer: {\n    prototype: WebGLFramebuffer;\n    new(): WebGLFramebuffer;\n};\n\ninterface WebGLObject {\n}\n\ndeclare var WebGLObject: {\n    prototype: WebGLObject;\n    new(): WebGLObject;\n};\n\ninterface WebGLProgram extends WebGLObject {\n}\n\ndeclare var WebGLProgram: {\n    prototype: WebGLProgram;\n    new(): WebGLProgram;\n};\n\ninterface WebGLRenderbuffer extends WebGLObject {\n}\n\ndeclare var WebGLRenderbuffer: {\n    prototype: WebGLRenderbuffer;\n    new(): WebGLRenderbuffer;\n};\n\ninterface WebGLRenderingContext extends WebGLRenderingContextBase {\n}\n\ndeclare var WebGLRenderingContext: {\n    prototype: WebGLRenderingContext;\n    new(): WebGLRenderingContext;\n    readonly ACTIVE_ATTRIBUTES: GLenum;\n    readonly ACTIVE_TEXTURE: GLenum;\n    readonly ACTIVE_UNIFORMS: GLenum;\n    readonly ALIASED_LINE_WIDTH_RANGE: GLenum;\n    readonly ALIASED_POINT_SIZE_RANGE: GLenum;\n    readonly ALPHA: GLenum;\n    readonly ALPHA_BITS: GLenum;\n    readonly ALWAYS: GLenum;\n    readonly ARRAY_BUFFER: GLenum;\n    readonly ARRAY_BUFFER_BINDING: GLenum;\n    readonly ATTACHED_SHADERS: GLenum;\n    readonly BACK: GLenum;\n    readonly BLEND: GLenum;\n    readonly BLEND_COLOR: GLenum;\n    readonly BLEND_DST_ALPHA: GLenum;\n    readonly BLEND_DST_RGB: GLenum;\n    readonly BLEND_EQUATION: GLenum;\n    readonly BLEND_EQUATION_ALPHA: GLenum;\n    readonly BLEND_EQUATION_RGB: GLenum;\n    readonly BLEND_SRC_ALPHA: GLenum;\n    readonly BLEND_SRC_RGB: GLenum;\n    readonly BLUE_BITS: GLenum;\n    readonly BOOL: GLenum;\n    readonly BOOL_VEC2: GLenum;\n    readonly BOOL_VEC3: GLenum;\n    readonly BOOL_VEC4: GLenum;\n    readonly BROWSER_DEFAULT_WEBGL: GLenum;\n    readonly BUFFER_SIZE: GLenum;\n    readonly BUFFER_USAGE: GLenum;\n    readonly BYTE: GLenum;\n    readonly CCW: GLenum;\n    readonly CLAMP_TO_EDGE: GLenum;\n    readonly COLOR_ATTACHMENT0: GLenum;\n    readonly COLOR_BUFFER_BIT: GLenum;\n    readonly COLOR_CLEAR_VALUE: GLenum;\n    readonly COLOR_WRITEMASK: GLenum;\n    readonly COMPILE_STATUS: GLenum;\n    readonly COMPRESSED_TEXTURE_FORMATS: GLenum;\n    readonly CONSTANT_ALPHA: GLenum;\n    readonly CONSTANT_COLOR: GLenum;\n    readonly CONTEXT_LOST_WEBGL: GLenum;\n    readonly CULL_FACE: GLenum;\n    readonly CULL_FACE_MODE: GLenum;\n    readonly CURRENT_PROGRAM: GLenum;\n    readonly CURRENT_VERTEX_ATTRIB: GLenum;\n    readonly CW: GLenum;\n    readonly DECR: GLenum;\n    readonly DECR_WRAP: GLenum;\n    readonly DELETE_STATUS: GLenum;\n    readonly DEPTH_ATTACHMENT: GLenum;\n    readonly DEPTH_BITS: GLenum;\n    readonly DEPTH_BUFFER_BIT: GLenum;\n    readonly DEPTH_CLEAR_VALUE: GLenum;\n    readonly DEPTH_COMPONENT: GLenum;\n    readonly DEPTH_COMPONENT16: GLenum;\n    readonly DEPTH_FUNC: GLenum;\n    readonly DEPTH_RANGE: GLenum;\n    readonly DEPTH_STENCIL: GLenum;\n    readonly DEPTH_STENCIL_ATTACHMENT: GLenum;\n    readonly DEPTH_TEST: GLenum;\n    readonly DEPTH_WRITEMASK: GLenum;\n    readonly DITHER: GLenum;\n    readonly DONT_CARE: GLenum;\n    readonly DST_ALPHA: GLenum;\n    readonly DST_COLOR: GLenum;\n    readonly DYNAMIC_DRAW: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: GLenum;\n    readonly EQUAL: GLenum;\n    readonly FASTEST: GLenum;\n    readonly FLOAT: GLenum;\n    readonly FLOAT_MAT2: GLenum;\n    readonly FLOAT_MAT3: GLenum;\n    readonly FLOAT_MAT4: GLenum;\n    readonly FLOAT_VEC2: GLenum;\n    readonly FLOAT_VEC3: GLenum;\n    readonly FLOAT_VEC4: GLenum;\n    readonly FRAGMENT_SHADER: GLenum;\n    readonly FRAMEBUFFER: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum;\n    readonly FRAMEBUFFER_BINDING: GLenum;\n    readonly FRAMEBUFFER_COMPLETE: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_UNSUPPORTED: GLenum;\n    readonly FRONT: GLenum;\n    readonly FRONT_AND_BACK: GLenum;\n    readonly FRONT_FACE: GLenum;\n    readonly FUNC_ADD: GLenum;\n    readonly FUNC_REVERSE_SUBTRACT: GLenum;\n    readonly FUNC_SUBTRACT: GLenum;\n    readonly GENERATE_MIPMAP_HINT: GLenum;\n    readonly GEQUAL: GLenum;\n    readonly GREATER: GLenum;\n    readonly GREEN_BITS: GLenum;\n    readonly HIGH_FLOAT: GLenum;\n    readonly HIGH_INT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: GLenum;\n    readonly INCR: GLenum;\n    readonly INCR_WRAP: GLenum;\n    readonly INT: GLenum;\n    readonly INT_VEC2: GLenum;\n    readonly INT_VEC3: GLenum;\n    readonly INT_VEC4: GLenum;\n    readonly INVALID_ENUM: GLenum;\n    readonly INVALID_FRAMEBUFFER_OPERATION: GLenum;\n    readonly INVALID_OPERATION: GLenum;\n    readonly INVALID_VALUE: GLenum;\n    readonly INVERT: GLenum;\n    readonly KEEP: GLenum;\n    readonly LEQUAL: GLenum;\n    readonly LESS: GLenum;\n    readonly LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_NEAREST: GLenum;\n    readonly LINES: GLenum;\n    readonly LINE_LOOP: GLenum;\n    readonly LINE_STRIP: GLenum;\n    readonly LINE_WIDTH: GLenum;\n    readonly LINK_STATUS: GLenum;\n    readonly LOW_FLOAT: GLenum;\n    readonly LOW_INT: GLenum;\n    readonly LUMINANCE: GLenum;\n    readonly LUMINANCE_ALPHA: GLenum;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: GLenum;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: GLenum;\n    readonly MAX_RENDERBUFFER_SIZE: GLenum;\n    readonly MAX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_TEXTURE_SIZE: GLenum;\n    readonly MAX_VARYING_VECTORS: GLenum;\n    readonly MAX_VERTEX_ATTRIBS: GLenum;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: GLenum;\n    readonly MAX_VIEWPORT_DIMS: GLenum;\n    readonly MEDIUM_FLOAT: GLenum;\n    readonly MEDIUM_INT: GLenum;\n    readonly MIRRORED_REPEAT: GLenum;\n    readonly NEAREST: GLenum;\n    readonly NEAREST_MIPMAP_LINEAR: GLenum;\n    readonly NEAREST_MIPMAP_NEAREST: GLenum;\n    readonly NEVER: GLenum;\n    readonly NICEST: GLenum;\n    readonly NONE: GLenum;\n    readonly NOTEQUAL: GLenum;\n    readonly NO_ERROR: GLenum;\n    readonly ONE: GLenum;\n    readonly ONE_MINUS_CONSTANT_ALPHA: GLenum;\n    readonly ONE_MINUS_CONSTANT_COLOR: GLenum;\n    readonly ONE_MINUS_DST_ALPHA: GLenum;\n    readonly ONE_MINUS_DST_COLOR: GLenum;\n    readonly ONE_MINUS_SRC_ALPHA: GLenum;\n    readonly ONE_MINUS_SRC_COLOR: GLenum;\n    readonly OUT_OF_MEMORY: GLenum;\n    readonly PACK_ALIGNMENT: GLenum;\n    readonly POINTS: GLenum;\n    readonly POLYGON_OFFSET_FACTOR: GLenum;\n    readonly POLYGON_OFFSET_FILL: GLenum;\n    readonly POLYGON_OFFSET_UNITS: GLenum;\n    readonly RED_BITS: GLenum;\n    readonly RENDERBUFFER: GLenum;\n    readonly RENDERBUFFER_ALPHA_SIZE: GLenum;\n    readonly RENDERBUFFER_BINDING: GLenum;\n    readonly RENDERBUFFER_BLUE_SIZE: GLenum;\n    readonly RENDERBUFFER_DEPTH_SIZE: GLenum;\n    readonly RENDERBUFFER_GREEN_SIZE: GLenum;\n    readonly RENDERBUFFER_HEIGHT: GLenum;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: GLenum;\n    readonly RENDERBUFFER_RED_SIZE: GLenum;\n    readonly RENDERBUFFER_STENCIL_SIZE: GLenum;\n    readonly RENDERBUFFER_WIDTH: GLenum;\n    readonly RENDERER: GLenum;\n    readonly REPEAT: GLenum;\n    readonly REPLACE: GLenum;\n    readonly RGB: GLenum;\n    readonly RGB565: GLenum;\n    readonly RGB5_A1: GLenum;\n    readonly RGBA: GLenum;\n    readonly RGBA4: GLenum;\n    readonly SAMPLER_2D: GLenum;\n    readonly SAMPLER_CUBE: GLenum;\n    readonly SAMPLES: GLenum;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: GLenum;\n    readonly SAMPLE_BUFFERS: GLenum;\n    readonly SAMPLE_COVERAGE: GLenum;\n    readonly SAMPLE_COVERAGE_INVERT: GLenum;\n    readonly SAMPLE_COVERAGE_VALUE: GLenum;\n    readonly SCISSOR_BOX: GLenum;\n    readonly SCISSOR_TEST: GLenum;\n    readonly SHADER_TYPE: GLenum;\n    readonly SHADING_LANGUAGE_VERSION: GLenum;\n    readonly SHORT: GLenum;\n    readonly SRC_ALPHA: GLenum;\n    readonly SRC_ALPHA_SATURATE: GLenum;\n    readonly SRC_COLOR: GLenum;\n    readonly STATIC_DRAW: GLenum;\n    readonly STENCIL_ATTACHMENT: GLenum;\n    readonly STENCIL_BACK_FAIL: GLenum;\n    readonly STENCIL_BACK_FUNC: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_BACK_REF: GLenum;\n    readonly STENCIL_BACK_VALUE_MASK: GLenum;\n    readonly STENCIL_BACK_WRITEMASK: GLenum;\n    readonly STENCIL_BITS: GLenum;\n    readonly STENCIL_BUFFER_BIT: GLenum;\n    readonly STENCIL_CLEAR_VALUE: GLenum;\n    readonly STENCIL_FAIL: GLenum;\n    readonly STENCIL_FUNC: GLenum;\n    readonly STENCIL_INDEX8: GLenum;\n    readonly STENCIL_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_REF: GLenum;\n    readonly STENCIL_TEST: GLenum;\n    readonly STENCIL_VALUE_MASK: GLenum;\n    readonly STENCIL_WRITEMASK: GLenum;\n    readonly STREAM_DRAW: GLenum;\n    readonly SUBPIXEL_BITS: GLenum;\n    readonly TEXTURE: GLenum;\n    readonly TEXTURE0: GLenum;\n    readonly TEXTURE1: GLenum;\n    readonly TEXTURE10: GLenum;\n    readonly TEXTURE11: GLenum;\n    readonly TEXTURE12: GLenum;\n    readonly TEXTURE13: GLenum;\n    readonly TEXTURE14: GLenum;\n    readonly TEXTURE15: GLenum;\n    readonly TEXTURE16: GLenum;\n    readonly TEXTURE17: GLenum;\n    readonly TEXTURE18: GLenum;\n    readonly TEXTURE19: GLenum;\n    readonly TEXTURE2: GLenum;\n    readonly TEXTURE20: GLenum;\n    readonly TEXTURE21: GLenum;\n    readonly TEXTURE22: GLenum;\n    readonly TEXTURE23: GLenum;\n    readonly TEXTURE24: GLenum;\n    readonly TEXTURE25: GLenum;\n    readonly TEXTURE26: GLenum;\n    readonly TEXTURE27: GLenum;\n    readonly TEXTURE28: GLenum;\n    readonly TEXTURE29: GLenum;\n    readonly TEXTURE3: GLenum;\n    readonly TEXTURE30: GLenum;\n    readonly TEXTURE31: GLenum;\n    readonly TEXTURE4: GLenum;\n    readonly TEXTURE5: GLenum;\n    readonly TEXTURE6: GLenum;\n    readonly TEXTURE7: GLenum;\n    readonly TEXTURE8: GLenum;\n    readonly TEXTURE9: GLenum;\n    readonly TEXTURE_2D: GLenum;\n    readonly TEXTURE_BINDING_2D: GLenum;\n    readonly TEXTURE_BINDING_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum;\n    readonly TEXTURE_MAG_FILTER: GLenum;\n    readonly TEXTURE_MIN_FILTER: GLenum;\n    readonly TEXTURE_WRAP_S: GLenum;\n    readonly TEXTURE_WRAP_T: GLenum;\n    readonly TRIANGLES: GLenum;\n    readonly TRIANGLE_FAN: GLenum;\n    readonly TRIANGLE_STRIP: GLenum;\n    readonly UNPACK_ALIGNMENT: GLenum;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum;\n    readonly UNPACK_FLIP_Y_WEBGL: GLenum;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum;\n    readonly UNSIGNED_BYTE: GLenum;\n    readonly UNSIGNED_INT: GLenum;\n    readonly UNSIGNED_SHORT: GLenum;\n    readonly UNSIGNED_SHORT_4_4_4_4: GLenum;\n    readonly UNSIGNED_SHORT_5_5_5_1: GLenum;\n    readonly UNSIGNED_SHORT_5_6_5: GLenum;\n    readonly VALIDATE_STATUS: GLenum;\n    readonly VENDOR: GLenum;\n    readonly VERSION: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: GLenum;\n    readonly VERTEX_SHADER: GLenum;\n    readonly VIEWPORT: GLenum;\n    readonly ZERO: GLenum;\n};\n\ninterface WebGLRenderingContextBase {\n    readonly drawingBufferHeight: GLsizei;\n    readonly drawingBufferWidth: GLsizei;\n    activeTexture(texture: GLenum): void;\n    attachShader(program: WebGLProgram, shader: WebGLShader): void;\n    bindAttribLocation(program: WebGLProgram, index: GLuint, name: string): void;\n    bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void;\n    bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer | null): void;\n    bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer | null): void;\n    bindTexture(target: GLenum, texture: WebGLTexture | null): void;\n    blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\n    blendEquation(mode: GLenum): void;\n    blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void;\n    blendFunc(sfactor: GLenum, dfactor: GLenum): void;\n    blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;\n    bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum): void;\n    bufferData(target: GLenum, data: BufferSource | null, usage: GLenum): void;\n    bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource): void;\n    checkFramebufferStatus(target: GLenum): GLenum;\n    clear(mask: GLbitfield): void;\n    clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\n    clearDepth(depth: GLclampf): void;\n    clearStencil(s: GLint): void;\n    colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;\n    compileShader(shader: WebGLShader): void;\n    compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;\n    compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;\n    copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;\n    copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    createBuffer(): WebGLBuffer | null;\n    createFramebuffer(): WebGLFramebuffer | null;\n    createProgram(): WebGLProgram | null;\n    createRenderbuffer(): WebGLRenderbuffer | null;\n    createShader(type: GLenum): WebGLShader | null;\n    createTexture(): WebGLTexture | null;\n    cullFace(mode: GLenum): void;\n    deleteBuffer(buffer: WebGLBuffer | null): void;\n    deleteFramebuffer(framebuffer: WebGLFramebuffer | null): void;\n    deleteProgram(program: WebGLProgram | null): void;\n    deleteRenderbuffer(renderbuffer: WebGLRenderbuffer | null): void;\n    deleteShader(shader: WebGLShader | null): void;\n    deleteTexture(texture: WebGLTexture | null): void;\n    depthFunc(func: GLenum): void;\n    depthMask(flag: GLboolean): void;\n    depthRange(zNear: GLclampf, zFar: GLclampf): void;\n    detachShader(program: WebGLProgram, shader: WebGLShader): void;\n    disable(cap: GLenum): void;\n    disableVertexAttribArray(index: GLuint): void;\n    drawArrays(mode: GLenum, first: GLint, count: GLsizei): void;\n    drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr): void;\n    enable(cap: GLenum): void;\n    enableVertexAttribArray(index: GLuint): void;\n    finish(): void;\n    flush(): void;\n    framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer | null): void;\n    framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture | null, level: GLint): void;\n    frontFace(mode: GLenum): void;\n    generateMipmap(target: GLenum): void;\n    getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;\n    getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo | null;\n    getAttachedShaders(program: WebGLProgram): WebGLShader[] | null;\n    getAttribLocation(program: WebGLProgram, name: string): GLint;\n    getBufferParameter(target: GLenum, pname: GLenum): any;\n    getContextAttributes(): WebGLContextAttributes | null;\n    getError(): GLenum;\n    getExtension(extensionName: "EXT_blend_minmax"): EXT_blend_minmax | null;\n    getExtension(extensionName: "EXT_texture_filter_anisotropic"): EXT_texture_filter_anisotropic | null;\n    getExtension(extensionName: "EXT_frag_depth"): EXT_frag_depth | null;\n    getExtension(extensionName: "EXT_shader_texture_lod"): EXT_shader_texture_lod | null;\n    getExtension(extensionName: "EXT_sRGB"): EXT_sRGB | null;\n    getExtension(extensionName: "OES_vertex_array_object"): OES_vertex_array_object | null;\n    getExtension(extensionName: "WEBGL_color_buffer_float"): WEBGL_color_buffer_float | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_astc"): WEBGL_compressed_texture_astc | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_s3tc_srgb"): WEBGL_compressed_texture_s3tc_srgb | null;\n    getExtension(extensionName: "WEBGL_debug_shaders"): WEBGL_debug_shaders | null;\n    getExtension(extensionName: "WEBGL_draw_buffers"): WEBGL_draw_buffers | null;\n    getExtension(extensionName: "WEBGL_lose_context"): WEBGL_lose_context | null;\n    getExtension(extensionName: "WEBGL_depth_texture"): WEBGL_depth_texture | null;\n    getExtension(extensionName: "WEBGL_debug_renderer_info"): WEBGL_debug_renderer_info | null;\n    getExtension(extensionName: "WEBGL_compressed_texture_s3tc"): WEBGL_compressed_texture_s3tc | null;\n    getExtension(extensionName: "OES_texture_half_float_linear"): OES_texture_half_float_linear | null;\n    getExtension(extensionName: "OES_texture_half_float"): OES_texture_half_float | null;\n    getExtension(extensionName: "OES_texture_float_linear"): OES_texture_float_linear | null;\n    getExtension(extensionName: "OES_texture_float"): OES_texture_float | null;\n    getExtension(extensionName: "OES_standard_derivatives"): OES_standard_derivatives | null;\n    getExtension(extensionName: "OES_element_index_uint"): OES_element_index_uint | null;\n    getExtension(extensionName: "ANGLE_instanced_arrays"): ANGLE_instanced_arrays | null;\n    getExtension(extensionName: string): any;\n    getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): any;\n    getParameter(pname: GLenum): any;\n    getProgramInfoLog(program: WebGLProgram): string | null;\n    getProgramParameter(program: WebGLProgram, pname: GLenum): any;\n    getRenderbufferParameter(target: GLenum, pname: GLenum): any;\n    getShaderInfoLog(shader: WebGLShader): string | null;\n    getShaderParameter(shader: WebGLShader, pname: GLenum): any;\n    getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat | null;\n    getShaderSource(shader: WebGLShader): string | null;\n    getSupportedExtensions(): string[] | null;\n    getTexParameter(target: GLenum, pname: GLenum): any;\n    getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;\n    getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation | null;\n    getVertexAttrib(index: GLuint, pname: GLenum): any;\n    getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr;\n    hint(target: GLenum, mode: GLenum): void;\n    isBuffer(buffer: WebGLBuffer | null): GLboolean;\n    isContextLost(): boolean;\n    isEnabled(cap: GLenum): GLboolean;\n    isFramebuffer(framebuffer: WebGLFramebuffer | null): GLboolean;\n    isProgram(program: WebGLProgram | null): GLboolean;\n    isRenderbuffer(renderbuffer: WebGLRenderbuffer | null): GLboolean;\n    isShader(shader: WebGLShader | null): GLboolean;\n    isTexture(texture: WebGLTexture | null): GLboolean;\n    lineWidth(width: GLfloat): void;\n    linkProgram(program: WebGLProgram): void;\n    pixelStorei(pname: GLenum, param: GLint): void;\n    polygonOffset(factor: GLfloat, units: GLfloat): void;\n    readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void;\n    sampleCoverage(value: GLclampf, invert: GLboolean): void;\n    scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    shaderSource(shader: WebGLShader, source: string): void;\n    stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;\n    stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;\n    stencilMask(mask: GLuint): void;\n    stencilMaskSeparate(face: GLenum, mask: GLuint): void;\n    stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void;\n    stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\n    texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource): void;\n    texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void;\n    texParameteri(target: GLenum, pname: GLenum, param: GLint): void;\n    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView | null): void;\n    texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource): void;\n    uniform1f(location: WebGLUniformLocation | null, x: GLfloat): void;\n    uniform1fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform1i(location: WebGLUniformLocation | null, x: GLint): void;\n    uniform1iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform2f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat): void;\n    uniform2fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform2i(location: WebGLUniformLocation | null, x: GLint, y: GLint): void;\n    uniform2iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform3f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat): void;\n    uniform3fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform3i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint): void;\n    uniform3iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniform4f(location: WebGLUniformLocation | null, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\n    uniform4fv(location: WebGLUniformLocation | null, v: Float32List): void;\n    uniform4i(location: WebGLUniformLocation | null, x: GLint, y: GLint, z: GLint, w: GLint): void;\n    uniform4iv(location: WebGLUniformLocation | null, v: Int32List): void;\n    uniformMatrix2fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    uniformMatrix3fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    uniformMatrix4fv(location: WebGLUniformLocation | null, transpose: GLboolean, value: Float32List): void;\n    useProgram(program: WebGLProgram | null): void;\n    validateProgram(program: WebGLProgram): void;\n    vertexAttrib1f(index: GLuint, x: GLfloat): void;\n    vertexAttrib1fv(index: GLuint, values: Float32List): void;\n    vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat): void;\n    vertexAttrib2fv(index: GLuint, values: Float32List): void;\n    vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;\n    vertexAttrib3fv(index: GLuint, values: Float32List): void;\n    vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\n    vertexAttrib4fv(index: GLuint, values: Float32List): void;\n    vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void;\n    viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\n    readonly ACTIVE_ATTRIBUTES: GLenum;\n    readonly ACTIVE_TEXTURE: GLenum;\n    readonly ACTIVE_UNIFORMS: GLenum;\n    readonly ALIASED_LINE_WIDTH_RANGE: GLenum;\n    readonly ALIASED_POINT_SIZE_RANGE: GLenum;\n    readonly ALPHA: GLenum;\n    readonly ALPHA_BITS: GLenum;\n    readonly ALWAYS: GLenum;\n    readonly ARRAY_BUFFER: GLenum;\n    readonly ARRAY_BUFFER_BINDING: GLenum;\n    readonly ATTACHED_SHADERS: GLenum;\n    readonly BACK: GLenum;\n    readonly BLEND: GLenum;\n    readonly BLEND_COLOR: GLenum;\n    readonly BLEND_DST_ALPHA: GLenum;\n    readonly BLEND_DST_RGB: GLenum;\n    readonly BLEND_EQUATION: GLenum;\n    readonly BLEND_EQUATION_ALPHA: GLenum;\n    readonly BLEND_EQUATION_RGB: GLenum;\n    readonly BLEND_SRC_ALPHA: GLenum;\n    readonly BLEND_SRC_RGB: GLenum;\n    readonly BLUE_BITS: GLenum;\n    readonly BOOL: GLenum;\n    readonly BOOL_VEC2: GLenum;\n    readonly BOOL_VEC3: GLenum;\n    readonly BOOL_VEC4: GLenum;\n    readonly BROWSER_DEFAULT_WEBGL: GLenum;\n    readonly BUFFER_SIZE: GLenum;\n    readonly BUFFER_USAGE: GLenum;\n    readonly BYTE: GLenum;\n    readonly CCW: GLenum;\n    readonly CLAMP_TO_EDGE: GLenum;\n    readonly COLOR_ATTACHMENT0: GLenum;\n    readonly COLOR_BUFFER_BIT: GLenum;\n    readonly COLOR_CLEAR_VALUE: GLenum;\n    readonly COLOR_WRITEMASK: GLenum;\n    readonly COMPILE_STATUS: GLenum;\n    readonly COMPRESSED_TEXTURE_FORMATS: GLenum;\n    readonly CONSTANT_ALPHA: GLenum;\n    readonly CONSTANT_COLOR: GLenum;\n    readonly CONTEXT_LOST_WEBGL: GLenum;\n    readonly CULL_FACE: GLenum;\n    readonly CULL_FACE_MODE: GLenum;\n    readonly CURRENT_PROGRAM: GLenum;\n    readonly CURRENT_VERTEX_ATTRIB: GLenum;\n    readonly CW: GLenum;\n    readonly DECR: GLenum;\n    readonly DECR_WRAP: GLenum;\n    readonly DELETE_STATUS: GLenum;\n    readonly DEPTH_ATTACHMENT: GLenum;\n    readonly DEPTH_BITS: GLenum;\n    readonly DEPTH_BUFFER_BIT: GLenum;\n    readonly DEPTH_CLEAR_VALUE: GLenum;\n    readonly DEPTH_COMPONENT: GLenum;\n    readonly DEPTH_COMPONENT16: GLenum;\n    readonly DEPTH_FUNC: GLenum;\n    readonly DEPTH_RANGE: GLenum;\n    readonly DEPTH_STENCIL: GLenum;\n    readonly DEPTH_STENCIL_ATTACHMENT: GLenum;\n    readonly DEPTH_TEST: GLenum;\n    readonly DEPTH_WRITEMASK: GLenum;\n    readonly DITHER: GLenum;\n    readonly DONT_CARE: GLenum;\n    readonly DST_ALPHA: GLenum;\n    readonly DST_COLOR: GLenum;\n    readonly DYNAMIC_DRAW: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER: GLenum;\n    readonly ELEMENT_ARRAY_BUFFER_BINDING: GLenum;\n    readonly EQUAL: GLenum;\n    readonly FASTEST: GLenum;\n    readonly FLOAT: GLenum;\n    readonly FLOAT_MAT2: GLenum;\n    readonly FLOAT_MAT3: GLenum;\n    readonly FLOAT_MAT4: GLenum;\n    readonly FLOAT_VEC2: GLenum;\n    readonly FLOAT_VEC3: GLenum;\n    readonly FLOAT_VEC4: GLenum;\n    readonly FRAGMENT_SHADER: GLenum;\n    readonly FRAMEBUFFER: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum;\n    readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum;\n    readonly FRAMEBUFFER_BINDING: GLenum;\n    readonly FRAMEBUFFER_COMPLETE: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum;\n    readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum;\n    readonly FRAMEBUFFER_UNSUPPORTED: GLenum;\n    readonly FRONT: GLenum;\n    readonly FRONT_AND_BACK: GLenum;\n    readonly FRONT_FACE: GLenum;\n    readonly FUNC_ADD: GLenum;\n    readonly FUNC_REVERSE_SUBTRACT: GLenum;\n    readonly FUNC_SUBTRACT: GLenum;\n    readonly GENERATE_MIPMAP_HINT: GLenum;\n    readonly GEQUAL: GLenum;\n    readonly GREATER: GLenum;\n    readonly GREEN_BITS: GLenum;\n    readonly HIGH_FLOAT: GLenum;\n    readonly HIGH_INT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_FORMAT: GLenum;\n    readonly IMPLEMENTATION_COLOR_READ_TYPE: GLenum;\n    readonly INCR: GLenum;\n    readonly INCR_WRAP: GLenum;\n    readonly INT: GLenum;\n    readonly INT_VEC2: GLenum;\n    readonly INT_VEC3: GLenum;\n    readonly INT_VEC4: GLenum;\n    readonly INVALID_ENUM: GLenum;\n    readonly INVALID_FRAMEBUFFER_OPERATION: GLenum;\n    readonly INVALID_OPERATION: GLenum;\n    readonly INVALID_VALUE: GLenum;\n    readonly INVERT: GLenum;\n    readonly KEEP: GLenum;\n    readonly LEQUAL: GLenum;\n    readonly LESS: GLenum;\n    readonly LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_LINEAR: GLenum;\n    readonly LINEAR_MIPMAP_NEAREST: GLenum;\n    readonly LINES: GLenum;\n    readonly LINE_LOOP: GLenum;\n    readonly LINE_STRIP: GLenum;\n    readonly LINE_WIDTH: GLenum;\n    readonly LINK_STATUS: GLenum;\n    readonly LOW_FLOAT: GLenum;\n    readonly LOW_INT: GLenum;\n    readonly LUMINANCE: GLenum;\n    readonly LUMINANCE_ALPHA: GLenum;\n    readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_CUBE_MAP_TEXTURE_SIZE: GLenum;\n    readonly MAX_FRAGMENT_UNIFORM_VECTORS: GLenum;\n    readonly MAX_RENDERBUFFER_SIZE: GLenum;\n    readonly MAX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_TEXTURE_SIZE: GLenum;\n    readonly MAX_VARYING_VECTORS: GLenum;\n    readonly MAX_VERTEX_ATTRIBS: GLenum;\n    readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum;\n    readonly MAX_VERTEX_UNIFORM_VECTORS: GLenum;\n    readonly MAX_VIEWPORT_DIMS: GLenum;\n    readonly MEDIUM_FLOAT: GLenum;\n    readonly MEDIUM_INT: GLenum;\n    readonly MIRRORED_REPEAT: GLenum;\n    readonly NEAREST: GLenum;\n    readonly NEAREST_MIPMAP_LINEAR: GLenum;\n    readonly NEAREST_MIPMAP_NEAREST: GLenum;\n    readonly NEVER: GLenum;\n    readonly NICEST: GLenum;\n    readonly NONE: GLenum;\n    readonly NOTEQUAL: GLenum;\n    readonly NO_ERROR: GLenum;\n    readonly ONE: GLenum;\n    readonly ONE_MINUS_CONSTANT_ALPHA: GLenum;\n    readonly ONE_MINUS_CONSTANT_COLOR: GLenum;\n    readonly ONE_MINUS_DST_ALPHA: GLenum;\n    readonly ONE_MINUS_DST_COLOR: GLenum;\n    readonly ONE_MINUS_SRC_ALPHA: GLenum;\n    readonly ONE_MINUS_SRC_COLOR: GLenum;\n    readonly OUT_OF_MEMORY: GLenum;\n    readonly PACK_ALIGNMENT: GLenum;\n    readonly POINTS: GLenum;\n    readonly POLYGON_OFFSET_FACTOR: GLenum;\n    readonly POLYGON_OFFSET_FILL: GLenum;\n    readonly POLYGON_OFFSET_UNITS: GLenum;\n    readonly RED_BITS: GLenum;\n    readonly RENDERBUFFER: GLenum;\n    readonly RENDERBUFFER_ALPHA_SIZE: GLenum;\n    readonly RENDERBUFFER_BINDING: GLenum;\n    readonly RENDERBUFFER_BLUE_SIZE: GLenum;\n    readonly RENDERBUFFER_DEPTH_SIZE: GLenum;\n    readonly RENDERBUFFER_GREEN_SIZE: GLenum;\n    readonly RENDERBUFFER_HEIGHT: GLenum;\n    readonly RENDERBUFFER_INTERNAL_FORMAT: GLenum;\n    readonly RENDERBUFFER_RED_SIZE: GLenum;\n    readonly RENDERBUFFER_STENCIL_SIZE: GLenum;\n    readonly RENDERBUFFER_WIDTH: GLenum;\n    readonly RENDERER: GLenum;\n    readonly REPEAT: GLenum;\n    readonly REPLACE: GLenum;\n    readonly RGB: GLenum;\n    readonly RGB565: GLenum;\n    readonly RGB5_A1: GLenum;\n    readonly RGBA: GLenum;\n    readonly RGBA4: GLenum;\n    readonly SAMPLER_2D: GLenum;\n    readonly SAMPLER_CUBE: GLenum;\n    readonly SAMPLES: GLenum;\n    readonly SAMPLE_ALPHA_TO_COVERAGE: GLenum;\n    readonly SAMPLE_BUFFERS: GLenum;\n    readonly SAMPLE_COVERAGE: GLenum;\n    readonly SAMPLE_COVERAGE_INVERT: GLenum;\n    readonly SAMPLE_COVERAGE_VALUE: GLenum;\n    readonly SCISSOR_BOX: GLenum;\n    readonly SCISSOR_TEST: GLenum;\n    readonly SHADER_TYPE: GLenum;\n    readonly SHADING_LANGUAGE_VERSION: GLenum;\n    readonly SHORT: GLenum;\n    readonly SRC_ALPHA: GLenum;\n    readonly SRC_ALPHA_SATURATE: GLenum;\n    readonly SRC_COLOR: GLenum;\n    readonly STATIC_DRAW: GLenum;\n    readonly STENCIL_ATTACHMENT: GLenum;\n    readonly STENCIL_BACK_FAIL: GLenum;\n    readonly STENCIL_BACK_FUNC: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_BACK_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_BACK_REF: GLenum;\n    readonly STENCIL_BACK_VALUE_MASK: GLenum;\n    readonly STENCIL_BACK_WRITEMASK: GLenum;\n    readonly STENCIL_BITS: GLenum;\n    readonly STENCIL_BUFFER_BIT: GLenum;\n    readonly STENCIL_CLEAR_VALUE: GLenum;\n    readonly STENCIL_FAIL: GLenum;\n    readonly STENCIL_FUNC: GLenum;\n    readonly STENCIL_INDEX8: GLenum;\n    readonly STENCIL_PASS_DEPTH_FAIL: GLenum;\n    readonly STENCIL_PASS_DEPTH_PASS: GLenum;\n    readonly STENCIL_REF: GLenum;\n    readonly STENCIL_TEST: GLenum;\n    readonly STENCIL_VALUE_MASK: GLenum;\n    readonly STENCIL_WRITEMASK: GLenum;\n    readonly STREAM_DRAW: GLenum;\n    readonly SUBPIXEL_BITS: GLenum;\n    readonly TEXTURE: GLenum;\n    readonly TEXTURE0: GLenum;\n    readonly TEXTURE1: GLenum;\n    readonly TEXTURE10: GLenum;\n    readonly TEXTURE11: GLenum;\n    readonly TEXTURE12: GLenum;\n    readonly TEXTURE13: GLenum;\n    readonly TEXTURE14: GLenum;\n    readonly TEXTURE15: GLenum;\n    readonly TEXTURE16: GLenum;\n    readonly TEXTURE17: GLenum;\n    readonly TEXTURE18: GLenum;\n    readonly TEXTURE19: GLenum;\n    readonly TEXTURE2: GLenum;\n    readonly TEXTURE20: GLenum;\n    readonly TEXTURE21: GLenum;\n    readonly TEXTURE22: GLenum;\n    readonly TEXTURE23: GLenum;\n    readonly TEXTURE24: GLenum;\n    readonly TEXTURE25: GLenum;\n    readonly TEXTURE26: GLenum;\n    readonly TEXTURE27: GLenum;\n    readonly TEXTURE28: GLenum;\n    readonly TEXTURE29: GLenum;\n    readonly TEXTURE3: GLenum;\n    readonly TEXTURE30: GLenum;\n    readonly TEXTURE31: GLenum;\n    readonly TEXTURE4: GLenum;\n    readonly TEXTURE5: GLenum;\n    readonly TEXTURE6: GLenum;\n    readonly TEXTURE7: GLenum;\n    readonly TEXTURE8: GLenum;\n    readonly TEXTURE9: GLenum;\n    readonly TEXTURE_2D: GLenum;\n    readonly TEXTURE_BINDING_2D: GLenum;\n    readonly TEXTURE_BINDING_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_X: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum;\n    readonly TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum;\n    readonly TEXTURE_MAG_FILTER: GLenum;\n    readonly TEXTURE_MIN_FILTER: GLenum;\n    readonly TEXTURE_WRAP_S: GLenum;\n    readonly TEXTURE_WRAP_T: GLenum;\n    readonly TRIANGLES: GLenum;\n    readonly TRIANGLE_FAN: GLenum;\n    readonly TRIANGLE_STRIP: GLenum;\n    readonly UNPACK_ALIGNMENT: GLenum;\n    readonly UNPACK_COLORSPACE_CONVERSION_WEBGL: GLenum;\n    readonly UNPACK_FLIP_Y_WEBGL: GLenum;\n    readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum;\n    readonly UNSIGNED_BYTE: GLenum;\n    readonly UNSIGNED_INT: GLenum;\n    readonly UNSIGNED_SHORT: GLenum;\n    readonly UNSIGNED_SHORT_4_4_4_4: GLenum;\n    readonly UNSIGNED_SHORT_5_5_5_1: GLenum;\n    readonly UNSIGNED_SHORT_5_6_5: GLenum;\n    readonly VALIDATE_STATUS: GLenum;\n    readonly VENDOR: GLenum;\n    readonly VERSION: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_ENABLED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_POINTER: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_SIZE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_STRIDE: GLenum;\n    readonly VERTEX_ATTRIB_ARRAY_TYPE: GLenum;\n    readonly VERTEX_SHADER: GLenum;\n    readonly VIEWPORT: GLenum;\n    readonly ZERO: GLenum;\n}\n\ninterface WebGLShader extends WebGLObject {\n}\n\ndeclare var WebGLShader: {\n    prototype: WebGLShader;\n    new(): WebGLShader;\n};\n\ninterface WebGLShaderPrecisionFormat {\n    readonly precision: GLint;\n    readonly rangeMax: GLint;\n    readonly rangeMin: GLint;\n}\n\ndeclare var WebGLShaderPrecisionFormat: {\n    prototype: WebGLShaderPrecisionFormat;\n    new(): WebGLShaderPrecisionFormat;\n};\n\ninterface WebGLTexture extends WebGLObject {\n}\n\ndeclare var WebGLTexture: {\n    prototype: WebGLTexture;\n    new(): WebGLTexture;\n};\n\ninterface WebGLUniformLocation {\n}\n\ndeclare var WebGLUniformLocation: {\n    prototype: WebGLUniformLocation;\n    new(): WebGLUniformLocation;\n};\n\ninterface WebGLVertexArrayObjectOES extends WebGLObject {\n}\n\ninterface WebSocketEventMap {\n    "close": CloseEvent;\n    "error": Event;\n    "message": MessageEvent;\n    "open": Event;\n}\n\ninterface WebSocket extends EventTarget {\n    binaryType: BinaryType;\n    readonly bufferedAmount: number;\n    readonly extensions: string;\n    onclose: ((this: WebSocket, ev: CloseEvent) => any) | null;\n    onerror: ((this: WebSocket, ev: Event) => any) | null;\n    onmessage: ((this: WebSocket, ev: MessageEvent) => any) | null;\n    onopen: ((this: WebSocket, ev: Event) => any) | null;\n    readonly protocol: string;\n    readonly readyState: number;\n    readonly url: string;\n    close(code?: number, reason?: string): void;\n    send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var WebSocket: {\n    prototype: WebSocket;\n    new(url: string, protocols?: string | string[]): WebSocket;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n};\n\ninterface WindowBase64 {\n    atob(encodedString: string): string;\n    btoa(rawString: string): string;\n}\n\ninterface WindowClient extends Client {\n    readonly ancestorOrigins: ReadonlyArray<string>;\n    readonly focused: boolean;\n    readonly visibilityState: VisibilityState;\n    focus(): Promise<WindowClient>;\n    navigate(url: string): Promise<WindowClient | null>;\n}\n\ndeclare var WindowClient: {\n    prototype: WindowClient;\n    new(): WindowClient;\n};\n\ninterface WindowConsole {\n    readonly console: Console;\n}\n\ninterface WindowOrWorkerGlobalScope {\n    readonly caches: CacheStorage;\n    readonly crypto: Crypto;\n    readonly indexedDB: IDBFactory;\n    readonly origin: string;\n    readonly performance: Performance;\n    atob(data: string): string;\n    btoa(data: string): string;\n    clearInterval(handle?: number): void;\n    clearTimeout(handle?: number): void;\n    createImageBitmap(image: ImageBitmapSource): Promise<ImageBitmap>;\n    createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number): Promise<ImageBitmap>;\n    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\n    queueMicrotask(callback: Function): void;\n    setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\n    setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\n}\n\ninterface WorkerEventMap extends AbstractWorkerEventMap {\n    "message": MessageEvent;\n}\n\ninterface Worker extends EventTarget, AbstractWorker {\n    onmessage: ((this: Worker, ev: MessageEvent) => any) | null;\n    postMessage(message: any, transfer?: Transferable[]): void;\n    terminate(): void;\n    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var Worker: {\n    prototype: Worker;\n    new(stringUrl: string, options?: WorkerOptions): Worker;\n};\n\ninterface WorkerGlobalScopeEventMap {\n    "error": ErrorEvent;\n}\n\ninterface WorkerGlobalScope extends EventTarget, WorkerUtils, WindowConsole, GlobalFetch, WindowOrWorkerGlobalScope {\n    readonly caches: CacheStorage;\n    readonly isSecureContext: boolean;\n    readonly location: WorkerLocation;\n    onerror: ((this: WorkerGlobalScope, ev: ErrorEvent) => any) | null;\n    readonly performance: Performance;\n    readonly self: WorkerGlobalScope;\n    msWriteProfilerMark(profilerMarkName: string): void;\n    addEventListener<K extends keyof WorkerGlobalScopeEventMap>(type: K, listener: (this: WorkerGlobalScope, ev: WorkerGlobalScopeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof WorkerGlobalScopeEventMap>(type: K, listener: (this: WorkerGlobalScope, ev: WorkerGlobalScopeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var WorkerGlobalScope: {\n    prototype: WorkerGlobalScope;\n    new(): WorkerGlobalScope;\n};\n\ninterface WorkerLocation {\n    readonly hash: string;\n    readonly host: string;\n    readonly hostname: string;\n    readonly href: string;\n    readonly origin: string;\n    readonly pathname: string;\n    readonly port: string;\n    readonly protocol: string;\n    readonly search: string;\n    toString(): string;\n}\n\ndeclare var WorkerLocation: {\n    prototype: WorkerLocation;\n    new(): WorkerLocation;\n};\n\ninterface WorkerNavigator extends NavigatorID, NavigatorOnLine, NavigatorBeacon, NavigatorConcurrentHardware, NavigatorStorage {\n    readonly serviceWorker: ServiceWorkerContainer;\n}\n\ndeclare var WorkerNavigator: {\n    prototype: WorkerNavigator;\n    new(): WorkerNavigator;\n};\n\ninterface WorkerUtils extends WindowBase64 {\n    readonly indexedDB: IDBFactory;\n    readonly msIndexedDB: IDBFactory;\n    readonly navigator: WorkerNavigator;\n    importScripts(...urls: string[]): void;\n}\n\ninterface WritableStream<W = any> {\n    readonly locked: boolean;\n    abort(reason?: any): Promise<void>;\n    getWriter(): WritableStreamDefaultWriter<W>;\n}\n\ndeclare var WritableStream: {\n    prototype: WritableStream;\n    new<W = any>(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>): WritableStream<W>;\n};\n\ninterface WritableStreamDefaultController {\n    error(error?: any): void;\n}\n\ninterface WritableStreamDefaultWriter<W = any> {\n    readonly closed: Promise<void>;\n    readonly desiredSize: number | null;\n    readonly ready: Promise<void>;\n    abort(reason?: any): Promise<void>;\n    close(): Promise<void>;\n    releaseLock(): void;\n    write(chunk: W): Promise<void>;\n}\n\ninterface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {\n    "readystatechange": Event;\n}\n\ninterface XMLHttpRequest extends XMLHttpRequestEventTarget {\n    onreadystatechange: ((this: XMLHttpRequest, ev: Event) => any) | null;\n    /**\n     * Returns client\'s state.\n     */\n    readonly readyState: number;\n    /**\n     * Returns the response\'s body.\n     */\n    readonly response: any;\n    /**\n     * Returns the text response.\n     * Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".\n     */\n    readonly responseText: string;\n    /**\n     * Returns the response type.\n     * Can be set to change the response type. Values are:\n     * the empty string (default),\n     * "arraybuffer",\n     * "blob",\n     * "document",\n     * "json", and\n     * "text".\n     * When set: setting to "document" is ignored if current global object is not a Window object.\n     * When set: throws an "InvalidStateError" DOMException if state is loading or done.\n     * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n     */\n    responseType: XMLHttpRequestResponseType;\n    readonly responseURL: string;\n    readonly status: number;\n    readonly statusText: string;\n    /**\n     * Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the\n     * request has not yet completed, and the synchronous flag is unset, a timeout event will then be dispatched, or a\n     * "TimeoutError" DOMException will be thrown otherwise (for the send() method).\n     * When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.\n     */\n    timeout: number;\n    /**\n     * Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is\n     * transferred to a server.\n     */\n    readonly upload: XMLHttpRequestUpload;\n    /**\n     * True when credentials are to be included in a cross-origin request. False when they are\n     * to be excluded in a cross-origin request and when cookies are to be ignored in its response.\n     * Initially false.\n     * When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.\n     */\n    withCredentials: boolean;\n    /**\n     * Cancels any network activity.\n     */\n    abort(): void;\n    getAllResponseHeaders(): string;\n    getResponseHeader(name: string): string | null;\n    /**\n     * Sets the request method, request URL, and synchronous flag.\n     * Throws a "SyntaxError" DOMException if either method is not a\n     * valid HTTP method or url cannot be parsed.\n     * Throws a "SecurityError" DOMException if method is a\n     * case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.\n     * Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.\n     */\n    open(method: string, url: string): void;\n    open(method: string, url: string, async: boolean, username?: string | null, password?: string | null): void;\n    /**\n     * Acts as if the `Content-Type` header value for response is mime.\n     * (It does not actually change the header though.)\n     * Throws an "InvalidStateError" DOMException if state is loading or done.\n     */\n    overrideMimeType(mime: string): void;\n    /**\n     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD.\n     * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n     */\n    send(body?: BodyInit | null): void;\n    /**\n     * Combines a header in author request headers.\n     * Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.\n     * Throws a "SyntaxError" DOMException if name is not a header name\n     * or if value is not a header value.\n     */\n    setRequestHeader(name: string, value: string): void;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequest: {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n};\n\ninterface XMLHttpRequestEventTargetEventMap {\n    "abort": ProgressEvent;\n    "error": ProgressEvent;\n    "load": ProgressEvent;\n    "loadend": ProgressEvent;\n    "loadstart": ProgressEvent;\n    "progress": ProgressEvent;\n    "timeout": ProgressEvent;\n}\n\ninterface XMLHttpRequestEventTarget extends EventTarget {\n    onabort: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onerror: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onload: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    ontimeout: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequestEventTarget: {\n    prototype: XMLHttpRequestEventTarget;\n    new(): XMLHttpRequestEventTarget;\n};\n\ninterface XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ndeclare var XMLHttpRequestUpload: {\n    prototype: XMLHttpRequestUpload;\n    new(): XMLHttpRequestUpload;\n};\n\ndeclare type EventListenerOrEventListenerObject = EventListener | EventListenerObject;\n\ninterface EventHandlerNonNull {\n    (event: Event): any;\n}\n\ninterface PerformanceObserverCallback {\n    (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void;\n}\n\ninterface QueuingStrategySizeCallback<T = any> {\n    (chunk: T): number;\n}\n\ninterface ReadableByteStreamControllerCallback {\n    (controller: ReadableByteStreamController): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamDefaultControllerCallback<R> {\n    (controller: ReadableStreamDefaultController<R>): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamErrorCallback {\n    (reason: any): void | PromiseLike<void>;\n}\n\ninterface TransformStreamDefaultControllerCallback<O> {\n    (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;\n}\n\ninterface TransformStreamDefaultControllerTransformCallback<I, O> {\n    (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerCloseCallback {\n    (): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerStartCallback {\n    (controller: WritableStreamDefaultController): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerWriteCallback<W> {\n    (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>;\n}\n\ninterface WritableStreamErrorCallback {\n    (reason: any): void | PromiseLike<void>;\n}\n\ndeclare var onmessage: ((this: DedicatedWorkerGlobalScope, ev: MessageEvent) => any) | null;\ndeclare function close(): void;\ndeclare function postMessage(message: any, transfer?: Transferable[]): void;\n/**\n * Dispatches a synthetic event event to target and returns true\n * if either event\'s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n */\ndeclare function dispatchEvent(event: Event): boolean;\ndeclare var caches: CacheStorage;\ndeclare var isSecureContext: boolean;\ndeclare var location: WorkerLocation;\ndeclare var onerror: ((this: DedicatedWorkerGlobalScope, ev: ErrorEvent) => any) | null;\ndeclare var performance: Performance;\ndeclare var self: WorkerGlobalScope;\ndeclare function msWriteProfilerMark(profilerMarkName: string): void;\n/**\n * Dispatches a synthetic event event to target and returns true\n * if either event\'s cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n */\ndeclare function dispatchEvent(event: Event): boolean;\ndeclare var indexedDB: IDBFactory;\ndeclare var msIndexedDB: IDBFactory;\ndeclare var navigator: WorkerNavigator;\ndeclare function importScripts(...urls: string[]): void;\ndeclare function atob(encodedString: string): string;\ndeclare function btoa(rawString: string): string;\ndeclare var console: Console;\ndeclare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\ndeclare var caches: CacheStorage;\ndeclare var crypto: Crypto;\ndeclare var indexedDB: IDBFactory;\ndeclare var origin: string;\ndeclare var performance: Performance;\ndeclare function atob(data: string): string;\ndeclare function btoa(data: string): string;\ndeclare function clearInterval(handle?: number): void;\ndeclare function clearTimeout(handle?: number): void;\ndeclare function createImageBitmap(image: ImageBitmapSource): Promise<ImageBitmap>;\ndeclare function createImageBitmap(image: ImageBitmapSource, sx: number, sy: number, sw: number, sh: number): Promise<ImageBitmap>;\ndeclare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;\ndeclare function queueMicrotask(callback: Function): void;\ndeclare function setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\ndeclare function setTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[]): number;\ndeclare function addEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type: K, listener: (this: DedicatedWorkerGlobalScope, ev: DedicatedWorkerGlobalScopeEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\ndeclare function addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\ndeclare function removeEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type: K, listener: (this: DedicatedWorkerGlobalScope, ev: DedicatedWorkerGlobalScopeEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\ndeclare function removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\ntype BlobPart = BufferSource | Blob | string;\ntype HeadersInit = Headers | string[][] | Record<string, string>;\ntype BodyInit = Blob | BufferSource | FormData | URLSearchParams | ReadableStream<Uint8Array> | string;\ntype RequestInfo = Request | string;\ntype DOMHighResTimeStamp = number;\ntype CanvasImageSource = ImageBitmap;\ntype MessageEventSource = MessagePort | ServiceWorker;\ntype ImageBitmapSource = CanvasImageSource | Blob | ImageData;\ntype TimerHandler = string | Function;\ntype PerformanceEntryList = PerformanceEntry[];\ntype PushMessageDataInit = BufferSource | string;\ntype VibratePattern = number | number[];\ntype AlgorithmIdentifier = string | Algorithm;\ntype HashAlgorithmIdentifier = AlgorithmIdentifier;\ntype BigInteger = Uint8Array;\ntype NamedCurve = string;\ntype GLenum = number;\ntype GLboolean = boolean;\ntype GLbitfield = number;\ntype GLint = number;\ntype GLsizei = number;\ntype GLintptr = number;\ntype GLsizeiptr = number;\ntype GLuint = number;\ntype GLfloat = number;\ntype GLclampf = number;\ntype TexImageSource = ImageBitmap | ImageData;\ntype Float32List = Float32Array | GLfloat[];\ntype Int32List = Int32Array | GLint[];\ntype BufferSource = ArrayBufferView | ArrayBuffer;\ntype DOMTimeStamp = number;\ntype FormDataEntryValue = File | string;\ntype IDBValidKey = number | string | Date | BufferSource | IDBArrayKey;\ntype Transferable = ArrayBuffer | MessagePort | ImageBitmap;\ntype BinaryType = "blob" | "arraybuffer";\ntype ClientTypes = "window" | "worker" | "sharedworker" | "all";\ntype EndingType = "transparent" | "native";\ntype IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique";\ntype IDBRequestReadyState = "pending" | "done";\ntype IDBTransactionMode = "readonly" | "readwrite" | "versionchange";\ntype KeyFormat = "raw" | "spki" | "pkcs8" | "jwk";\ntype KeyType = "public" | "private" | "secret";\ntype KeyUsage = "encrypt" | "decrypt" | "sign" | "verify" | "deriveKey" | "deriveBits" | "wrapKey" | "unwrapKey";\ntype NotificationDirection = "auto" | "ltr" | "rtl";\ntype NotificationPermission = "default" | "denied" | "granted";\ntype PushEncryptionKeyName = "p256dh" | "auth";\ntype PushPermissionState = "denied" | "granted" | "prompt";\ntype ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin-only" | "origin-when-cross-origin" | "unsafe-url";\ntype RequestCache = "default" | "no-store" | "reload" | "no-cache" | "force-cache" | "only-if-cached";\ntype RequestCredentials = "omit" | "same-origin" | "include";\ntype RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt";\ntype RequestMode = "navigate" | "same-origin" | "no-cors" | "cors";\ntype RequestRedirect = "follow" | "error" | "manual";\ntype ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";\ntype ServiceWorkerState = "installing" | "installed" | "activating" | "activated" | "redundant";\ntype ServiceWorkerUpdateViaCache = "imports" | "all" | "none";\ntype VisibilityState = "hidden" | "visible" | "prerender";\ntype WebGLPowerPreference = "default" | "low-power" | "high-performance";\ntype WorkerType = "classic" | "module";\ntype XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text";\n'},213:function(e,n){e.exports='// Type definitions for Node.js 10.12\n// Project: http://nodejs.org/\n// Definitions by: Microsoft TypeScript <https://github.com/Microsoft>\n//                 DefinitelyTyped <https://github.com/DefinitelyTyped>\n//                 Alberto Schiabel <https://github.com/jkomyno>\n//                 Alexander T. <https://github.com/a-tarasyuk>\n//                 Alvis HT Tang <https://github.com/alvis>\n//                 Andrew Makarov <https://github.com/r3nya>\n//                 Bruno Scheufler <https://github.com/brunoscheufler>\n//                 Chigozirim C. <https://github.com/smac89>\n//                 Christian Vaagland Tellnes <https://github.com/tellnes>\n//                 Deividas Bakanas <https://github.com/DeividasBakanas>\n//                 Eugene Y. Q. Shen <https://github.com/eyqs>\n//                 Flarna <https://github.com/Flarna>\n//                 Hannes Magnusson <https://github.com/Hannes-Magnusson-CK>\n//                 Ho\xe0ng V\u0103n Kh\u1ea3i <https://github.com/KSXGitHub>\n//                 Huw <https://github.com/hoo29>\n//                 Kelvin Jin <https://github.com/kjin>\n//                 Klaus Meinhardt <https://github.com/ajafff>\n//                 Lishude <https://github.com/islishude>\n//                 Mariusz Wiktorczyk <https://github.com/mwiktorczyk>\n//                 Matthieu Sieben <https://github.com/matthieusieben>\n//                 Mohsen Azimi <https://github.com/mohsen1>\n//                 Nicolas Even <https://github.com/n-e>\n//                 Nicolas Voigt <https://github.com/octo-sniffle>\n//                 Parambir Singh <https://github.com/parambirs>\n//                 Sebastian Silbermann <https://github.com/eps1lon>\n//                 Simon Schick <https://github.com/SimonSchick>\n//                 Thomas den Hollander <https://github.com/ThomasdenH>\n//                 Wilco Bakker <https://github.com/WilcoBakker>\n//                 wwwy3y3 <https://github.com/wwwy3y3>\n//                 Zane Hannan AU <https://github.com/ZaneHannanAU>\n//                 Jeremie Rodriguez <https://github.com/jeremiergz>\n//                 Samuel Ainsworth <https://github.com/samuela>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n/** inspector module types */\n/// <reference path="./inspector.d.ts" />\n\n// This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build\ninterface Console {\n    Console: NodeJS.ConsoleConstructor;\n    /**\n     * A simple assertion test that verifies whether `value` is truthy.\n     * If it is not, an `AssertionError` is thrown.\n     * If provided, the error `message` is formatted using `util.format()` and used as the error message.\n     */\n    assert(value: any, message?: string, ...optionalParams: any[]): void;\n    /**\n     * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY.\n     * When `stdout` is not a TTY, this method does nothing.\n     */\n    clear(): void;\n    /**\n     * Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`.\n     */\n    count(label?: string): void;\n    /**\n     * Resets the internal counter specific to `label`.\n     */\n    countReset(label?: string): void;\n    /**\n     * The `console.debug()` function is an alias for {@link console.log()}.\n     */\n    debug(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Uses {@link util.inspect()} on `obj` and prints the resulting string to `stdout`.\n     * This function bypasses any custom `inspect()` function defined on `obj`.\n     */\n    dir(obj: any, options?: NodeJS.InspectOptions): void;\n    /**\n     * This method calls {@link console.log()} passing it the arguments received. Please note that this method does not produce any XML formatting\n     */\n    dirxml(...data: any[]): void;\n    /**\n     * Prints to `stderr` with newline.\n     */\n    error(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Increases indentation of subsequent lines by two spaces.\n     * If one or more `label`s are provided, those are printed first without the additional indentation.\n     */\n    group(...label: any[]): void;\n    /**\n     * The `console.groupCollapsed()` function is an alias for {@link console.group()}.\n     */\n    groupCollapsed(): void;\n    /**\n     * Decreases indentation of subsequent lines by two spaces.\n     */\n    groupEnd(): void;\n    /**\n     * The {@link console.info()} function is an alias for {@link console.log()}.\n     */\n    info(message?: any, ...optionalParams: any[]): void;\n    /**\n     * Prints to `stdout` with newline.\n     */\n    log(message?: any, ...optionalParams: any[]): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Prints to `stdout` the array `array` formatted as a table.\n     */\n    table(tabularData: any, properties?: string[]): void;\n    /**\n     * Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`.\n     */\n    time(label?: string): void;\n    /**\n     * Stops a timer that was previously started by calling {@link console.time()} and prints the result to `stdout`.\n     */\n    timeEnd(label?: string): void;\n    /**\n     * For a timer that was previously started by calling {@link console.time()}, prints the elapsed time and other `data` arguments to `stdout`.\n     */\n    timeLog(label: string, ...data: any[]): void;\n    /**\n     * Prints to `stderr` the string \'Trace :\', followed by the {@link util.format()} formatted message and stack trace to the current position in the code.\n     */\n    trace(message?: any, ...optionalParams: any[]): void;\n    /**\n     * The {@link console.warn()} function is an alias for {@link console.error()}.\n     */\n    warn(message?: any, ...optionalParams: any[]): void;\n\n    // --- Inspector mode only ---\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Starts a JavaScript CPU profile with an optional label.\n     */\n    profile(label?: string): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.\n     */\n    profileEnd(): void;\n    /**\n     * This method does not display anything unless used in the inspector.\n     *  Adds an event with the label `label` to the Timeline panel of the inspector.\n     */\n    timeStamp(label?: string): void;\n}\n\ninterface Error {\n    stack?: string;\n}\n\n// Declare "static" methods in Error\ninterface ErrorConstructor {\n    /** Create .stack property on a target object */\n    captureStackTrace(targetObject: Object, constructorOpt?: Function): void;\n\n    /**\n     * Optional override for formatting stack traces\n     *\n     * @see https://github.com/v8/v8/wiki/Stack%20Trace%20API#customizing-stack-traces\n     */\n    prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;\n\n    stackTraceLimit: number;\n}\n\n// compat for TypeScript 1.8 and default es5 target\n// if you use with --target es3 or --target es5 and use below definitions,\n// use the lib.es6.d.ts that is bundled with TypeScript 1.8.\ninterface MapConstructor { }\ninterface WeakMapConstructor { }\ninterface SetConstructor { }\ninterface WeakSetConstructor { }\n\ninterface Set<T> {}\ninterface ReadonlySet<T> {}\n\n// Forward-declare needed types from lib.es2015.d.ts (in case users are using `--lib es5`)\ninterface Iterable<T> { }\ninterface Iterator<T> {\n    next(value?: any): IteratorResult<T>;\n}\ninterface IteratorResult<T> { }\ninterface AsyncIterableIterator<T> {}\ninterface SymbolConstructor {\n    readonly observable: symbol;\n    readonly iterator: symbol;\n    readonly asyncIterator: symbol;\n}\ndeclare var Symbol: SymbolConstructor;\ninterface SharedArrayBuffer {\n    readonly byteLength: number;\n    slice(begin?: number, end?: number): SharedArrayBuffer;\n}\n\n// Node.js ESNEXT support\ninterface String {\n    /** Removes whitespace from the left end of a string. */\n    trimLeft(): string;\n    /** Removes whitespace from the right end of a string. */\n    trimRight(): string;\n}\n\n/*-----------------------------------------------*\n *                                               *\n *                   GLOBAL                      *\n *                                               *\n ------------------------------------------------*/\ndeclare var process: NodeJS.Process;\ndeclare var global: NodeJS.Global;\ndeclare var console: Console;\n\ndeclare var __filename: string;\ndeclare var __dirname: string;\n\ndeclare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare namespace setTimeout {\n    function __promisify__(ms: number): Promise<void>;\n    function __promisify__<T>(ms: number, value: T): Promise<T>;\n}\ndeclare function clearTimeout(timeoutId: NodeJS.Timeout): void;\ndeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\ndeclare function clearInterval(intervalId: NodeJS.Timeout): void;\ndeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\ndeclare namespace setImmediate {\n    function __promisify__(): Promise<void>;\n    function __promisify__<T>(value: T): Promise<T>;\n}\ndeclare function clearImmediate(immediateId: NodeJS.Immediate): void;\n\n// TODO: change to `type NodeRequireFunction = (id: string) => any;` in next mayor version.\ninterface NodeRequireFunction {\n    /* tslint:disable-next-line:callable-types */\n    (id: string): any;\n}\n\ninterface NodeRequire extends NodeRequireFunction {\n    resolve: RequireResolve;\n    cache: any;\n    extensions: NodeExtensions;\n    main: NodeModule | undefined;\n}\n\ninterface RequireResolve {\n    (id: string, options?: { paths?: string[]; }): string;\n    paths(request: string): string[] | null;\n}\n\ninterface NodeExtensions {\n    \'.js\': (m: NodeModule, filename: string) => any;\n    \'.json\': (m: NodeModule, filename: string) => any;\n    \'.node\': (m: NodeModule, filename: string) => any;\n    [ext: string]: (m: NodeModule, filename: string) => any;\n}\n\ndeclare var require: NodeRequire;\n\ninterface NodeModule {\n    exports: any;\n    require: NodeRequireFunction;\n    id: string;\n    filename: string;\n    loaded: boolean;\n    parent: NodeModule | null;\n    children: NodeModule[];\n    paths: string[];\n}\n\ndeclare var module: NodeModule;\n\n// Same as module.exports\ndeclare var exports: any;\ndeclare const SlowBuffer: {\n    new(str: string, encoding?: string): Buffer;\n    new(size: number): Buffer;\n    new(size: Uint8Array): Buffer;\n    new(array: any[]): Buffer;\n    prototype: Buffer;\n    isBuffer(obj: any): boolean;\n    byteLength(string: string, encoding?: string): number;\n    concat(list: Buffer[], totalLength?: number): Buffer;\n};\n\n// Buffer class\ntype BufferEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";\ninterface Buffer extends Uint8Array {\n    constructor: typeof Buffer;\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: \'Buffer\', data: any[] };\n    equals(otherBuffer: Uint8Array): boolean;\n    compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;\n    entries(): IterableIterator<[number, number]>;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n    keys(): IterableIterator<number>;\n    values(): IterableIterator<number>;\n}\n\n/**\n * Raw data is stored in instances of the Buffer class.\n * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.\n * Valid string encodings: \'ascii\'|\'utf8\'|\'utf16le\'|\'ucs2\'(alias of \'utf16le\')|\'base64\'|\'binary\'(deprecated)|\'hex\'\n */\ndeclare const Buffer: {\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is \'utf8\'\n     * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n     */\n    new(str: string, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n     */\n    new(size: number): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: Uint8Array): Buffer;\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}/{SharedArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n     */\n    new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n     */\n    new(array: any[]): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.\n     */\n    new(buffer: Buffer): Buffer;\n    prototype: Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()\n     */\n    from(arrayBuffer: ArrayBuffer | SharedArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param data data to create a new Buffer\n     */\n    from(data: any[]): Buffer;\n    from(data: Uint8Array): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to \'utf8\'.\n     */\n    from(str: string, encoding?: string): Buffer;\n    /**\n     * Creates a new Buffer using the passed {data}\n     * @param values to create a new Buffer\n     */\n    of(...items: number[]): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: \'ascii\'|\'utf8\'|\'utf16le\'|\'ucs2\'(alias of \'utf16le\')|\'base64\'|\'binary\'(deprecated)|\'hex\'\n     *\n     * @param encoding string to test.\n     */\n    isEncoding(encoding: string): boolean | undefined;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to \'utf8\'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to \'utf8\')\n     */\n    byteLength(string: string | NodeJS.TypedArray | DataView | ArrayBuffer | SharedArrayBuffer, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    concat(list: Uint8Array[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    compare(buf1: Uint8Array, buf2: Uint8Array): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    allocUnsafeSlow(size: number): Buffer;\n    /**\n     * This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified.\n     */\n    poolSize: number;\n};\n\n/*----------------------------------------------*\n*                                               *\n*               GLOBAL INTERFACES               *\n*                                               *\n*-----------------------------------------------*/\ndeclare namespace NodeJS {\n    interface InspectOptions {\n        showHidden?: boolean;\n        depth?: number | null;\n        colors?: boolean;\n        customInspect?: boolean;\n        showProxy?: boolean;\n        maxArrayLength?: number | null;\n        breakLength?: number;\n        compact?: boolean;\n        sorted?: boolean | ((a: string, b: string) => number);\n    }\n\n    interface ConsoleConstructorOptions {\n        stdout: WritableStream;\n        stderr?: WritableStream;\n        ignoreErrors?: boolean;\n        colorMode?: boolean | \'auto\';\n    }\n\n    interface ConsoleConstructor {\n        prototype: Console;\n        new(stdout: WritableStream, stderr?: WritableStream, ignoreErrors?: boolean): Console;\n        new(options: ConsoleConstructorOptions): Console;\n    }\n\n    interface CallSite {\n        /**\n         * Value of "this"\n         */\n        getThis(): any;\n\n        /**\n         * Type of "this" as a string.\n         * This is the name of the function stored in the constructor field of\n         * "this", if available.  Otherwise the object\'s [[Class]] internal\n         * property.\n         */\n        getTypeName(): string | null;\n\n        /**\n         * Current function\n         */\n        getFunction(): Function | undefined;\n\n        /**\n         * Name of the current function, typically its name property.\n         * If a name property is not available an attempt will be made to try\n         * to infer a name from the function\'s context.\n         */\n        getFunctionName(): string | null;\n\n        /**\n         * Name of the property [of "this" or one of its prototypes] that holds\n         * the current function\n         */\n        getMethodName(): string | null;\n\n        /**\n         * Name of the script [if this function was defined in a script]\n         */\n        getFileName(): string | null;\n\n        /**\n         * Current line number [if this function was defined in a script]\n         */\n        getLineNumber(): number | null;\n\n        /**\n         * Current column number [if this function was defined in a script]\n         */\n        getColumnNumber(): number | null;\n\n        /**\n         * A call site object representing the location where eval was called\n         * [if this function was created using a call to eval]\n         */\n        getEvalOrigin(): string | undefined;\n\n        /**\n         * Is this a toplevel invocation, that is, is "this" the global object?\n         */\n        isToplevel(): boolean;\n\n        /**\n         * Does this call take place in code defined by a call to eval?\n         */\n        isEval(): boolean;\n\n        /**\n         * Is this call in native V8 code?\n         */\n        isNative(): boolean;\n\n        /**\n         * Is this a constructor call?\n         */\n        isConstructor(): boolean;\n    }\n\n    interface ErrnoException extends Error {\n        errno?: number;\n        code?: string;\n        path?: string;\n        syscall?: string;\n        stack?: string;\n    }\n\n    class EventEmitter {\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string | symbol): this;\n        setMaxListeners(n: number): this;\n        getMaxListeners(): number;\n        listeners(event: string | symbol): Function[];\n        rawListeners(event: string | symbol): Function[];\n        emit(event: string | symbol, ...args: any[]): boolean;\n        listenerCount(type: string | symbol): number;\n        // Added in Node 6...\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        eventNames(): Array<string | symbol>;\n    }\n\n    interface ReadableStream extends EventEmitter {\n        readable: boolean;\n        read(size?: number): string | Buffer;\n        setEncoding(encoding: string): this;\n        pause(): this;\n        resume(): this;\n        isPaused(): boolean;\n        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean; }): T;\n        unpipe(destination?: WritableStream): this;\n        unshift(chunk: string): void;\n        unshift(chunk: Buffer): void;\n        wrap(oldStream: ReadableStream): this;\n        [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;\n    }\n\n    interface WritableStream extends EventEmitter {\n        writable: boolean;\n        write(buffer: Buffer | string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        end(cb?: Function): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n    }\n\n    interface ReadWriteStream extends ReadableStream, WritableStream { }\n\n    interface Events extends EventEmitter { }\n\n    interface Domain extends Events {\n        run(fn: Function): void;\n        add(emitter: Events): void;\n        remove(emitter: Events): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        removeListener(event: string, listener: (...args: any[]) => void): this;\n        removeAllListeners(event?: string): this;\n    }\n\n    interface MemoryUsage {\n        rss: number;\n        heapTotal: number;\n        heapUsed: number;\n        external: number;\n    }\n\n    interface CpuUsage {\n        user: number;\n        system: number;\n    }\n\n    interface ProcessRelease {\n        name: string;\n        sourceUrl?: string;\n        headersUrl?: string;\n        libUrl?: string;\n        lts?: string;\n    }\n\n    interface ProcessVersions {\n        http_parser: string;\n        node: string;\n        v8: string;\n        ares: string;\n        uv: string;\n        zlib: string;\n        modules: string;\n        openssl: string;\n    }\n\n    type Platform = \'aix\'\n        | \'android\'\n        | \'darwin\'\n        | \'freebsd\'\n        | \'linux\'\n        | \'openbsd\'\n        | \'sunos\'\n        | \'win32\'\n        | \'cygwin\';\n\n    type Signals =\n        "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" |\n        "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" |\n        "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" |\n        "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO";\n\n    type MultipleResolveType = \'resolve\' | \'reject\';\n\n    type BeforeExitListener = (code: number) => void;\n    type DisconnectListener = () => void;\n    type ExitListener = (code: number) => void;\n    type RejectionHandledListener = (promise: Promise<any>) => void;\n    type UncaughtExceptionListener = (error: Error) => void;\n    type UnhandledRejectionListener = (reason: any, promise: Promise<any>) => void;\n    type WarningListener = (warning: Error) => void;\n    type MessageListener = (message: any, sendHandle: any) => void;\n    type SignalsListener = (signal: Signals) => void;\n    type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n    type MultipleResolveListener = (type: MultipleResolveType, promise: Promise<any>, value: any) => void;\n\n    interface Socket extends ReadWriteStream {\n        isTTY?: true;\n    }\n\n    interface ProcessEnv {\n        [key: string]: string | undefined;\n    }\n\n    interface WriteStream extends Socket {\n        readonly writableHighWaterMark: number;\n        readonly writableLength: number;\n        columns?: number;\n        rows?: number;\n        _write(chunk: any, encoding: string, callback: Function): void;\n        _destroy(err: Error | null, callback: Function): void;\n        _final(callback: Function): void;\n        setDefaultEncoding(encoding: string): this;\n        cork(): void;\n        uncork(): void;\n        destroy(error?: Error): void;\n    }\n    interface ReadStream extends Socket {\n        readonly readableHighWaterMark: number;\n        readonly readableLength: number;\n        isRaw?: boolean;\n        setRawMode?(mode: boolean): void;\n        _read(size: number): void;\n        _destroy(err: Error | null, callback: Function): void;\n        push(chunk: any, encoding?: string): boolean;\n        destroy(error?: Error): void;\n    }\n\n    interface Process extends EventEmitter {\n        stdout: WriteStream;\n        stderr: WriteStream;\n        stdin: ReadStream;\n        openStdin(): Socket;\n        argv: string[];\n        argv0: string;\n        execArgv: string[];\n        execPath: string;\n        abort(): void;\n        chdir(directory: string): void;\n        cwd(): string;\n        debugPort: number;\n        emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n        env: ProcessEnv;\n        exit(code?: number): never;\n        exitCode: number;\n        getgid(): number;\n        setgid(id: number | string): void;\n        getuid(): number;\n        setuid(id: number | string): void;\n        geteuid(): number;\n        seteuid(id: number | string): void;\n        getegid(): number;\n        setegid(id: number | string): void;\n        getgroups(): number[];\n        setgroups(groups: Array<string | number>): void;\n        setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n        hasUncaughtExceptionCaptureCallback(): boolean;\n        version: string;\n        versions: ProcessVersions;\n        config: {\n            target_defaults: {\n                cflags: any[];\n                default_configuration: string;\n                defines: string[];\n                include_dirs: string[];\n                libraries: string[];\n            };\n            variables: {\n                clang: number;\n                host_arch: string;\n                node_install_npm: boolean;\n                node_install_waf: boolean;\n                node_prefix: string;\n                node_shared_openssl: boolean;\n                node_shared_v8: boolean;\n                node_shared_zlib: boolean;\n                node_use_dtrace: boolean;\n                node_use_etw: boolean;\n                node_use_openssl: boolean;\n                target_arch: string;\n                v8_no_strict_aliasing: number;\n                v8_use_snapshot: boolean;\n                visibility: string;\n            };\n        };\n        kill(pid: number, signal?: string | number): void;\n        pid: number;\n        ppid: number;\n        title: string;\n        arch: string;\n        platform: Platform;\n        mainModule?: NodeModule;\n        memoryUsage(): MemoryUsage;\n        cpuUsage(previousValue?: CpuUsage): CpuUsage;\n        nextTick(callback: Function, ...args: any[]): void;\n        release: ProcessRelease;\n        umask(mask?: number): number;\n        uptime(): number;\n        hrtime(time?: [number, number]): [number, number];\n        domain: Domain;\n\n        // Worker\n        send?(message: any, sendHandle?: any): void;\n        disconnect(): void;\n        connected: boolean;\n\n        /**\n         * The `process.allowedNodeEnvironmentFlags` property is a special,\n         * read-only `Set` of flags allowable within the [`NODE_OPTIONS`][]\n         * environment variable.\n         */\n        allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n        /**\n         * EventEmitter\n         *   1. beforeExit\n         *   2. disconnect\n         *   3. exit\n         *   4. message\n         *   5. rejectionHandled\n         *   6. uncaughtException\n         *   7. unhandledRejection\n         *   8. warning\n         *   9. message\n         *  10. <All OS Signals>\n         *  11. newListener/removeListener inherited from EventEmitter\n         */\n        addListener(event: "beforeExit", listener: BeforeExitListener): this;\n        addListener(event: "disconnect", listener: DisconnectListener): this;\n        addListener(event: "exit", listener: ExitListener): this;\n        addListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n        addListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n        addListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n        addListener(event: "warning", listener: WarningListener): this;\n        addListener(event: "message", listener: MessageListener): this;\n        addListener(event: Signals, listener: SignalsListener): this;\n        addListener(event: "newListener", listener: NewListenerListener): this;\n        addListener(event: "removeListener", listener: RemoveListenerListener): this;\n        addListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        emit(event: "beforeExit", code: number): boolean;\n        emit(event: "disconnect"): boolean;\n        emit(event: "exit", code: number): boolean;\n        emit(event: "rejectionHandled", promise: Promise<any>): boolean;\n        emit(event: "uncaughtException", error: Error): boolean;\n        emit(event: "unhandledRejection", reason: any, promise: Promise<any>): boolean;\n        emit(event: "warning", warning: Error): boolean;\n        emit(event: "message", message: any, sendHandle: any): this;\n        emit(event: Signals, signal: Signals): boolean;\n        emit(event: "newListener", eventName: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: "removeListener", eventName: string, listener: (...args: any[]) => void): this;\n        emit(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        on(event: "beforeExit", listener: BeforeExitListener): this;\n        on(event: "disconnect", listener: DisconnectListener): this;\n        on(event: "exit", listener: ExitListener): this;\n        on(event: "rejectionHandled", listener: RejectionHandledListener): this;\n        on(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n        on(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n        on(event: "warning", listener: WarningListener): this;\n        on(event: "message", listener: MessageListener): this;\n        on(event: Signals, listener: SignalsListener): this;\n        on(event: "newListener", listener: NewListenerListener): this;\n        on(event: "removeListener", listener: RemoveListenerListener): this;\n        on(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        once(event: "beforeExit", listener: BeforeExitListener): this;\n        once(event: "disconnect", listener: DisconnectListener): this;\n        once(event: "exit", listener: ExitListener): this;\n        once(event: "rejectionHandled", listener: RejectionHandledListener): this;\n        once(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n        once(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n        once(event: "warning", listener: WarningListener): this;\n        once(event: "message", listener: MessageListener): this;\n        once(event: Signals, listener: SignalsListener): this;\n        once(event: "newListener", listener: NewListenerListener): this;\n        once(event: "removeListener", listener: RemoveListenerListener): this;\n        once(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        prependListener(event: "beforeExit", listener: BeforeExitListener): this;\n        prependListener(event: "disconnect", listener: DisconnectListener): this;\n        prependListener(event: "exit", listener: ExitListener): this;\n        prependListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n        prependListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n        prependListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n        prependListener(event: "warning", listener: WarningListener): this;\n        prependListener(event: "message", listener: MessageListener): this;\n        prependListener(event: Signals, listener: SignalsListener): this;\n        prependListener(event: "newListener", listener: NewListenerListener): this;\n        prependListener(event: "removeListener", listener: RemoveListenerListener): this;\n        prependListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        prependOnceListener(event: "beforeExit", listener: BeforeExitListener): this;\n        prependOnceListener(event: "disconnect", listener: DisconnectListener): this;\n        prependOnceListener(event: "exit", listener: ExitListener): this;\n        prependOnceListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n        prependOnceListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n        prependOnceListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n        prependOnceListener(event: "warning", listener: WarningListener): this;\n        prependOnceListener(event: "message", listener: MessageListener): this;\n        prependOnceListener(event: Signals, listener: SignalsListener): this;\n        prependOnceListener(event: "newListener", listener: NewListenerListener): this;\n        prependOnceListener(event: "removeListener", listener: RemoveListenerListener): this;\n        prependOnceListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n        listeners(event: "beforeExit"): BeforeExitListener[];\n        listeners(event: "disconnect"): DisconnectListener[];\n        listeners(event: "exit"): ExitListener[];\n        listeners(event: "rejectionHandled"): RejectionHandledListener[];\n        listeners(event: "uncaughtException"): UncaughtExceptionListener[];\n        listeners(event: "unhandledRejection"): UnhandledRejectionListener[];\n        listeners(event: "warning"): WarningListener[];\n        listeners(event: "message"): MessageListener[];\n        listeners(event: Signals): SignalsListener[];\n        listeners(event: "newListener"): NewListenerListener[];\n        listeners(event: "removeListener"): RemoveListenerListener[];\n        listeners(event: "multipleResolves"): MultipleResolveListener[];\n    }\n\n    interface Global {\n        Array: typeof Array;\n        ArrayBuffer: typeof ArrayBuffer;\n        Boolean: typeof Boolean;\n        Buffer: typeof Buffer;\n        DataView: typeof DataView;\n        Date: typeof Date;\n        Error: typeof Error;\n        EvalError: typeof EvalError;\n        Float32Array: typeof Float32Array;\n        Float64Array: typeof Float64Array;\n        Function: typeof Function;\n        GLOBAL: Global;\n        Infinity: typeof Infinity;\n        Int16Array: typeof Int16Array;\n        Int32Array: typeof Int32Array;\n        Int8Array: typeof Int8Array;\n        Intl: typeof Intl;\n        JSON: typeof JSON;\n        Map: MapConstructor;\n        Math: typeof Math;\n        NaN: typeof NaN;\n        Number: typeof Number;\n        Object: typeof Object;\n        Promise: Function;\n        RangeError: typeof RangeError;\n        ReferenceError: typeof ReferenceError;\n        RegExp: typeof RegExp;\n        Set: SetConstructor;\n        String: typeof String;\n        Symbol: Function;\n        SyntaxError: typeof SyntaxError;\n        TypeError: typeof TypeError;\n        URIError: typeof URIError;\n        Uint16Array: typeof Uint16Array;\n        Uint32Array: typeof Uint32Array;\n        Uint8Array: typeof Uint8Array;\n        Uint8ClampedArray: Function;\n        WeakMap: WeakMapConstructor;\n        WeakSet: WeakSetConstructor;\n        clearImmediate: (immediateId: Immediate) => void;\n        clearInterval: (intervalId: Timeout) => void;\n        clearTimeout: (timeoutId: Timeout) => void;\n        console: typeof console;\n        decodeURI: typeof decodeURI;\n        decodeURIComponent: typeof decodeURIComponent;\n        encodeURI: typeof encodeURI;\n        encodeURIComponent: typeof encodeURIComponent;\n        escape: (str: string) => string;\n        eval: typeof eval;\n        global: Global;\n        isFinite: typeof isFinite;\n        isNaN: typeof isNaN;\n        parseFloat: typeof parseFloat;\n        parseInt: typeof parseInt;\n        process: Process;\n        root: Global;\n        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => Immediate;\n        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => Timeout;\n        undefined: typeof undefined;\n        unescape: (str: string) => string;\n        gc: () => void;\n        v8debug?: any;\n    }\n\n    interface Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Immediate {\n        ref(): void;\n        unref(): void;\n        _onImmediate: Function; // to distinguish it from the Timeout class\n    }\n\n    class Timeout implements Timer {\n        ref(): void;\n        refresh(): void;\n        unref(): void;\n    }\n\n    class Module {\n        static runMain(): void;\n        static wrap(code: string): string;\n        static createRequireFromPath(path: string): (path: string) => any;\n        static builtinModules: string[];\n\n        static Module: typeof Module;\n\n        exports: any;\n        require: NodeRequireFunction;\n        id: string;\n        filename: string;\n        loaded: boolean;\n        parent: Module | null;\n        children: Module[];\n        paths: string[];\n\n        constructor(id: string, parent?: Module);\n    }\n\n    type TypedArray = Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n}\n\ninterface IterableIterator<T> { }\n\n/*----------------------------------------------*\n*                                               *\n*                   MODULES                     *\n*                                               *\n*-----------------------------------------------*/\ndeclare module "buffer" {\n    export const INSPECT_MAX_BYTES: number;\n    const BuffType: typeof Buffer;\n    const SlowBuffType: typeof SlowBuffer;\n    export { BuffType as Buffer, SlowBuffType as SlowBuffer };\n}\n\ndeclare module "querystring" {\n    interface StringifyOptions {\n        encodeURIComponent?: Function;\n    }\n\n    interface ParseOptions {\n        maxKeys?: number;\n        decodeURIComponent?: Function;\n    }\n\n    interface ParsedUrlQuery { [key: string]: string | string[]; }\n\n    function stringify(obj?: {}, sep?: string, eq?: string, options?: StringifyOptions): string;\n    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;\n    function escape(str: string): string;\n    function unescape(str: string): string;\n}\n\ndeclare module "events" {\n    class internal extends NodeJS.EventEmitter { }\n\n    namespace internal {\n         class EventEmitter extends internal {\n            /** @deprecated since v4.0.0 */\n            static listenerCount(emitter: EventEmitter, event: string | symbol): number;\n            static defaultMaxListeners: number;\n\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n            off(event: string | symbol, listener: (...args: any[]) => void): this;\n            removeAllListeners(event?: string | symbol): this;\n            setMaxListeners(n: number): this;\n            getMaxListeners(): number;\n            listeners(event: string | symbol): Function[];\n            rawListeners(event: string | symbol): Function[];\n            emit(event: string | symbol, ...args: any[]): boolean;\n            eventNames(): Array<string | symbol>;\n            listenerCount(type: string | symbol): number;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module "http" {\n    import * as events from "events";\n    import * as net from "net";\n    import * as stream from "stream";\n    import { URL } from "url";\n\n    // incoming headers will never contain number\n    interface IncomingHttpHeaders {\n        \'accept\'?: string;\n        \'access-control-allow-origin\'?: string;\n        \'access-control-allow-credentials\'?: string;\n        \'access-control-expose-headers\'?: string;\n        \'access-control-max-age\'?: string;\n        \'access-control-allow-methods\'?: string;\n        \'access-control-allow-headers\'?: string;\n        \'accept-patch\'?: string;\n        \'accept-ranges\'?: string;\n        \'age\'?: string;\n        \'allow\'?: string;\n        \'alt-svc\'?: string;\n        \'authorization\'?: string;\n        \'cache-control\'?: string;\n        \'connection\'?: string;\n        \'content-disposition\'?: string;\n        \'content-encoding\'?: string;\n        \'content-language\'?: string;\n        \'content-length\'?: string;\n        \'content-location\'?: string;\n        \'content-range\'?: string;\n        \'content-type\'?: string;\n        \'cookie\'?: string;\n        \'date\'?: string;\n        \'expect\'?: string;\n        \'expires\'?: string;\n        \'forwarded\'?: string;\n        \'from\'?: string;\n        \'host\'?: string;\n        \'if-match\'?: string;\n        \'if-modified-since\'?: string;\n        \'if-none-match\'?: string;\n        \'if-unmodified-since\'?: string;\n        \'last-modified\'?: string;\n        \'location\'?: string;\n        \'pragma\'?: string;\n        \'proxy-authenticate\'?: string;\n        \'proxy-authorization\'?: string;\n        \'public-key-pins\'?: string;\n        \'range\'?: string;\n        \'referer\'?: string;\n        \'retry-after\'?: string;\n        \'set-cookie\'?: string[];\n        \'strict-transport-security\'?: string;\n        \'trailer\'?: string;\n        \'transfer-encoding\'?: string;\n        \'tk\'?: string;\n        \'upgrade\'?: string;\n        \'user-agent\'?: string;\n        \'vary\'?: string;\n        \'via\'?: string;\n        \'warning\'?: string;\n        \'www-authenticate\'?: string;\n        [header: string]: string | string[] | undefined;\n    }\n\n    // outgoing headers allows numbers (as they are converted internally to strings)\n    interface OutgoingHttpHeaders {\n        [header: string]: number | string | string[] | undefined;\n    }\n\n    interface ClientRequestArgs {\n        protocol?: string;\n        host?: string;\n        hostname?: string;\n        family?: number;\n        port?: number | string;\n        defaultPort?: number | string;\n        localAddress?: string;\n        socketPath?: string;\n        method?: string;\n        path?: string;\n        headers?: OutgoingHttpHeaders;\n        auth?: string;\n        agent?: Agent | boolean;\n        _defaultAgent?: Agent;\n        timeout?: number;\n        // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L278\n        createConnection?: (options: ClientRequestArgs, oncreate: (err: Error, socket: net.Socket) => void) => net.Socket;\n    }\n\n    class Server extends net.Server {\n        constructor(requestListener?: (req: IncomingMessage, res: ServerResponse) => void);\n\n        setTimeout(msecs?: number, callback?: () => void): this;\n        setTimeout(callback: () => void): this;\n        maxHeadersCount: number;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_outgoing.js\n    class OutgoingMessage extends stream.Writable {\n        upgrading: boolean;\n        chunkedEncoding: boolean;\n        shouldKeepAlive: boolean;\n        useChunkedEncodingByDefault: boolean;\n        sendDate: boolean;\n        finished: boolean;\n        headersSent: boolean;\n        connection: net.Socket;\n\n        constructor();\n\n        setTimeout(msecs: number, callback?: () => void): this;\n        setHeader(name: string, value: number | string | string[]): void;\n        getHeader(name: string): number | string | string[] | undefined;\n        getHeaders(): OutgoingHttpHeaders;\n        getHeaderNames(): string[];\n        hasHeader(name: string): boolean;\n        removeHeader(name: string): void;\n        addTrailers(headers: OutgoingHttpHeaders | Array<[string, string]>): void;\n        flushHeaders(): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_server.js#L108-L256\n    class ServerResponse extends OutgoingMessage {\n        statusCode: number;\n        statusMessage: string;\n\n        constructor(req: IncomingMessage);\n\n        assignSocket(socket: net.Socket): void;\n        detachSocket(socket: net.Socket): void;\n        // https://github.com/nodejs/node/blob/master/test/parallel/test-http-write-callbacks.js#L53\n        // no args in writeContinue callback\n        writeContinue(callback?: () => void): void;\n        writeHead(statusCode: number, reasonPhrase?: string, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/_http_client.js#L77\n    class ClientRequest extends OutgoingMessage {\n        connection: net.Socket;\n        socket: net.Socket;\n        aborted: number;\n\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\n\n        abort(): void;\n        onSocket(socket: net.Socket): void;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): void;\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\n    }\n\n    class IncomingMessage extends stream.Readable {\n        constructor(socket: net.Socket);\n\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        connection: net.Socket;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n        trailers: { [key: string]: string | undefined };\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback: () => void): this;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        method?: string;\n        /**\n         * Only valid for request obtained from http.Server.\n         */\n        url?: string;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusCode?: number;\n        /**\n         * Only valid for response obtained from http.ClientRequest.\n         */\n        statusMessage?: string;\n        socket: net.Socket;\n        destroy(error?: Error): void;\n    }\n\n    interface AgentOptions {\n        /**\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\n         */\n        keepAlive?: boolean;\n        /**\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\n         * Only relevant if keepAlive is set to true.\n         */\n        keepAliveMsecs?: number;\n        /**\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\n         */\n        maxSockets?: number;\n        /**\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\n         */\n        maxFreeSockets?: number;\n        /**\n         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.\n         */\n        timeout?: number;\n    }\n\n    class Agent {\n        maxFreeSockets: number;\n        maxSockets: number;\n        sockets: any;\n        requests: any;\n\n        constructor(opts?: AgentOptions);\n\n        /**\n         * Destroy any sockets that are currently in use by the agent.\n         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,\n         * then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,\n         * sockets may hang open for quite a long time before the server terminates them.\n         */\n        destroy(): void;\n    }\n\n    const METHODS: string[];\n\n    const STATUS_CODES: {\n        [errorCode: number]: string | undefined;\n        [errorCode: string]: string | undefined;\n    };\n\n    function createServer(requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server;\n    function createClient(port?: number, host?: string): any;\n\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\n    // create interface RequestOptions would make the naming more clear to developers\n    interface RequestOptions extends ClientRequestArgs { }\n    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module "cluster" {\n    import * as child from "child_process";\n    import * as events from "events";\n    import * as net from "net";\n\n    // interfaces\n    interface ClusterSettings {\n        execArgv?: string[]; // default: process.execArgv\n        exec?: string;\n        args?: string[];\n        silent?: boolean;\n        stdio?: any[];\n        uid?: number;\n        gid?: number;\n        inspectPort?: number | (() => number);\n    }\n\n    interface Address {\n        address: string;\n        port: number;\n        addressType: number | "udp4" | "udp6";  // 4, 6, -1, "udp4", "udp6"\n    }\n\n    class Worker extends events.EventEmitter {\n        id: number;\n        process: child.ChildProcess;\n        suicide: boolean;\n        send(message: any, sendHandle?: any, callback?: (error: Error) => void): boolean;\n        kill(signal?: string): void;\n        destroy(signal?: string): void;\n        disconnect(): void;\n        isConnected(): boolean;\n        isDead(): boolean;\n        exitedAfterDisconnect: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. error\n         *   3. exit\n         *   4. listening\n         *   5. message\n         *   6. online\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "disconnect", listener: () => void): this;\n        addListener(event: "error", listener: (error: Error) => void): this;\n        addListener(event: "exit", listener: (code: number, signal: string) => void): this;\n        addListener(event: "listening", listener: (address: Address) => void): this;\n        addListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: "online", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "disconnect"): boolean;\n        emit(event: "error", error: Error): boolean;\n        emit(event: "exit", code: number, signal: string): boolean;\n        emit(event: "listening", address: Address): boolean;\n        emit(event: "message", message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: "online"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "disconnect", listener: () => void): this;\n        on(event: "error", listener: (error: Error) => void): this;\n        on(event: "exit", listener: (code: number, signal: string) => void): this;\n        on(event: "listening", listener: (address: Address) => void): this;\n        on(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: "online", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "disconnect", listener: () => void): this;\n        once(event: "error", listener: (error: Error) => void): this;\n        once(event: "exit", listener: (code: number, signal: string) => void): this;\n        once(event: "listening", listener: (address: Address) => void): this;\n        once(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: "online", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "disconnect", listener: () => void): this;\n        prependListener(event: "error", listener: (error: Error) => void): this;\n        prependListener(event: "exit", listener: (code: number, signal: string) => void): this;\n        prependListener(event: "listening", listener: (address: Address) => void): this;\n        prependListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: "online", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "disconnect", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (error: Error) => void): this;\n        prependOnceListener(event: "exit", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: "listening", listener: (address: Address) => void): this;\n        prependOnceListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: "online", listener: () => void): this;\n    }\n\n    interface Cluster extends events.EventEmitter {\n        Worker: Worker;\n        disconnect(callback?: Function): void;\n        fork(env?: any): Worker;\n        isMaster: boolean;\n        isWorker: boolean;\n        // TODO: cluster.schedulingPolicy\n        settings: ClusterSettings;\n        setupMaster(settings?: ClusterSettings): void;\n        worker?: Worker;\n        workers?: {\n            [index: string]: Worker | undefined\n        };\n\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. exit\n         *   3. fork\n         *   4. listening\n         *   5. message\n         *   6. online\n         *   7. setup\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "disconnect", listener: (worker: Worker) => void): this;\n        addListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;\n        addListener(event: "fork", listener: (worker: Worker) => void): this;\n        addListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;\n        addListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: "online", listener: (worker: Worker) => void): this;\n        addListener(event: "setup", listener: (settings: any) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "disconnect", worker: Worker): boolean;\n        emit(event: "exit", worker: Worker, code: number, signal: string): boolean;\n        emit(event: "fork", worker: Worker): boolean;\n        emit(event: "listening", worker: Worker, address: Address): boolean;\n        emit(event: "message", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: "online", worker: Worker): boolean;\n        emit(event: "setup", settings: any): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "disconnect", listener: (worker: Worker) => void): this;\n        on(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;\n        on(event: "fork", listener: (worker: Worker) => void): this;\n        on(event: "listening", listener: (worker: Worker, address: Address) => void): this;\n        on(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: "online", listener: (worker: Worker) => void): this;\n        on(event: "setup", listener: (settings: any) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "disconnect", listener: (worker: Worker) => void): this;\n        once(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;\n        once(event: "fork", listener: (worker: Worker) => void): this;\n        once(event: "listening", listener: (worker: Worker, address: Address) => void): this;\n        once(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: "online", listener: (worker: Worker) => void): this;\n        once(event: "setup", listener: (settings: any) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "disconnect", listener: (worker: Worker) => void): this;\n        prependListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependListener(event: "fork", listener: (worker: Worker) => void): this;\n        prependListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;\n        prependListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;  // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: "online", listener: (worker: Worker) => void): this;\n        prependListener(event: "setup", listener: (settings: any) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "disconnect", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependOnceListener(event: "fork", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this;\n        prependOnceListener(event: "online", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: "setup", listener: (settings: any) => void): this;\n    }\n\n    function disconnect(callback?: Function): void;\n    function fork(env?: any): Worker;\n    const isMaster: boolean;\n    const isWorker: boolean;\n    // TODO: cluster.schedulingPolicy\n    const settings: ClusterSettings;\n    function setupMaster(settings?: ClusterSettings): void;\n    const worker: Worker;\n    const workers: {\n        [index: string]: Worker | undefined\n    };\n\n    /**\n     * events.EventEmitter\n     *   1. disconnect\n     *   2. exit\n     *   3. fork\n     *   4. listening\n     *   5. message\n     *   6. online\n     *   7. setup\n     */\n    function addListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function addListener(event: "disconnect", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function addListener(event: "fork", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: "listening", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function addListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function addListener(event: "online", listener: (worker: Worker) => void): Cluster;\n    function addListener(event: "setup", listener: (settings: any) => void): Cluster;\n\n    function emit(event: string | symbol, ...args: any[]): boolean;\n    function emit(event: "disconnect", worker: Worker): boolean;\n    function emit(event: "exit", worker: Worker, code: number, signal: string): boolean;\n    function emit(event: "fork", worker: Worker): boolean;\n    function emit(event: "listening", worker: Worker, address: Address): boolean;\n    function emit(event: "message", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n    function emit(event: "online", worker: Worker): boolean;\n    function emit(event: "setup", settings: any): boolean;\n\n    function on(event: string, listener: (...args: any[]) => void): Cluster;\n    function on(event: "disconnect", listener: (worker: Worker) => void): Cluster;\n    function on(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function on(event: "fork", listener: (worker: Worker) => void): Cluster;\n    function on(event: "listening", listener: (worker: Worker, address: Address) => void): Cluster;\n    function on(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function on(event: "online", listener: (worker: Worker) => void): Cluster;\n    function on(event: "setup", listener: (settings: any) => void): Cluster;\n\n    function once(event: string, listener: (...args: any[]) => void): Cluster;\n    function once(event: "disconnect", listener: (worker: Worker) => void): Cluster;\n    function once(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function once(event: "fork", listener: (worker: Worker) => void): Cluster;\n    function once(event: "listening", listener: (worker: Worker, address: Address) => void): Cluster;\n    function once(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;  // the handle is a net.Socket or net.Server object, or undefined.\n    function once(event: "online", listener: (worker: Worker) => void): Cluster;\n    function once(event: "setup", listener: (settings: any) => void): Cluster;\n\n    function removeListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function removeAllListeners(event?: string): Cluster;\n    function setMaxListeners(n: number): Cluster;\n    function getMaxListeners(): number;\n    function listeners(event: string): Function[];\n    function listenerCount(type: string): number;\n\n    function prependListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependListener(event: "disconnect", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependListener(event: "fork", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: "listening", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependListener(event: "online", listener: (worker: Worker) => void): Cluster;\n    function prependListener(event: "setup", listener: (settings: any) => void): Cluster;\n\n    function prependOnceListener(event: string, listener: (...args: any[]) => void): Cluster;\n    function prependOnceListener(event: "disconnect", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): Cluster;\n    function prependOnceListener(event: "fork", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: "listening", listener: (worker: Worker, address: Address) => void): Cluster;\n     // the handle is a net.Socket or net.Server object, or undefined.\n    function prependOnceListener(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): Cluster;\n    function prependOnceListener(event: "online", listener: (worker: Worker) => void): Cluster;\n    function prependOnceListener(event: "setup", listener: (settings: any) => void): Cluster;\n\n    function eventNames(): string[];\n}\n\ndeclare module "zlib" {\n    import * as stream from "stream";\n\n    interface ZlibOptions {\n        flush?: number; // default: zlib.constants.Z_NO_FLUSH\n        finishFlush?: number; // default: zlib.constants.Z_FINISH\n        chunkSize?: number; // default: 16*1024\n        windowBits?: number;\n        level?: number; // compression only\n        memLevel?: number; // compression only\n        strategy?: number; // compression only\n        dictionary?: Buffer | NodeJS.TypedArray | DataView | ArrayBuffer; // deflate/inflate only, empty dictionary by default\n    }\n\n    interface Zlib {\n        readonly bytesRead: number;\n        close(callback?: () => void): void;\n        flush(kind?: number | (() => void), callback?: () => void): void;\n    }\n\n    interface ZlibParams {\n        params(level: number, strategy: number, callback: () => void): void;\n    }\n\n    interface ZlibReset {\n        reset(): void;\n    }\n\n    interface Gzip extends stream.Transform, Zlib { }\n    interface Gunzip extends stream.Transform, Zlib { }\n    interface Deflate extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface Inflate extends stream.Transform, Zlib, ZlibReset { }\n    interface DeflateRaw extends stream.Transform, Zlib, ZlibReset, ZlibParams { }\n    interface InflateRaw extends stream.Transform, Zlib, ZlibReset { }\n    interface Unzip extends stream.Transform, Zlib { }\n\n    function createGzip(options?: ZlibOptions): Gzip;\n    function createGunzip(options?: ZlibOptions): Gunzip;\n    function createDeflate(options?: ZlibOptions): Deflate;\n    function createInflate(options?: ZlibOptions): Inflate;\n    function createDeflateRaw(options?: ZlibOptions): DeflateRaw;\n    function createInflateRaw(options?: ZlibOptions): InflateRaw;\n    function createUnzip(options?: ZlibOptions): Unzip;\n\n    type InputType = string | Buffer | DataView | ArrayBuffer | NodeJS.TypedArray;\n    function deflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function deflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function deflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function gunzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function gunzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflate(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflate(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function inflateRaw(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRaw(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function inflateRawSync(buf: InputType, options?: ZlibOptions): Buffer;\n    function unzip(buf: InputType, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzip(buf: InputType, options: ZlibOptions, callback: (error: Error | null, result: Buffer) => void): void;\n    function unzipSync(buf: InputType, options?: ZlibOptions): Buffer;\n\n    namespace constants {\n        // Allowed flush values.\n\n        const Z_NO_FLUSH: number;\n        const Z_PARTIAL_FLUSH: number;\n        const Z_SYNC_FLUSH: number;\n        const Z_FULL_FLUSH: number;\n        const Z_FINISH: number;\n        const Z_BLOCK: number;\n        const Z_TREES: number;\n\n        // Return codes for the compression/decompression functions. Negative values are errors, positive values are used for special but normal events.\n\n        const Z_OK: number;\n        const Z_STREAM_END: number;\n        const Z_NEED_DICT: number;\n        const Z_ERRNO: number;\n        const Z_STREAM_ERROR: number;\n        const Z_DATA_ERROR: number;\n        const Z_MEM_ERROR: number;\n        const Z_BUF_ERROR: number;\n        const Z_VERSION_ERROR: number;\n\n        // Compression levels.\n\n        const Z_NO_COMPRESSION: number;\n        const Z_BEST_SPEED: number;\n        const Z_BEST_COMPRESSION: number;\n        const Z_DEFAULT_COMPRESSION: number;\n\n        // Compression strategy.\n\n        const Z_FILTERED: number;\n        const Z_HUFFMAN_ONLY: number;\n        const Z_RLE: number;\n        const Z_FIXED: number;\n        const Z_DEFAULT_STRATEGY: number;\n    }\n\n    // Constants\n    const Z_NO_FLUSH: number;\n    const Z_PARTIAL_FLUSH: number;\n    const Z_SYNC_FLUSH: number;\n    const Z_FULL_FLUSH: number;\n    const Z_FINISH: number;\n    const Z_BLOCK: number;\n    const Z_TREES: number;\n    const Z_OK: number;\n    const Z_STREAM_END: number;\n    const Z_NEED_DICT: number;\n    const Z_ERRNO: number;\n    const Z_STREAM_ERROR: number;\n    const Z_DATA_ERROR: number;\n    const Z_MEM_ERROR: number;\n    const Z_BUF_ERROR: number;\n    const Z_VERSION_ERROR: number;\n    const Z_NO_COMPRESSION: number;\n    const Z_BEST_SPEED: number;\n    const Z_BEST_COMPRESSION: number;\n    const Z_DEFAULT_COMPRESSION: number;\n    const Z_FILTERED: number;\n    const Z_HUFFMAN_ONLY: number;\n    const Z_RLE: number;\n    const Z_FIXED: number;\n    const Z_DEFAULT_STRATEGY: number;\n    const Z_BINARY: number;\n    const Z_TEXT: number;\n    const Z_ASCII: number;\n    const Z_UNKNOWN: number;\n    const Z_DEFLATED: number;\n}\n\ndeclare module "os" {\n    interface CpuInfo {\n        model: string;\n        speed: number;\n        times: {\n            user: number;\n            nice: number;\n            sys: number;\n            idle: number;\n            irq: number;\n        };\n    }\n\n    interface NetworkInterfaceBase {\n        address: string;\n        netmask: string;\n        mac: string;\n        internal: boolean;\n        cidr: string | null;\n    }\n\n    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {\n        family: "IPv4";\n    }\n\n    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {\n        family: "IPv6";\n        scopeid: number;\n    }\n\n    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;\n\n    function hostname(): string;\n    function loadavg(): number[];\n    function uptime(): number;\n    function freemem(): number;\n    function totalmem(): number;\n    function cpus(): CpuInfo[];\n    function type(): string;\n    function release(): string;\n    function networkInterfaces(): { [index: string]: NetworkInterfaceInfo[] };\n    function homedir(): string;\n    function userInfo(options?: { encoding: string }): { username: string, uid: number, gid: number, shell: any, homedir: string };\n    const constants: {\n        UV_UDP_REUSEADDR: number;\n        signals: {\n            SIGHUP: number;\n            SIGINT: number;\n            SIGQUIT: number;\n            SIGILL: number;\n            SIGTRAP: number;\n            SIGABRT: number;\n            SIGIOT: number;\n            SIGBUS: number;\n            SIGFPE: number;\n            SIGKILL: number;\n            SIGUSR1: number;\n            SIGSEGV: number;\n            SIGUSR2: number;\n            SIGPIPE: number;\n            SIGALRM: number;\n            SIGTERM: number;\n            SIGCHLD: number;\n            SIGSTKFLT: number;\n            SIGCONT: number;\n            SIGSTOP: number;\n            SIGTSTP: number;\n            SIGTTIN: number;\n            SIGTTOU: number;\n            SIGURG: number;\n            SIGXCPU: number;\n            SIGXFSZ: number;\n            SIGVTALRM: number;\n            SIGPROF: number;\n            SIGWINCH: number;\n            SIGIO: number;\n            SIGPOLL: number;\n            SIGPWR: number;\n            SIGSYS: number;\n            SIGUNUSED: number;\n        };\n        errno: {\n            E2BIG: number;\n            EACCES: number;\n            EADDRINUSE: number;\n            EADDRNOTAVAIL: number;\n            EAFNOSUPPORT: number;\n            EAGAIN: number;\n            EALREADY: number;\n            EBADF: number;\n            EBADMSG: number;\n            EBUSY: number;\n            ECANCELED: number;\n            ECHILD: number;\n            ECONNABORTED: number;\n            ECONNREFUSED: number;\n            ECONNRESET: number;\n            EDEADLK: number;\n            EDESTADDRREQ: number;\n            EDOM: number;\n            EDQUOT: number;\n            EEXIST: number;\n            EFAULT: number;\n            EFBIG: number;\n            EHOSTUNREACH: number;\n            EIDRM: number;\n            EILSEQ: number;\n            EINPROGRESS: number;\n            EINTR: number;\n            EINVAL: number;\n            EIO: number;\n            EISCONN: number;\n            EISDIR: number;\n            ELOOP: number;\n            EMFILE: number;\n            EMLINK: number;\n            EMSGSIZE: number;\n            EMULTIHOP: number;\n            ENAMETOOLONG: number;\n            ENETDOWN: number;\n            ENETRESET: number;\n            ENETUNREACH: number;\n            ENFILE: number;\n            ENOBUFS: number;\n            ENODATA: number;\n            ENODEV: number;\n            ENOENT: number;\n            ENOEXEC: number;\n            ENOLCK: number;\n            ENOLINK: number;\n            ENOMEM: number;\n            ENOMSG: number;\n            ENOPROTOOPT: number;\n            ENOSPC: number;\n            ENOSR: number;\n            ENOSTR: number;\n            ENOSYS: number;\n            ENOTCONN: number;\n            ENOTDIR: number;\n            ENOTEMPTY: number;\n            ENOTSOCK: number;\n            ENOTSUP: number;\n            ENOTTY: number;\n            ENXIO: number;\n            EOPNOTSUPP: number;\n            EOVERFLOW: number;\n            EPERM: number;\n            EPIPE: number;\n            EPROTO: number;\n            EPROTONOSUPPORT: number;\n            EPROTOTYPE: number;\n            ERANGE: number;\n            EROFS: number;\n            ESPIPE: number;\n            ESRCH: number;\n            ESTALE: number;\n            ETIME: number;\n            ETIMEDOUT: number;\n            ETXTBSY: number;\n            EWOULDBLOCK: number;\n            EXDEV: number;\n        };\n        priority: {\n            PRIORITY_LOW: number;\n            PRIORITY_BELOW_NORMAL: number;\n            PRIORITY_NORMAL: number;\n            PRIORITY_ABOVE_NORMAL: number;\n            PRIORITY_HIGH: number;\n            PRIORITY_HIGHEST: number;\n        }\n    };\n    function arch(): string;\n    function platform(): NodeJS.Platform;\n    function tmpdir(): string;\n    const EOL: string;\n    function endianness(): "BE" | "LE";\n    /**\n     * Gets the priority of a process.\n     * Defaults to current process.\n     */\n    function getPriority(pid?: number): number;\n    /**\n     * Sets the priority of the current process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(priority: number): void;\n    /**\n     * Sets the priority of the process specified process.\n     * @param priority Must be in range of -20 to 19\n     */\n    function setPriority(pid: number, priority: number): void;\n}\n\ndeclare module "https" {\n    import * as tls from "tls";\n    import * as events from "events";\n    import * as http from "http";\n    import { URL } from "url";\n\n    type ServerOptions = tls.SecureContextOptions & tls.TlsOptions;\n\n    type RequestOptions = http.RequestOptions & tls.SecureContextOptions & {\n        rejectUnauthorized?: boolean; // Defaults to true\n        servername?: string; // SNI TLS Extension\n    };\n\n    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\n        rejectUnauthorized?: boolean;\n        maxCachedSessions?: number;\n    }\n\n    class Agent extends http.Agent {\n        constructor(options?: AgentOptions);\n        options: AgentOptions;\n    }\n\n    class Server extends tls.Server {\n        setTimeout(callback: () => void): this;\n        setTimeout(msecs?: number, callback?: () => void): this;\n        timeout: number;\n        keepAliveTimeout: number;\n    }\n\n    function createServer(options: ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): Server;\n    function request(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function request(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(options: RequestOptions | string | URL, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: http.IncomingMessage) => void): http.ClientRequest;\n    let globalAgent: Agent;\n}\n\ndeclare module "punycode" {\n    function decode(string: string): string;\n    function encode(string: string): string;\n    function toUnicode(domain: string): string;\n    function toASCII(domain: string): string;\n    const ucs2: ucs2;\n    interface ucs2 {\n        decode(string: string): number[];\n        encode(codePoints: number[]): string;\n    }\n    const version: any;\n}\n\ndeclare module "repl" {\n    import { Interface, Completer, AsyncCompleter } from "readline";\n    import { Context } from "vm";\n    import { InspectOptions } from "util";\n\n    interface ReplOptions {\n        /**\n         * The input prompt to display.\n         * Default: `"> "`\n         */\n        prompt?: string;\n        /**\n         * The `Readable` stream from which REPL input will be read.\n         * Default: `process.stdin`\n         */\n        input?: NodeJS.ReadableStream;\n        /**\n         * The `Writable` stream to which REPL output will be written.\n         * Default: `process.stdout`\n         */\n        output?: NodeJS.WritableStream;\n        /**\n         * If `true`, specifies that the output should be treated as a TTY terminal, and have\n         * ANSI/VT100 escape codes written to it.\n         * Default: checking the value of the `isTTY` property on the output stream upon\n         * instantiation.\n         */\n        terminal?: boolean;\n        /**\n         * The function to be used when evaluating each given line of input.\n         * Default: an async wrapper for the JavaScript `eval()` function. An `eval` function can\n         * error with `repl.Recoverable` to indicate the input was incomplete and prompt for\n         * additional lines.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_default_evaluation\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_custom_evaluation_functions\n         */\n        eval?: REPLEval;\n        /**\n         * If `true`, specifies that the default `writer` function should include ANSI color\n         * styling to REPL output. If a custom `writer` function is provided then this has no\n         * effect.\n         * Default: the REPL instance\'s `terminal` value.\n         */\n        useColors?: boolean;\n        /**\n         * If `true`, specifies that the default evaluation function will use the JavaScript\n         * `global` as the context as opposed to creating a new separate context for the REPL\n         * instance. The node CLI REPL sets this value to `true`.\n         * Default: `false`.\n         */\n        useGlobal?: boolean;\n        /**\n         * If `true`, specifies that the default writer will not output the return value of a\n         * command if it evaluates to `undefined`.\n         * Default: `false`.\n         */\n        ignoreUndefined?: boolean;\n        /**\n         * The function to invoke to format the output of each command before writing to `output`.\n         * Default: a wrapper for `util.inspect`.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_customizing_repl_output\n         */\n        writer?: REPLWriter;\n        /**\n         * An optional function used for custom Tab auto completion.\n         *\n         * @see https://nodejs.org/dist/latest-v11.x/docs/api/readline.html#readline_use_of_the_completer_function\n         */\n        completer?: Completer | AsyncCompleter;\n        /**\n         * A flag that specifies whether the default evaluator executes all JavaScript commands in\n         * strict mode or default (sloppy) mode.\n         * Accepted values are:\n         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.\n         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to\n         *   prefacing every repl statement with `\'use strict\'`.\n         */\n        replMode?: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;\n        /**\n         * Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is\n         * pressed. This cannot be used together with a custom `eval` function.\n         * Default: `false`.\n         */\n        breakEvalOnSigint?: boolean;\n    }\n\n    type REPLEval = (this: REPLServer, evalCmd: string, context: Context, file: string, cb: (err: Error | null, result: any) => void) => void;\n    type REPLWriter = (this: REPLServer, obj: any) => string;\n\n    /**\n     * This is the default "writer" value, if none is passed in the REPL options,\n     * and it can be overridden by custom print functions.\n     */\n    const writer: REPLWriter & { options: InspectOptions };\n\n    type REPLCommandAction = (this: REPLServer, text: string) => void;\n\n    interface REPLCommand {\n        /**\n         * Help text to be displayed when `.help` is entered.\n         */\n        help?: string;\n        /**\n         * The function to execute, optionally accepting a single string argument.\n         */\n        action: REPLCommandAction;\n    }\n\n    /**\n     * Provides a customizable Read-Eval-Print-Loop (REPL).\n     *\n     * Instances of `repl.REPLServer` will accept individual lines of user input, evaluate those\n     * according to a user-defined evaluation function, then output the result. Input and output\n     * may be from `stdin` and `stdout`, respectively, or may be connected to any Node.js `stream`.\n     *\n     * Instances of `repl.REPLServer` support automatic completion of inputs, simplistic Emacs-style\n     * line editing, multi-line inputs, ANSI-styled output, saving and restoring current REPL session\n     * state, error recovery, and customizable evaluation functions.\n     *\n     * Instances of `repl.REPLServer` are created using the `repl.start()` method and _should not_\n     * be created directly using the JavaScript `new` keyword.\n     *\n     * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_repl\n     */\n    class REPLServer extends Interface {\n        /**\n         * The `vm.Context` provided to the `eval` function to be used for JavaScript\n         * evaluation.\n         */\n        readonly context: Context;\n        /**\n         * The `Readable` stream from which REPL input will be read.\n         */\n        readonly inputStream: NodeJS.ReadableStream;\n        /**\n         * The `Writable` stream to which REPL output will be written.\n         */\n        readonly outputStream: NodeJS.WritableStream;\n        /**\n         * The commands registered via `replServer.defineCommand()`.\n         */\n        readonly commands: { readonly [name: string]: REPLCommand | undefined };\n        /**\n         * A value indicating whether the REPL is currently in "editor mode".\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_commands_and_special_keys\n         */\n        readonly editorMode: boolean;\n        /**\n         * A value indicating whether the `_` variable has been assigned.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly underscoreAssigned: boolean;\n        /**\n         * The last evaluation result from the REPL (assigned to the `_` variable inside of the REPL).\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly last: any;\n        /**\n         * A value indicating whether the `_error` variable has been assigned.\n         *\n         * @since v9.8.0\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly underscoreErrAssigned: boolean;\n        /**\n         * The last error raised inside the REPL (assigned to the `_error` variable inside of the REPL).\n         *\n         * @since v9.8.0\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable\n         */\n        readonly lastError: any;\n        /**\n         * Specified in the REPL options, this is the function to be used when evaluating each\n         * given line of input. If not specified in the REPL options, this is an async wrapper\n         * for the JavaScript `eval()` function.\n         */\n        readonly eval: REPLEval;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default\n         * `writer` function should include ANSI color styling to REPL output.\n         */\n        readonly useColors: boolean;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default `eval`\n         * function will use the JavaScript `global` as the context as opposed to creating a new\n         * separate context for the REPL instance.\n         */\n        readonly useGlobal: boolean;\n        /**\n         * Specified in the REPL options, this is a value indicating whether the default `writer`\n         * function should output the result of a command if it evaluates to `undefined`.\n         */\n        readonly ignoreUndefined: boolean;\n        /**\n         * Specified in the REPL options, this is the function to invoke to format the output of\n         * each command before writing to `outputStream`. If not specified in the REPL options,\n         * this will be a wrapper for `util.inspect`.\n         */\n        readonly writer: REPLWriter;\n        /**\n         * Specified in the REPL options, this is the function to use for custom Tab auto-completion.\n         */\n        readonly completer: Completer | AsyncCompleter;\n        /**\n         * Specified in the REPL options, this is a flag that specifies whether the default `eval`\n         * function should execute all JavaScript commands in strict mode or default (sloppy) mode.\n         * Possible values are:\n         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.\n         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to\n         *    prefacing every repl statement with `\'use strict\'`.\n         */\n        readonly replMode: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;\n\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of `repl.REPLServer` are created using the `repl.start()` method and\n         * > _should not_ be created directly using the JavaScript `new` keyword.\n         *\n         * `REPLServer` cannot be subclassed due to implementation specifics in NodeJS.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_class_replserver\n         */\n        private constructor();\n\n        /**\n         * Used to add new `.`-prefixed commands to the REPL instance. Such commands are invoked\n         * by typing a `.` followed by the `keyword`.\n         *\n         * @param keyword The command keyword (_without_ a leading `.` character).\n         * @param cmd The function to invoke when the command is processed.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_replserver_definecommand_keyword_cmd\n         */\n        defineCommand(keyword: string, cmd: REPLCommandAction | REPLCommand): void;\n        /**\n         * Readies the REPL instance for input from the user, printing the configured `prompt` to a\n         * new line in the `output` and resuming the `input` to accept new input.\n         *\n         * When multi-line input is being entered, an ellipsis is printed rather than the \'prompt\'.\n         *\n         * This method is primarily intended to be called from within the action function for\n         * commands registered using the `replServer.defineCommand()` method.\n         *\n         * @param preserveCursor When `true`, the cursor placement will not be reset to `0`.\n         */\n        displayPrompt(preserveCursor?: boolean): void;\n        /**\n         * Clears any command that has been buffered but not yet executed.\n         *\n         * This method is primarily intended to be called from within the action function for\n         * commands registered using the `replServer.defineCommand()` method.\n         *\n         * @since v9.0.0\n         */\n        clearBufferedCommand(): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close - inherited from `readline.Interface`\n         * 2. line - inherited from `readline.Interface`\n         * 3. pause - inherited from `readline.Interface`\n         * 4. resume - inherited from `readline.Interface`\n         * 5. SIGCONT - inherited from `readline.Interface`\n         * 6. SIGINT - inherited from `readline.Interface`\n         * 7. SIGTSTP - inherited from `readline.Interface`\n         * 8. exit\n         * 9. reset\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "line", listener: (input: string) => void): this;\n        addListener(event: "pause", listener: () => void): this;\n        addListener(event: "resume", listener: () => void): this;\n        addListener(event: "SIGCONT", listener: () => void): this;\n        addListener(event: "SIGINT", listener: () => void): this;\n        addListener(event: "SIGTSTP", listener: () => void): this;\n        addListener(event: "exit", listener: () => void): this;\n        addListener(event: "reset", listener: (context: Context) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "line", input: string): boolean;\n        emit(event: "pause"): boolean;\n        emit(event: "resume"): boolean;\n        emit(event: "SIGCONT"): boolean;\n        emit(event: "SIGINT"): boolean;\n        emit(event: "SIGTSTP"): boolean;\n        emit(event: "exit"): boolean;\n        emit(event: "reset", context: Context): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "line", listener: (input: string) => void): this;\n        on(event: "pause", listener: () => void): this;\n        on(event: "resume", listener: () => void): this;\n        on(event: "SIGCONT", listener: () => void): this;\n        on(event: "SIGINT", listener: () => void): this;\n        on(event: "SIGTSTP", listener: () => void): this;\n        on(event: "exit", listener: () => void): this;\n        on(event: "reset", listener: (context: Context) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "line", listener: (input: string) => void): this;\n        once(event: "pause", listener: () => void): this;\n        once(event: "resume", listener: () => void): this;\n        once(event: "SIGCONT", listener: () => void): this;\n        once(event: "SIGINT", listener: () => void): this;\n        once(event: "SIGTSTP", listener: () => void): this;\n        once(event: "exit", listener: () => void): this;\n        once(event: "reset", listener: (context: Context) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "line", listener: (input: string) => void): this;\n        prependListener(event: "pause", listener: () => void): this;\n        prependListener(event: "resume", listener: () => void): this;\n        prependListener(event: "SIGCONT", listener: () => void): this;\n        prependListener(event: "SIGINT", listener: () => void): this;\n        prependListener(event: "SIGTSTP", listener: () => void): this;\n        prependListener(event: "exit", listener: () => void): this;\n        prependListener(event: "reset", listener: (context: Context) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "line", listener: (input: string) => void): this;\n        prependOnceListener(event: "pause", listener: () => void): this;\n        prependOnceListener(event: "resume", listener: () => void): this;\n        prependOnceListener(event: "SIGCONT", listener: () => void): this;\n        prependOnceListener(event: "SIGINT", listener: () => void): this;\n        prependOnceListener(event: "SIGTSTP", listener: () => void): this;\n        prependOnceListener(event: "exit", listener: () => void): this;\n        prependOnceListener(event: "reset", listener: (context: Context) => void): this;\n    }\n\n    /**\n     * A flag passed in the REPL options. Evaluates expressions in sloppy mode.\n     */\n    export const REPL_MODE_SLOPPY: symbol; // TODO: unique symbol\n\n    /**\n     * A flag passed in the REPL options. Evaluates expressions in strict mode.\n     * This is equivalent to prefacing every repl statement with `\'use strict\'`.\n     */\n    export const REPL_MODE_STRICT: symbol; // TODO: unique symbol\n\n    /**\n     * Creates and starts a `repl.REPLServer` instance.\n     *\n     * @param options The options for the `REPLServer`. If `options` is a string, then it specifies\n     * the input prompt.\n     */\n    function start(options?: string | ReplOptions): REPLServer;\n\n    /**\n     * Indicates a recoverable error that a `REPLServer` can use to support multi-line input.\n     *\n     * @see https://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_recoverable_errors\n     */\n    class Recoverable extends SyntaxError {\n        err: Error;\n\n        constructor(err: Error);\n    }\n}\n\ndeclare module "readline" {\n    import * as events from "events";\n    import * as stream from "stream";\n\n    interface Key {\n        sequence?: string;\n        name?: string;\n        ctrl?: boolean;\n        meta?: boolean;\n        shift?: boolean;\n    }\n\n    class Interface extends events.EventEmitter {\n        readonly terminal: boolean;\n\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface\n         */\n        protected constructor(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean);\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface\n         */\n        protected constructor(options: ReadLineOptions);\n\n        setPrompt(prompt: string): void;\n        prompt(preserveCursor?: boolean): void;\n        question(query: string, callback: (answer: string) => void): void;\n        pause(): this;\n        resume(): this;\n        close(): void;\n        write(data: string | Buffer, key?: Key): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. line\n         * 3. pause\n         * 4. resume\n         * 5. SIGCONT\n         * 6. SIGINT\n         * 7. SIGTSTP\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "line", listener: (input: string) => void): this;\n        addListener(event: "pause", listener: () => void): this;\n        addListener(event: "resume", listener: () => void): this;\n        addListener(event: "SIGCONT", listener: () => void): this;\n        addListener(event: "SIGINT", listener: () => void): this;\n        addListener(event: "SIGTSTP", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "line", input: string): boolean;\n        emit(event: "pause"): boolean;\n        emit(event: "resume"): boolean;\n        emit(event: "SIGCONT"): boolean;\n        emit(event: "SIGINT"): boolean;\n        emit(event: "SIGTSTP"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "line", listener: (input: string) => void): this;\n        on(event: "pause", listener: () => void): this;\n        on(event: "resume", listener: () => void): this;\n        on(event: "SIGCONT", listener: () => void): this;\n        on(event: "SIGINT", listener: () => void): this;\n        on(event: "SIGTSTP", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "line", listener: (input: string) => void): this;\n        once(event: "pause", listener: () => void): this;\n        once(event: "resume", listener: () => void): this;\n        once(event: "SIGCONT", listener: () => void): this;\n        once(event: "SIGINT", listener: () => void): this;\n        once(event: "SIGTSTP", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "line", listener: (input: string) => void): this;\n        prependListener(event: "pause", listener: () => void): this;\n        prependListener(event: "resume", listener: () => void): this;\n        prependListener(event: "SIGCONT", listener: () => void): this;\n        prependListener(event: "SIGINT", listener: () => void): this;\n        prependListener(event: "SIGTSTP", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "line", listener: (input: string) => void): this;\n        prependOnceListener(event: "pause", listener: () => void): this;\n        prependOnceListener(event: "resume", listener: () => void): this;\n        prependOnceListener(event: "SIGCONT", listener: () => void): this;\n        prependOnceListener(event: "SIGINT", listener: () => void): this;\n        prependOnceListener(event: "SIGTSTP", listener: () => void): this;\n    }\n\n    type ReadLine = Interface; // type forwarded for backwards compatiblity\n\n    type Completer = (line: string) => CompleterResult;\n    type AsyncCompleter = (line: string, callback: (err: any, result: CompleterResult) => void) => any;\n\n    type CompleterResult = [string[], string];\n\n    interface ReadLineOptions {\n        input: NodeJS.ReadableStream;\n        output?: NodeJS.WritableStream;\n        completer?: Completer | AsyncCompleter;\n        terminal?: boolean;\n        historySize?: number;\n        prompt?: string;\n        crlfDelay?: number;\n        removeHistoryDuplicates?: boolean;\n    }\n\n    function createInterface(input: NodeJS.ReadableStream, output?: NodeJS.WritableStream, completer?: Completer | AsyncCompleter, terminal?: boolean): Interface;\n    function createInterface(options: ReadLineOptions): Interface;\n\n    function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number): void;\n    function emitKeypressEvents(stream: NodeJS.ReadableStream, interface?: Interface): void;\n    function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void;\n    function clearLine(stream: NodeJS.WritableStream, dir: number): void;\n    function clearScreenDown(stream: NodeJS.WritableStream): void;\n}\n\ndeclare module "vm" {\n    interface Context {\n        [key: string]: any;\n    }\n    interface BaseOptions {\n        /**\n         * Specifies the filename used in stack traces produced by this script.\n         * Default: `\'\'`.\n         */\n        filename?: string;\n        /**\n         * Specifies the line number offset that is displayed in stack traces produced by this script.\n         * Default: `0`.\n         */\n        lineOffset?: number;\n        /**\n         * Specifies the column number offset that is displayed in stack traces produced by this script.\n         * Default: `0`\n         */\n        columnOffset?: number;\n    }\n    interface ScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n        cachedData?: Buffer;\n        produceCachedData?: boolean;\n    }\n    interface RunningScriptOptions extends BaseOptions {\n        displayErrors?: boolean;\n        timeout?: number;\n    }\n    interface CompileFunctionOptions extends BaseOptions {\n        /**\n         * Provides an optional data with V8\'s code cache data for the supplied source.\n         */\n        cachedData?: Buffer;\n        /**\n         * Specifies whether to produce new cache data.\n         * Default: `false`,\n         */\n        produceCachedData?: boolean;\n        /**\n         * The sandbox/context in which the said function should be compiled in.\n         */\n        parsingContext?: Context;\n\n        /**\n         * An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling\n         */\n        contextExtensions?: Object[];\n    }\n    class Script {\n        constructor(code: string, options?: ScriptOptions);\n        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;\n        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;\n        runInThisContext(options?: RunningScriptOptions): any;\n    }\n    function createContext(sandbox?: Context): Context;\n    function isContext(sandbox: Context): boolean;\n    function runInContext(code: string, contextifiedSandbox: Context, options?: RunningScriptOptions | string): any;\n    function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions | string): any;\n    function runInThisContext(code: string, options?: RunningScriptOptions | string): any;\n    function compileFunction(code: string, params: string[], options: CompileFunctionOptions): Function;\n}\n\ndeclare module "child_process" {\n    import * as events from "events";\n    import * as stream from "stream";\n    import * as net from "net";\n\n    interface ChildProcess extends events.EventEmitter {\n        stdin: stream.Writable;\n        stdout: stream.Readable;\n        stderr: stream.Readable;\n        stdio: [stream.Writable, stream.Readable, stream.Readable];\n        killed: boolean;\n        pid: number;\n        kill(signal?: string): void;\n        send(message: any, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, callback?: (error: Error) => void): boolean;\n        send(message: any, sendHandle?: net.Socket | net.Server, options?: MessageOptions, callback?: (error: Error) => void): boolean;\n        connected: boolean;\n        disconnect(): void;\n        unref(): void;\n        ref(): void;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. disconnect\n         * 3. error\n         * 4. exit\n         * 5. message\n         */\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: (code: number, signal: string) => void): this;\n        addListener(event: "disconnect", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "exit", listener: (code: number | null, signal: string | null) => void): this;\n        addListener(event: "message", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close", code: number, signal: string): boolean;\n        emit(event: "disconnect"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "exit", code: number | null, signal: string | null): boolean;\n        emit(event: "message", message: any, sendHandle: net.Socket | net.Server): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: (code: number, signal: string) => void): this;\n        on(event: "disconnect", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "exit", listener: (code: number | null, signal: string | null) => void): this;\n        on(event: "message", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: (code: number, signal: string) => void): this;\n        once(event: "disconnect", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "exit", listener: (code: number | null, signal: string | null) => void): this;\n        once(event: "message", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: (code: number, signal: string) => void): this;\n        prependListener(event: "disconnect", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "exit", listener: (code: number | null, signal: string | null) => void): this;\n        prependListener(event: "message", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: "disconnect", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "exit", listener: (code: number | null, signal: string | null) => void): this;\n        prependOnceListener(event: "message", listener: (message: any, sendHandle: net.Socket | net.Server) => void): this;\n    }\n\n    interface MessageOptions {\n        keepOpen?: boolean;\n    }\n\n    type StdioOptions = "pipe" | "ignore" | "inherit" | Array<("pipe" | "ipc" | "ignore" | "inherit" | stream.Stream | number | null | undefined)>;\n\n    interface SpawnOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        argv0?: string;\n        stdio?: StdioOptions;\n        detached?: boolean;\n        uid?: number;\n        gid?: number;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n\n    function spawn(command: string, options?: SpawnOptions): ChildProcess;\n    function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;\n\n    interface ExecOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n    }\n\n    interface ExecOptionsWithStringEncoding extends ExecOptions {\n        encoding: BufferEncoding;\n    }\n\n    interface ExecOptionsWithBufferEncoding extends ExecOptions {\n        encoding: string | null; // specify `null`.\n    }\n\n    interface ExecException extends Error {\n        cmd?: string;\n        killed?: boolean;\n        code?: number;\n        signal?: string;\n    }\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function exec(command: string, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function exec(command: string, options: { encoding: "buffer" | null } & ExecOptions, callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: { encoding: BufferEncoding } & ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function exec(command: string, options: { encoding: string } & ExecOptions, callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function exec(command: string, options: ExecOptions, callback?: (error: ExecException | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function exec(\n        command: string,\n        options: ({ encoding?: string | null } & ExecOptions) | undefined | null,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exec {\n        function __promisify__(command: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: { encoding: "buffer" | null } & ExecOptions): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(command: string, options: { encoding: BufferEncoding } & ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options: ExecOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(command: string, options?: ({ encoding?: string | null } & ExecOptions) | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ExecFileOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        timeout?: number;\n        maxBuffer?: number;\n        killSignal?: string;\n        uid?: number;\n        gid?: number;\n        windowsHide?: boolean;\n        windowsVerbatimArguments?: boolean;\n    }\n    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\n        encoding: \'buffer\' | null;\n    }\n    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\n        encoding: string;\n    }\n\n    function execFile(file: string): ChildProcess;\n    function execFile(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n    function execFile(file: string, args?: ReadonlyArray<string> | null): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): ChildProcess;\n\n    // no `options` definitely means stdout/stderr are `string`.\n    function execFile(file: string, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function execFile(file: string, options: ExecFileOptionsWithBufferEncoding, callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: Error | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptionsWithStringEncoding, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: Error | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function execFile(file: string, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n    function execFile(file: string, args: ReadonlyArray<string> | undefined | null, options: ExecFileOptions, callback: (error: Error | null, stdout: string, stderr: string) => void): ChildProcess;\n\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function execFile(\n        file: string,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: ReadonlyArray<string> | undefined | null,\n        options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        callback: ((error: Error | null, stdout: string | Buffer, stderr: string | Buffer) => void) | undefined | null,\n    ): ChildProcess;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace execFile {\n        function __promisify__(file: string): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithBufferEncoding): Promise<{ stdout: Buffer, stderr: Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithStringEncoding): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptionsWithOtherEncoding): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(file: string, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, args: string[] | undefined | null, options: ExecFileOptions): Promise<{ stdout: string, stderr: string }>;\n        function __promisify__(file: string, options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n        function __promisify__(\n            file: string,\n            args: string[] | undefined | null,\n            options: ({ encoding?: string | null } & ExecFileOptions) | undefined | null,\n        ): Promise<{ stdout: string | Buffer, stderr: string | Buffer }>;\n    }\n\n    interface ForkOptions {\n        cwd?: string;\n        env?: NodeJS.ProcessEnv;\n        execPath?: string;\n        execArgv?: string[];\n        silent?: boolean;\n        stdio?: StdioOptions;\n        windowsVerbatimArguments?: boolean;\n        uid?: number;\n        gid?: number;\n    }\n    function fork(modulePath: string, args?: ReadonlyArray<string>, options?: ForkOptions): ChildProcess;\n\n    interface SpawnSyncOptions {\n        argv0?: string; // Not specified in the docs\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        shell?: boolean | string;\n        windowsVerbatimArguments?: boolean;\n        windowsHide?: boolean;\n    }\n    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    interface SpawnSyncReturns<T> {\n        pid: number;\n        output: string[];\n        stdout: T;\n        stderr: T;\n        status: number;\n        signal: string;\n        error: Error;\n    }\n    function spawnSync(command: string): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, args?: ReadonlyArray<string>, options?: SpawnSyncOptions): SpawnSyncReturns<Buffer>;\n\n    interface ExecSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | Uint8Array;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        shell?: string;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n    }\n    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execSync(command: string): Buffer;\n    function execSync(command: string, options?: ExecSyncOptionsWithStringEncoding): string;\n    function execSync(command: string, options?: ExecSyncOptionsWithBufferEncoding): Buffer;\n    function execSync(command: string, options?: ExecSyncOptions): Buffer;\n\n    interface ExecFileSyncOptions {\n        cwd?: string;\n        input?: string | Buffer | NodeJS.TypedArray | DataView;\n        stdio?: StdioOptions;\n        env?: NodeJS.ProcessEnv;\n        uid?: number;\n        gid?: number;\n        timeout?: number;\n        killSignal?: string | number;\n        maxBuffer?: number;\n        encoding?: string;\n        windowsHide?: boolean;\n        shell?: boolean | string;\n    }\n    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\n        encoding: string; // specify `null`.\n    }\n    function execFileSync(command: string): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, options?: ExecFileSyncOptions): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(command: string, args?: ReadonlyArray<string>, options?: ExecFileSyncOptions): Buffer;\n}\n\ndeclare module "url" {\n    import { ParsedUrlQuery } from \'querystring\';\n\n    interface UrlObjectCommon {\n        auth?: string;\n        hash?: string;\n        host?: string;\n        hostname?: string;\n        href?: string;\n        path?: string;\n        pathname?: string;\n        protocol?: string;\n        search?: string;\n        slashes?: boolean;\n    }\n\n    // Input to `url.format`\n    interface UrlObject extends UrlObjectCommon {\n        port?: string | number;\n        query?: string | null | { [key: string]: any };\n    }\n\n    // Output of `url.parse`\n    interface Url extends UrlObjectCommon {\n        port?: string;\n        query?: string | null | ParsedUrlQuery;\n    }\n\n    interface UrlWithParsedQuery extends Url {\n        query: ParsedUrlQuery;\n    }\n\n    interface UrlWithStringQuery extends Url {\n        query: string | null;\n    }\n\n    function parse(urlStr: string): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: false | undefined, slashesDenoteHost?: boolean): UrlWithStringQuery;\n    function parse(urlStr: string, parseQueryString: true, slashesDenoteHost?: boolean): UrlWithParsedQuery;\n    function parse(urlStr: string, parseQueryString: boolean, slashesDenoteHost?: boolean): Url;\n\n    function format(URL: URL, options?: URLFormatOptions): string;\n    function format(urlObject: UrlObject | string): string;\n    function resolve(from: string, to: string): string;\n\n    function domainToASCII(domain: string): string;\n    function domainToUnicode(domain: string): string;\n\n    /**\n     * This function ensures the correct decodings of percent-encoded characters as\n     * well as ensuring a cross-platform valid absolute path string.\n     * @param url The file URL string or URL object to convert to a path.\n     */\n    function fileURLToPath(url: string | URL): string;\n\n    /**\n     * This function ensures that path is resolved absolutely, and that the URL\n     * control characters are correctly encoded when converting into a File URL.\n     * @param url The path to convert to a File URL.\n     */\n    function pathToFileURL(url: string): URL;\n\n    interface URLFormatOptions {\n        auth?: boolean;\n        fragment?: boolean;\n        search?: boolean;\n        unicode?: boolean;\n    }\n\n    class URL {\n        constructor(input: string, base?: string | URL);\n        hash: string;\n        host: string;\n        hostname: string;\n        href: string;\n        readonly origin: string;\n        password: string;\n        pathname: string;\n        port: string;\n        protocol: string;\n        search: string;\n        readonly searchParams: URLSearchParams;\n        username: string;\n        toString(): string;\n        toJSON(): string;\n    }\n\n    class URLSearchParams implements Iterable<[string, string]> {\n        constructor(init?: URLSearchParams | string | { [key: string]: string | string[] | undefined } | Iterable<[string, string]> | Array<[string, string]>);\n        append(name: string, value: string): void;\n        delete(name: string): void;\n        entries(): IterableIterator<[string, string]>;\n        forEach(callback: (value: string, name: string, searchParams: this) => void): void;\n        get(name: string): string | null;\n        getAll(name: string): string[];\n        has(name: string): boolean;\n        keys(): IterableIterator<string>;\n        set(name: string, value: string): void;\n        sort(): void;\n        toString(): string;\n        values(): IterableIterator<string>;\n        [Symbol.iterator](): IterableIterator<[string, string]>;\n    }\n}\n\ndeclare module "dns" {\n    // Supported getaddrinfo flags.\n    const ADDRCONFIG: number;\n    const V4MAPPED: number;\n\n    interface LookupOptions {\n        family?: number;\n        hints?: number;\n        all?: boolean;\n        verbatim?: boolean;\n    }\n\n    interface LookupOneOptions extends LookupOptions {\n        all?: false;\n    }\n\n    interface LookupAllOptions extends LookupOptions {\n        all: true;\n    }\n\n    interface LookupAddress {\n        address: string;\n        family: number;\n    }\n\n    function lookup(hostname: string, family: number, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n    function lookup(hostname: string, options: LookupAllOptions, callback: (err: NodeJS.ErrnoException, addresses: LookupAddress[]) => void): void;\n    function lookup(hostname: string, options: LookupOptions, callback: (err: NodeJS.ErrnoException, address: string | LookupAddress[], family: number) => void): void;\n    function lookup(hostname: string, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lookup {\n        function __promisify__(hostname: string, options: LookupAllOptions): Promise<{ address: LookupAddress[] }>;\n        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<{ address: string, family: number }>;\n        function __promisify__(hostname: string, options?: LookupOptions | number): Promise<{ address: string | LookupAddress[], family?: number }>;\n    }\n\n    function lookupService(address: string, port: number, callback: (err: NodeJS.ErrnoException, hostname: string, service: string) => void): void;\n\n    namespace lookupService {\n        function __promisify__(address: string, port: number): Promise<{ hostname: string, service: string }>;\n    }\n\n    interface ResolveOptions {\n        ttl: boolean;\n    }\n\n    interface ResolveWithTtlOptions extends ResolveOptions {\n        ttl: true;\n    }\n\n    interface RecordWithTtl {\n        address: string;\n        ttl: number;\n    }\n\n    /** @deprecated Use AnyARecord or AnyAaaaRecord instead. */\n    type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;\n\n    interface AnyARecord extends RecordWithTtl {\n        type: "A";\n    }\n\n    interface AnyAaaaRecord extends RecordWithTtl {\n        type: "AAAA";\n    }\n\n    interface MxRecord {\n        priority: number;\n        exchange: string;\n    }\n\n    interface AnyMxRecord extends MxRecord {\n        type: "MX";\n    }\n\n    interface NaptrRecord {\n        flags: string;\n        service: string;\n        regexp: string;\n        replacement: string;\n        order: number;\n        preference: number;\n    }\n\n    interface AnyNaptrRecord extends NaptrRecord {\n        type: "NAPTR";\n    }\n\n    interface SoaRecord {\n        nsname: string;\n        hostmaster: string;\n        serial: number;\n        refresh: number;\n        retry: number;\n        expire: number;\n        minttl: number;\n    }\n\n    interface AnySoaRecord extends SoaRecord {\n        type: "SOA";\n    }\n\n    interface SrvRecord {\n        priority: number;\n        weight: number;\n        port: number;\n        name: string;\n    }\n\n    interface AnySrvRecord extends SrvRecord {\n        type: "SRV";\n    }\n\n    interface AnyTxtRecord {\n        type: "TXT";\n        entries: string[];\n    }\n\n    interface AnyNsRecord {\n        type: "NS";\n        value: string;\n    }\n\n    interface AnyPtrRecord {\n        type: "PTR";\n        value: string;\n    }\n\n    interface AnyCnameRecord {\n        type: "CNAME";\n        value: string;\n    }\n\n    type AnyRecord = AnyARecord |\n        AnyAaaaRecord |\n        AnyCnameRecord |\n        AnyMxRecord |\n        AnyNaptrRecord |\n        AnyNsRecord |\n        AnyPtrRecord |\n        AnySoaRecord |\n        AnySrvRecord |\n        AnyTxtRecord;\n\n    function resolve(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "A", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "AAAA", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "ANY", callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: "CNAME", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "MX", callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: "NAPTR", callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: "NS", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "PTR", callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve(hostname: string, rrtype: "SOA", callback: (err: NodeJS.ErrnoException, addresses: SoaRecord) => void): void;\n    function resolve(hostname: string, rrtype: "SRV", callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    function resolve(hostname: string, rrtype: "TXT", callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    function resolve(\n        hostname: string,\n        rrtype: string,\n        callback: (err: NodeJS.ErrnoException, addresses: string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve {\n        function __promisify__(hostname: string, rrtype?: "A" | "AAAA" | "CNAME" | "NS" | "PTR"): Promise<string[]>;\n        function __promisify__(hostname: string, rrtype: "ANY"): Promise<AnyRecord[]>;\n        function __promisify__(hostname: string, rrtype: "MX"): Promise<MxRecord[]>;\n        function __promisify__(hostname: string, rrtype: "NAPTR"): Promise<NaptrRecord[]>;\n        function __promisify__(hostname: string, rrtype: "SOA"): Promise<SoaRecord>;\n        function __promisify__(hostname: string, rrtype: "SRV"): Promise<SrvRecord[]>;\n        function __promisify__(hostname: string, rrtype: "TXT"): Promise<string[][]>;\n        function __promisify__(hostname: string, rrtype: string): Promise<string[] | MxRecord[] | NaptrRecord[] | SoaRecord | SrvRecord[] | string[][] | AnyRecord[]>;\n    }\n\n    function resolve4(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve4(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve4(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve4 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolve6(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    function resolve6(hostname: string, options: ResolveWithTtlOptions, callback: (err: NodeJS.ErrnoException, addresses: RecordWithTtl[]) => void): void;\n    function resolve6(hostname: string, options: ResolveOptions, callback: (err: NodeJS.ErrnoException, addresses: string[] | RecordWithTtl[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace resolve6 {\n        function __promisify__(hostname: string): Promise<string[]>;\n        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;\n        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;\n    }\n\n    function resolveCname(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveCname {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveMx(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: MxRecord[]) => void): void;\n    namespace resolveMx {\n        function __promisify__(hostname: string): Promise<MxRecord[]>;\n    }\n\n    function resolveNaptr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: NaptrRecord[]) => void): void;\n    namespace resolveNaptr {\n        function __promisify__(hostname: string): Promise<NaptrRecord[]>;\n    }\n\n    function resolveNs(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolveNs {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolvePtr(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[]) => void): void;\n    namespace resolvePtr {\n        function __promisify__(hostname: string): Promise<string[]>;\n    }\n\n    function resolveSoa(hostname: string, callback: (err: NodeJS.ErrnoException, address: SoaRecord) => void): void;\n    namespace resolveSoa {\n        function __promisify__(hostname: string): Promise<SoaRecord>;\n    }\n\n    function resolveSrv(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: SrvRecord[]) => void): void;\n    namespace resolveSrv {\n        function __promisify__(hostname: string): Promise<SrvRecord[]>;\n    }\n\n    function resolveTxt(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: string[][]) => void): void;\n    namespace resolveTxt {\n        function __promisify__(hostname: string): Promise<string[][]>;\n    }\n\n    function resolveAny(hostname: string, callback: (err: NodeJS.ErrnoException, addresses: AnyRecord[]) => void): void;\n    namespace resolveAny {\n        function __promisify__(hostname: string): Promise<AnyRecord[]>;\n    }\n\n    function reverse(ip: string, callback: (err: NodeJS.ErrnoException, hostnames: string[]) => void): void;\n    function setServers(servers: string[]): void;\n    function getServers(): string[];\n\n    // Error codes\n    const NODATA: string;\n    const FORMERR: string;\n    const SERVFAIL: string;\n    const NOTFOUND: string;\n    const NOTIMP: string;\n    const REFUSED: string;\n    const BADQUERY: string;\n    const BADNAME: string;\n    const BADFAMILY: string;\n    const BADRESP: string;\n    const CONNREFUSED: string;\n    const TIMEOUT: string;\n    const EOF: string;\n    const FILE: string;\n    const NOMEM: string;\n    const DESTRUCTION: string;\n    const BADSTR: string;\n    const BADFLAGS: string;\n    const NONAME: string;\n    const BADHINTS: string;\n    const NOTINITIALIZED: string;\n    const LOADIPHLPAPI: string;\n    const ADDRGETNETWORKPARAMS: string;\n    const CANCELLED: string;\n\n    class Resolver {\n        getServers: typeof getServers;\n        setServers: typeof setServers;\n        resolve: typeof resolve;\n        resolve4: typeof resolve4;\n        resolve6: typeof resolve6;\n        resolveAny: typeof resolveAny;\n        resolveCname: typeof resolveCname;\n        resolveMx: typeof resolveMx;\n        resolveNaptr: typeof resolveNaptr;\n        resolveNs: typeof resolveNs;\n        resolvePtr: typeof resolvePtr;\n        resolveSoa: typeof resolveSoa;\n        resolveSrv: typeof resolveSrv;\n        resolveTxt: typeof resolveTxt;\n        reverse: typeof reverse;\n        cancel(): void;\n    }\n}\n\ndeclare module "net" {\n    import * as stream from "stream";\n    import * as events from "events";\n    import * as dns from "dns";\n\n    type LookupFunction = (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface TcpSocketConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Buffer): boolean;\n        write(buffer: Buffer, cb?: Function): boolean;\n        write(str: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, cb?: Function): boolean;\n        write(str: string, encoding?: string, fd?: string): boolean;\n        write(data: any, encoding?: string, callback?: Function): void;\n\n        connect(options: SocketConnectOpts, connectionListener?: Function): this;\n        connect(port: number, host: string, connectionListener?: Function): this;\n        connect(port: number, connectionListener?: Function): this;\n        connect(path: string, connectionListener?: Function): this;\n\n        setEncoding(encoding?: string): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: Function): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | string;\n        unref(): void;\n        ref(): void;\n\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(): void;\n        end(buffer: Buffer, cb?: Function): void;\n        end(str: string, cb?: Function): void;\n        end(str: string, encoding?: string, cb?: Function): void;\n        end(data?: any, encoding?: string): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: (had_error: boolean) => void): this;\n        addListener(event: "connect", listener: () => void): this;\n        addListener(event: "data", listener: (data: Buffer) => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "end", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close", had_error: boolean): boolean;\n        emit(event: "connect"): boolean;\n        emit(event: "data", data: Buffer): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "end"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: "timeout"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: (had_error: boolean) => void): this;\n        on(event: "connect", listener: () => void): this;\n        on(event: "data", listener: (data: Buffer) => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "end", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: "timeout", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: (had_error: boolean) => void): this;\n        once(event: "connect", listener: () => void): this;\n        once(event: "data", listener: (data: Buffer) => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "end", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: "timeout", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependListener(event: "connect", listener: () => void): this;\n        prependListener(event: "data", listener: (data: Buffer) => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "end", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: "connect", listener: () => void): this;\n        prependOnceListener(event: "data", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "end", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends events.EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, hostname?: string, listeningListener?: Function): this;\n        listen(port?: number, backlog?: number, listeningListener?: Function): this;\n        listen(port?: number, listeningListener?: Function): this;\n        listen(path: string, backlog?: number, listeningListener?: Function): this;\n        listen(path: string, listeningListener?: Function): this;\n        listen(options: ListenOptions, listeningListener?: Function): this;\n        listen(handle: any, backlog?: number, listeningListener?: Function): this;\n        listen(handle: any, listeningListener?: Function): this;\n        close(callback?: Function): this;\n        address(): AddressInfo | string;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "connection", listener: (socket: Socket) => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "listening", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "connection", socket: Socket): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "listening"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "connection", listener: (socket: Socket) => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "listening", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "connection", listener: (socket: Socket) => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "listening", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "listening", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "listening", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: { allowHalfOpen?: boolean, pauseOnConnect?: boolean }, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function connect(port: number, host?: string, connectionListener?: Function): Socket;\n    function connect(path: string, connectionListener?: Function): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: Function): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: Function): Socket;\n    function createConnection(path: string, connectionListener?: Function): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}\n\ndeclare module "dgram" {\n    import { AddressInfo } from "net";\n    import * as dns from "dns";\n    import * as events from "events";\n\n    interface RemoteInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface BindOptions {\n        port: number;\n        address?: string;\n        exclusive?: boolean;\n    }\n\n    type SocketType = "udp4" | "udp6";\n\n    interface SocketOptions {\n        type: SocketType;\n        reuseAddr?: boolean;\n        recvBufferSize?: number;\n        sendBufferSize?: number;\n        lookup?: (hostname: string, options: dns.LookupOneOptions, callback: (err: NodeJS.ErrnoException, address: string, family: number) => void) => void;\n    }\n\n    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n\n    class Socket extends events.EventEmitter {\n        send(msg: Buffer | string | Uint8Array | any[], port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        send(msg: Buffer | string | Uint8Array, offset: number, length: number, port: number, address?: string, callback?: (error: Error | null, bytes: number) => void): void;\n        bind(port?: number, address?: string, callback?: () => void): void;\n        bind(port?: number, callback?: () => void): void;\n        bind(callback?: () => void): void;\n        bind(options: BindOptions, callback?: Function): void;\n        close(callback?: () => void): void;\n        address(): AddressInfo | string;\n        setBroadcast(flag: boolean): void;\n        setTTL(ttl: number): void;\n        setMulticastTTL(ttl: number): void;\n        setMulticastInterface(multicastInterface: string): void;\n        setMulticastLoopback(flag: boolean): void;\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\n        ref(): this;\n        unref(): this;\n        setRecvBufferSize(size: number): void;\n        setSendBufferSize(size: number): void;\n        getRecvBufferSize(): number;\n        getSendBufferSize(): number;\n\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. error\n         * 3. listening\n         * 4. message\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "listening", listener: () => void): this;\n        addListener(event: "message", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "listening"): boolean;\n        emit(event: "message", msg: Buffer, rinfo: AddressInfo): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "listening", listener: () => void): this;\n        on(event: "message", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "listening", listener: () => void): this;\n        once(event: "message", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "listening", listener: () => void): this;\n        prependListener(event: "message", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "listening", listener: () => void): this;\n        prependOnceListener(event: "message", listener: (msg: Buffer, rinfo: AddressInfo) => void): this;\n    }\n}\n\ndeclare module "fs" {\n    import * as stream from "stream";\n    import * as events from "events";\n    import { URL } from "url";\n\n    /**\n     * Valid types for path values in "fs".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type BinaryData = Buffer | DataView | NodeJS.TypedArray;\n    class Stats {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        dev: number;\n        ino: number;\n        mode: number;\n        nlink: number;\n        uid: number;\n        gid: number;\n        rdev: number;\n        size: number;\n        blksize: number;\n        blocks: number;\n        atimeMs: number;\n        mtimeMs: number;\n        ctimeMs: number;\n        birthtimeMs: number;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: "error", listener: (error: Error) => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: "error", listener: (error: Error) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: "error", listener: (error: Error) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: "error", listener: (error: Error) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: "error", listener: (error: Error) => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "open", listener: (fd: number) => void): this;\n        addListener(event: "close", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "open", listener: (fd: number) => void): this;\n        on(event: "close", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "open", listener: (fd: number) => void): this;\n        once(event: "close", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "open", listener: (fd: number) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "open", listener: (fd: number) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "open", listener: (fd: number) => void): this;\n        addListener(event: "close", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "open", listener: (fd: number) => void): this;\n        on(event: "close", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "open", listener: (fd: number) => void): this;\n        once(event: "close", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "open", listener: (fd: number) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "open", listener: (fd: number) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param len If not specified, defaults to `0`.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to `0`.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function statSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number): Stats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException, stats: Stats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<Stats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function lstatSync(path: PathLike): Stats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `\'dir\'`, `\'file\'`, or `\'junction\'` (default is `\'file\'`) and is only available on Windows (ignored on other platforms).\n     * When using `\'junction\'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `\'dir\'`, `\'file\'`, or `\'junction\'` (default is `\'file\'`) and is only available on Windows (ignored on other platforms).\n         * When using `\'junction\'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = "dir" | "file" | "junction";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     * @param type May be set to `\'dir\'`, `\'file\'`, or `\'junction\'` (default is `\'file\'`) and is only available on Windows (ignored on other platforms).\n     * When using `\'junction\'`, the `target` argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(path: PathLike, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n        function native(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlink(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function rmdirSync(path: PathLike): void;\n\n    export interface MakeDirectoryOptions {\n        /**\n         * Indicates whether parent folders should be created.\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified\n         * @default 0o777.\n         */\n        mode?: number;\n    }\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, options: number | string | MakeDirectoryOptions | undefined | null, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function mkdir(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | MakeDirectoryOptions | null): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtemp(prefix: string, options: "buffer" | { encoding: "buffer" }, callback: (err: NodeJS.ErrnoException, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: "buffer" } | "buffer"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdir(path: PathLike, options: { encoding: "buffer"; withFileTypes?: false } | "buffer", callback: (err: NodeJS.ErrnoException, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { withFileTypes: true }, callback: (err: NodeJS.ErrnoException, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options: "buffer" | { encoding: "buffer"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: "buffer"; withFileTypes?: false } | "buffer"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file\'s in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file\'s in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file\'s in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     */\n    function write<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: BinaryData, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function read<TBuffer extends BinaryData>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback?: (err: NodeJS.ErrnoException, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends BinaryData>(fd: number, buffer: TBuffer, offset: number, length: number, position: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: BinaryData, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `\'r\'`.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `\'w\'` is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `\'w\'` is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `\'w\'` is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `\'a\'` is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `\'a\'` is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `mode` is not supplied, the default of `0o666` is used.\n     * If `mode` is a string, it is parsed as an octal integer.\n     * If `flag` is not supplied, the default of `\'a\'` is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on `filename`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(filename: PathLike, options: { encoding: "buffer", persistent?: boolean, recursive?: boolean } | "buffer", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file\'s type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n    }\n\n    /**\n     * Asynchronously tests a user\'s permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    /**\n     * Asynchronously tests a user\'s permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user\'s permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user\'s permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new `ReadStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new `WriteStream` object.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        start?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file\'s in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file\'s in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file\'s in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: (err: NodeJS.ErrnoException) => void): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: (err: NodeJS.ErrnoException) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for appending.\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `\'a\'` is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file\'s in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file\'s in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The `FileHandle` must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n             */\n            read<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `\'r\'`.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `\'r\'`.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to `\'r\'`.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(): Promise<Stats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to `0`.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes `buffer` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n             * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Buffer | Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes `string` to the file.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`\n             * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The `FileHandle` must have been opened for writing.\n             * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n             * If `mode` is not supplied, the default of `0o666` is used.\n             * If `mode` is a string, it is parsed as an octal integer.\n             * If `flag` is not supplied, the default of `\'w\'` is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous close(2) - close a `FileHandle`.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user\'s permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if\n         * `dest` already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to `0o666`.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * `null`, data will be read from the current position.\n         */\n        function read<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Buffer | Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.\n         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`\n         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.\n         * @param handle A `FileHandle`.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A `FileHandle`.\n         * @param len If not specified, defaults to `0`.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function rmdir(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file\'s in-core state with storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file\'s in-core state with the underlying storage device.\n         * @param handle A `FileHandle`.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function mkdir(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<void>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readdir(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readlink(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `\'dir\'`, `\'file\'`, or `\'junction\'` (default is `\'file\'`) and is only available on Windows (ignored on other platforms).\n         * When using `\'junction\'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param handle A `FileHandle`.\n         */\n        function fstat(handle: FileHandle): Promise<Stats>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lstat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function stat(path: PathLike): Promise<Stats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A `FileHandle`.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A `FileHandle`.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.\n         * @param handle A `FileHandle`.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function realpath(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `\'utf8\'` is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `\'w\'` is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `\'utf8\'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `\'a\'` is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `\'r\'`.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n    }\n}\n\ndeclare module "path" {\n    /**\n     * A parsed path object generated by path.parse() or consumed by path.format().\n     */\n    interface ParsedPath {\n        /**\n         * The root of the path such as \'/\' or \'c:\\\'\n         */\n        root: string;\n        /**\n         * The full directory path such as \'/home/user/dir\' or \'c:\\path\\dir\'\n         */\n        dir: string;\n        /**\n         * The file name including extension (if any) such as \'index.html\'\n         */\n        base: string;\n        /**\n         * The file extension (if any) such as \'.html\'\n         */\n        ext: string;\n        /**\n         * The file name without extension (if any) such as \'index\'\n         */\n        name: string;\n    }\n    interface FormatInputPathObject {\n        /**\n         * The root of the path such as \'/\' or \'c:\\\'\n         */\n        root?: string;\n        /**\n         * The full directory path such as \'/home/user/dir\' or \'c:\\path\\dir\'\n         */\n        dir?: string;\n        /**\n         * The file name including extension (if any) such as \'index.html\'\n         */\n        base?: string;\n        /**\n         * The file extension (if any) such as \'.html\'\n         */\n        ext?: string;\n        /**\n         * The file name without extension (if any) such as \'index\'\n         */\n        name?: string;\n    }\n\n    /**\n     * Normalize a string path, reducing \'..\' and \'.\' parts.\n     * When multiple slashes are found, they\'re replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n     *\n     * @param p string path to normalize.\n     */\n    function normalize(p: string): string;\n    /**\n     * Join all arguments together and normalize the resulting path.\n     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.\n     *\n     * @param paths paths to join.\n     */\n    function join(...paths: string[]): string;\n    /**\n     * The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.\n     *\n     * Starting from leftmost {from} parameter, resolves {to} to an absolute path.\n     *\n     * If {to} isn\'t already absolute, {from} arguments are prepended in right to left order,\n     * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n     * the current working directory is used as well. The resulting path is normalized,\n     * and trailing slashes are removed unless the path gets resolved to the root directory.\n     *\n     * @param pathSegments string paths to join.  Non-string arguments are ignored.\n     */\n    function resolve(...pathSegments: string[]): string;\n    /**\n     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n     *\n     * @param path path to test.\n     */\n    function isAbsolute(path: string): boolean;\n    /**\n     * Solve the relative path from {from} to {to}.\n     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n     */\n    function relative(from: string, to: string): string;\n    /**\n     * Return the directory name of a path. Similar to the Unix dirname command.\n     *\n     * @param p the path to evaluate.\n     */\n    function dirname(p: string): string;\n    /**\n     * Return the last portion of a path. Similar to the Unix basename command.\n     * Often used to extract the file name from a fully qualified path.\n     *\n     * @param p the path to evaluate.\n     * @param ext optionally, an extension to remove from the result.\n     */\n    function basename(p: string, ext?: string): string;\n    /**\n     * Return the extension of the path, from the last \'.\' to end of string in the last portion of the path.\n     * If there is no \'.\' in the last portion of the path or the first character of it is \'.\', then it returns an empty string\n     *\n     * @param p the path to evaluate.\n     */\n    function extname(p: string): string;\n    /**\n     * The platform-specific file separator. \'\\\\\' or \'/\'.\n     */\n    const sep: \'\\\\\' | \'/\';\n    /**\n     * The platform-specific file delimiter. \';\' or \':\'.\n     */\n    const delimiter: \';\' | \':\';\n    /**\n     * Returns an object from a path string - the opposite of format().\n     *\n     * @param pathString path to evaluate.\n     */\n    function parse(pathString: string): ParsedPath;\n    /**\n     * Returns a path string from an object - the opposite of parse().\n     *\n     * @param pathString path to evaluate.\n     */\n    function format(pathObject: FormatInputPathObject): string;\n\n    namespace posix {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n\n    namespace win32 {\n        function normalize(p: string): string;\n        function join(...paths: any[]): string;\n        function resolve(...pathSegments: any[]): string;\n        function isAbsolute(p: string): boolean;\n        function relative(from: string, to: string): string;\n        function dirname(p: string): string;\n        function basename(p: string, ext?: string): string;\n        function extname(p: string): string;\n        const sep: string;\n        const delimiter: string;\n        function parse(p: string): ParsedPath;\n        function format(pP: FormatInputPathObject): string;\n    }\n}\n\ndeclare module "string_decoder" {\n    interface NodeStringDecoder {\n        write(buffer: Buffer): string;\n        end(buffer?: Buffer): string;\n    }\n    const StringDecoder: {\n        new(encoding?: string): NodeStringDecoder;\n    };\n}\n\ndeclare module "tls" {\n    import * as crypto from "crypto";\n    import * as dns from "dns";\n    import * as net from "net";\n    import * as stream from "stream";\n\n    const CLIENT_RENEG_LIMIT: number;\n    const CLIENT_RENEG_WINDOW: number;\n\n    interface Certificate {\n        /**\n         * Country code.\n         */\n        C: string;\n        /**\n         * Street.\n         */\n        ST: string;\n        /**\n         * Locality.\n         */\n        L: string;\n        /**\n         * Organization.\n         */\n        O: string;\n        /**\n         * Organizational unit.\n         */\n        OU: string;\n        /**\n         * Common name.\n         */\n        CN: string;\n    }\n\n    interface PeerCertificate {\n        subject: Certificate;\n        issuer: Certificate;\n        subjectaltname: string;\n        infoAccess: { [index: string]: string[] | undefined };\n        modulus: string;\n        exponent: string;\n        valid_from: string;\n        valid_to: string;\n        fingerprint: string;\n        ext_key_usage: string[];\n        serialNumber: string;\n        raw: Buffer;\n    }\n\n    interface DetailedPeerCertificate extends PeerCertificate {\n        issuerCertificate: DetailedPeerCertificate;\n    }\n\n    interface CipherNameAndProtocol {\n        /**\n         * The cipher name.\n         */\n        name: string;\n        /**\n         * SSL/TLS protocol version.\n         */\n        version: string;\n    }\n\n    class TLSSocket extends net.Socket {\n        /**\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\n         */\n        constructor(socket: net.Socket, options?: {\n            /**\n             * An optional TLS context object from tls.createSecureContext()\n             */\n            secureContext?: SecureContext,\n            /**\n             * If true the TLS socket will be instantiated in server-mode.\n             * Defaults to false.\n             */\n            isServer?: boolean,\n            /**\n             * An optional net.Server instance.\n             */\n            server?: net.Server,\n            /**\n             * If true the server will request a certificate from clients that\n             * connect and attempt to verify that certificate. Defaults to\n             * false.\n             */\n            requestCert?: boolean,\n            /**\n             * If true the server will reject any connection which is not\n             * authorized with the list of supplied CAs. This option only has an\n             * effect if requestCert is true. Defaults to false.\n             */\n            rejectUnauthorized?: boolean,\n            /**\n             * An array of strings or a Buffer naming possible NPN protocols.\n             * (Protocols should be ordered by their priority.)\n             */\n            NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * An array of strings or a Buffer naming possible ALPN protocols.\n             * (Protocols should be ordered by their priority.) When the server\n             * receives both NPN and ALPN extensions from the client, ALPN takes\n             * precedence over NPN and the server does not send an NPN extension\n             * to the client.\n             */\n            ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array,\n            /**\n             * SNICallback(servername, cb) <Function> A function that will be\n             * called if the client supports SNI TLS extension. Two arguments\n             * will be passed when called: servername and cb. SNICallback should\n             * invoke cb(null, ctx), where ctx is a SecureContext instance.\n             * (tls.createSecureContext(...) can be used to get a proper\n             * SecureContext.) If SNICallback wasn\'t provided the default callback\n             * with high-level API will be used (see below).\n             */\n            SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void,\n            /**\n             * An optional Buffer instance containing a TLS session.\n             */\n            session?: Buffer,\n            /**\n             * If true, specifies that the OCSP status request extension will be\n             * added to the client hello and an \'OCSPResponse\' event will be\n             * emitted on the socket before establishing a secure communication\n             */\n            requestOCSP?: boolean\n        });\n\n        /**\n         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.\n         */\n        authorized: boolean;\n        /**\n         * The reason why the peer\'s certificate has not been verified.\n         * This property becomes available only when tlsSocket.authorized === false.\n         */\n        authorizationError: Error;\n        /**\n         * Static boolean value, always true.\n         * May be used to distinguish TLS sockets from regular ones.\n         */\n        encrypted: boolean;\n\n        /**\n         * String containing the selected ALPN protocol.\n         * When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false.\n         */\n        alpnProtocol?: string;\n\n        /**\n         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.\n         * @returns Returns an object representing the cipher name\n         * and the SSL/TLS protocol version of the current connection.\n         */\n        getCipher(): CipherNameAndProtocol;\n        /**\n         * Returns an object representing the peer\'s certificate.\n         * The returned object has some properties corresponding to the field of the certificate.\n         * If detailed argument is true the full chain with issuer property will be returned,\n         * if false only the top certificate without issuer property.\n         * If the peer does not provide a certificate, it returns null or an empty object.\n         * @param detailed - If true; the full chain with issuer property will be returned.\n         * @returns An object representing the peer\'s certificate.\n         */\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\n        getPeerCertificate(detailed?: false): PeerCertificate;\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\n        /**\n         * Returns a string containing the negotiated SSL/TLS protocol version of the current connection.\n         * The value `\'unknown\'` will be returned for connected sockets that have not completed the handshaking process.\n         * The value `null` will be returned for server sockets or disconnected client sockets.\n         * See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.\n         * @returns negotiated SSL/TLS protocol version of the current connection\n         */\n        getProtocol(): string | null;\n        /**\n         * Could be used to speed up handshake establishment when reconnecting to the server.\n         * @returns ASN.1 encoded TLS session or undefined if none was negotiated.\n         */\n        getSession(): any;\n        /**\n         * NOTE: Works only with client TLS sockets.\n         * Useful only for debugging, for session reuse provide session option to tls.connect().\n         * @returns TLS session ticket or undefined if none was negotiated.\n         */\n        getTLSTicket(): any;\n        /**\n         * Initiate TLS renegotiation process.\n         *\n         * NOTE: Can be used to request peer\'s certificate after the secure connection has been established.\n         * ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.\n         * @param options - The options may contain the following fields: rejectUnauthorized,\n         * requestCert (See tls.createServer() for details).\n         * @param callback - callback(err) will be executed with null as err, once the renegotiation\n         * is successfully completed.\n         */\n        renegotiate(options: { rejectUnauthorized?: boolean, requestCert?: boolean }, callback: (err: Error | null) => void): any;\n        /**\n         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by\n         * the TLS layer until the entire fragment is received and its integrity is verified;\n         * large fragments can span multiple roundtrips, and their processing can be delayed due to packet\n         * loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,\n         * which may decrease overall server throughput.\n         * @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).\n         * @returns Returns true on success, false otherwise.\n         */\n        setMaxSendFragment(size: number): boolean;\n\n        /**\n         * events.EventEmitter\n         * 1. OCSPResponse\n         * 2. secureConnect\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;\n        addListener(event: "secureConnect", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "OCSPResponse", response: Buffer): boolean;\n        emit(event: "secureConnect"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "OCSPResponse", listener: (response: Buffer) => void): this;\n        on(event: "secureConnect", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "OCSPResponse", listener: (response: Buffer) => void): this;\n        once(event: "secureConnect", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;\n        prependListener(event: "secureConnect", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;\n        prependOnceListener(event: "secureConnect", listener: () => void): this;\n    }\n\n    interface TlsOptions extends SecureContextOptions {\n        handshakeTimeout?: number;\n        requestCert?: boolean;\n        rejectUnauthorized?: boolean;\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        SNICallback?: (servername: string, cb: (err: Error | null, ctx: SecureContext) => void) => void;\n        sessionTimeout?: number;\n        ticketKeys?: Buffer;\n    }\n\n    interface ConnectionOptions extends SecureContextOptions {\n        host?: string;\n        port?: number;\n        path?: string; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\n        socket?: net.Socket; // Establish secure connection on a given socket rather than creating a new socket\n        rejectUnauthorized?: boolean; // Defaults to true\n        NPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        ALPNProtocols?: string[] | Buffer[] | Uint8Array[] | Buffer | Uint8Array;\n        checkServerIdentity?: typeof checkServerIdentity;\n        servername?: string; // SNI TLS Extension\n        session?: Buffer;\n        minDHSize?: number;\n        secureContext?: SecureContext; // If not provided, the entire ConnectionOptions object will be passed to tls.createSecureContext()\n        lookup?: net.LookupFunction;\n    }\n\n    class Server extends net.Server {\n        addContext(hostName: string, credentials: {\n            key: string;\n            cert: string;\n            ca: string;\n        }): void;\n\n        /**\n         * events.EventEmitter\n         * 1. tlsClientError\n         * 2. newSession\n         * 3. OCSPRequest\n         * 4. resumeSession\n         * 5. secureConnection\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "tlsClientError", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        addListener(event: "newSession", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        addListener(event: "OCSPRequest", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        addListener(event: "resumeSession", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        addListener(event: "secureConnection", listener: (tlsSocket: TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "tlsClientError", err: Error, tlsSocket: TLSSocket): boolean;\n        emit(event: "newSession", sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void): boolean;\n        emit(event: "OCSPRequest", certificate: Buffer, issuer: Buffer, callback: Function): boolean;\n        emit(event: "resumeSession", sessionId: any, callback: (err: Error, sessionData: any) => void): boolean;\n        emit(event: "secureConnection", tlsSocket: TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "tlsClientError", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        on(event: "newSession", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        on(event: "OCSPRequest", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        on(event: "resumeSession", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        on(event: "secureConnection", listener: (tlsSocket: TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "tlsClientError", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        once(event: "newSession", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        once(event: "OCSPRequest", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        once(event: "resumeSession", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        once(event: "secureConnection", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "tlsClientError", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependListener(event: "newSession", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependListener(event: "OCSPRequest", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependListener(event: "resumeSession", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependListener(event: "secureConnection", listener: (tlsSocket: TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "tlsClientError", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: "newSession", listener: (sessionId: any, sessionData: any, callback: (err: Error, resp: Buffer) => void) => void): this;\n        prependOnceListener(event: "OCSPRequest", listener: (certificate: Buffer, issuer: Buffer, callback: Function) => void): this;\n        prependOnceListener(event: "resumeSession", listener: (sessionId: any, callback: (err: Error, sessionData: any) => void) => void): this;\n        prependOnceListener(event: "secureConnection", listener: (tlsSocket: TLSSocket) => void): this;\n    }\n\n    interface SecurePair {\n        encrypted: any;\n        cleartext: any;\n    }\n\n    interface SecureContextOptions {\n        pfx?: string | Buffer | Array<string | Buffer | Object>;\n        key?: string | Buffer | Array<Buffer | Object>;\n        passphrase?: string;\n        cert?: string | Buffer | Array<string | Buffer>;\n        ca?: string | Buffer | Array<string | Buffer>;\n        ciphers?: string;\n        honorCipherOrder?: boolean;\n        ecdhCurve?: string;\n        clientCertEngine?: string;\n        crl?: string | Buffer | Array<string | Buffer>;\n        dhparam?: string | Buffer;\n        secureOptions?: number; // Value is a numeric bitmask of the `SSL_OP_*` options\n        secureProtocol?: string; // SSL Method, e.g. SSLv23_method\n        sessionIdContext?: string;\n    }\n\n    interface SecureContext {\n        context: any;\n    }\n\n    /*\n     * Verifies the certificate `cert` is issued to host `host`.\n     * @host The hostname to verify the certificate against\n     * @cert PeerCertificate representing the peer\'s certificate\n     *\n     * Returns Error object, populating it with the reason, host and cert on failure.  On success, returns undefined.\n     */\n    function checkServerIdentity(host: string, cert: PeerCertificate): Error | undefined;\n    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function connect(options: ConnectionOptions, secureConnectionListener?: () => void): TLSSocket;\n    function connect(port: number, host?: string, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function createSecurePair(credentials?: crypto.Credentials, isServer?: boolean, requestCert?: boolean, rejectUnauthorized?: boolean): SecurePair;\n    function createSecureContext(details: SecureContextOptions): SecureContext;\n    function getCiphers(): string[];\n\n    const DEFAULT_ECDH_CURVE: string;\n}\n\ndeclare module "crypto" {\n    import * as stream from "stream";\n\n    interface Certificate {\n        exportChallenge(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        exportPublicKey(spkac: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        verifySpkac(spkac: Buffer | NodeJS.TypedArray | DataView): boolean;\n    }\n    const Certificate: {\n        new(): Certificate;\n        (): Certificate;\n    };\n\n    /** @deprecated since v10.0.0 */\n    const fips: boolean;\n\n    interface CredentialDetails {\n        pfx: string;\n        key: string;\n        passphrase: string;\n        cert: string;\n        ca: string | string[];\n        crl: string | string[];\n        ciphers: string;\n    }\n    interface Credentials { context?: any; }\n    function createCredentials(details: CredentialDetails): Credentials;\n    function createHash(algorithm: string, options?: stream.TransformOptions): Hash;\n    function createHmac(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Hmac;\n\n    type Utf8AsciiLatin1Encoding = "utf8" | "ascii" | "latin1";\n    type HexBase64Latin1Encoding = "latin1" | "hex" | "base64";\n    type Utf8AsciiBinaryEncoding = "utf8" | "ascii" | "binary";\n    type HexBase64BinaryEncoding = "binary" | "base64" | "hex";\n    type ECDHKeyFormat = "compressed" | "uncompressed" | "hybrid";\n\n    interface Hash extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hash;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hash;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    interface Hmac extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Hmac;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Hmac;\n        digest(): Buffer;\n        digest(encoding: HexBase64Latin1Encoding): string;\n    }\n    type CipherCCMTypes = \'aes-128-ccm\' | \'aes-192-ccm\' | \'aes-256-ccm\';\n    type CipherGCMTypes = \'aes-128-gcm\' | \'aes-192-gcm\' | \'aes-256-gcm\';\n    interface CipherCCMOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherGCMOptions extends stream.TransformOptions {\n        authTagLength?: number;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createCipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    function createCipheriv(algorithm: CipherCCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): CipherCCM;\n    function createCipheriv(algorithm: CipherGCMTypes, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): CipherGCM;\n    function createCipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Cipher;\n\n    interface Cipher extends NodeJS.ReadWriteStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64BinaryEncoding): string;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: HexBase64BinaryEncoding): string;\n        // second arg ignored\n        update(data: string, input_encoding: Utf8AsciiBinaryEncoding, output_encoding: HexBase64BinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // getAuthTag(): Buffer;\n        // setAAD(buffer: Buffer): this; // docs only say buffer\n    }\n    interface CipherCCM extends Cipher {\n        setAAD(buffer: Buffer, options: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherGCM extends Cipher {\n        setAAD(buffer: Buffer, options?: { plaintextLength: number }): this;\n        getAuthTag(): Buffer;\n    }\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherCCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options: CipherCCMOptions): DecipherCCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: CipherGCMTypes, password: string | Buffer | NodeJS.TypedArray | DataView, options?: CipherGCMOptions): DecipherGCM;\n    /** @deprecated since v10.0.0 use createCipheriv() */\n    function createDecipher(algorithm: string, password: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    function createDecipheriv(\n        algorithm: CipherCCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options: CipherCCMOptions,\n    ): DecipherCCM;\n    function createDecipheriv(\n        algorithm: CipherGCMTypes,\n        key: string | Buffer | NodeJS.TypedArray | DataView,\n        iv: string | Buffer | NodeJS.TypedArray | DataView,\n        options?: CipherGCMOptions,\n    ): DecipherGCM;\n    function createDecipheriv(algorithm: string, key: string | Buffer | NodeJS.TypedArray | DataView, iv: string | Buffer | NodeJS.TypedArray | DataView, options?: stream.TransformOptions): Decipher;\n\n    interface Decipher extends NodeJS.ReadWriteStream {\n        update(data: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer;\n        update(data: Buffer | NodeJS.TypedArray | DataView, input_encoding: any, output_encoding: Utf8AsciiBinaryEncoding): string;\n        // second arg is ignored\n        update(data: string, input_encoding: HexBase64BinaryEncoding, output_encoding: Utf8AsciiBinaryEncoding): string;\n        final(): Buffer;\n        final(output_encoding: string): string;\n        setAutoPadding(auto_padding?: boolean): this;\n        // setAuthTag(tag: Buffer | NodeJS.TypedArray | DataView): this;\n        // setAAD(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n    }\n    interface DecipherCCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options: { plaintextLength: number }): this;\n    }\n    interface DecipherGCM extends Decipher {\n        setAuthTag(buffer: Buffer | NodeJS.TypedArray | DataView): this;\n        setAAD(buffer: Buffer | NodeJS.TypedArray | DataView, options?: { plaintextLength: number }): this;\n    }\n\n    function createSign(algorithm: string, options?: stream.WritableOptions): Signer;\n    interface Signer extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Signer;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Signer;\n        sign(private_key: string | { key: string; passphrase?: string, padding?: number, saltLength?: number }): Buffer;\n        sign(private_key: string | { key: string; passphrase?: string, padding?: number, saltLength?: number }, output_format: HexBase64Latin1Encoding): string;\n    }\n    function createVerify(algorith: string, options?: stream.WritableOptions): Verify;\n    interface Verify extends NodeJS.WritableStream {\n        update(data: string | Buffer | NodeJS.TypedArray | DataView): Verify;\n        update(data: string, input_encoding: Utf8AsciiLatin1Encoding): Verify;\n        verify(object: string | Object, signature: Buffer | NodeJS.TypedArray | DataView): boolean;\n        verify(object: string | Object, signature: string, signature_format: HexBase64Latin1Encoding): boolean;\n        // https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format\n        // The signature field accepts a TypedArray type, but it is only available starting ES2017\n    }\n    function createDiffieHellman(prime_length: number, generator?: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: number | Buffer | NodeJS.TypedArray | DataView): DiffieHellman;\n    function createDiffieHellman(prime: string, prime_encoding: HexBase64Latin1Encoding, generator: string, generator_encoding: HexBase64Latin1Encoding): DiffieHellman;\n    interface DiffieHellman {\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrime(): Buffer;\n        getPrime(encoding: HexBase64Latin1Encoding): string;\n        getGenerator(): Buffer;\n        getGenerator(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        setPublicKey(public_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPublicKey(public_key: string, encoding: string): void;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: string): void;\n        verifyError: number;\n    }\n    function getDiffieHellman(group_name: string): DiffieHellman;\n    function pbkdf2(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        iterations: number,\n        keylen: number,\n        digest: string,\n        callback: (err: Error | null, derivedKey: Buffer) => any,\n    ): void;\n    function pbkdf2Sync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, iterations: number, keylen: number, digest: string): Buffer;\n\n    function randomBytes(size: number): Buffer;\n    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    function pseudoRandomBytes(size: number): Buffer;\n    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n\n    function randomFillSync<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset?: number, size?: number): T;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, callback: (err: Error | null, buf: T) => void): void;\n    function randomFill<T extends Buffer | NodeJS.TypedArray | DataView>(buffer: T, offset: number, size: number, callback: (err: Error | null, buf: T) => void): void;\n\n    interface ScryptOptions {\n        N?: number;\n        r?: number;\n        p?: number;\n        maxmem?: number;\n    }\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number, callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scrypt(\n        password: string | Buffer | NodeJS.TypedArray | DataView,\n        salt: string | Buffer | NodeJS.TypedArray | DataView,\n        keylen: number,\n        options: ScryptOptions,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scryptSync(password: string | Buffer | NodeJS.TypedArray | DataView, salt: string | Buffer | NodeJS.TypedArray | DataView, keylen: number, options?: ScryptOptions): Buffer;\n\n    interface RsaPublicKey {\n        key: string;\n        padding?: number;\n    }\n    interface RsaPrivateKey {\n        key: string;\n        passphrase?: string;\n        padding?: number;\n    }\n    function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer | NodeJS.TypedArray | DataView): Buffer;\n    function getCiphers(): string[];\n    function getCurves(): string[];\n    function getHashes(): string[];\n    class ECDH {\n        static convertKey(\n            key: string | Buffer | NodeJS.TypedArray | DataView,\n            curve: string,\n            inputEncoding?: HexBase64Latin1Encoding,\n            outputEncoding?: "latin1" | "hex" | "base64",\n            format?: "uncompressed" | "compressed" | "hybrid",\n        ): Buffer | string;\n        generateKeys(): Buffer;\n        generateKeys(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView): Buffer;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer;\n        computeSecret(other_public_key: Buffer | NodeJS.TypedArray | DataView, output_encoding: HexBase64Latin1Encoding): string;\n        computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding, output_encoding: HexBase64Latin1Encoding): string;\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: HexBase64Latin1Encoding): string;\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: HexBase64Latin1Encoding, format?: ECDHKeyFormat): string;\n        setPrivateKey(private_key: Buffer | NodeJS.TypedArray | DataView): void;\n        setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void;\n    }\n    function createECDH(curve_name: string): ECDH;\n    function timingSafeEqual(a: Buffer | NodeJS.TypedArray | DataView, b: Buffer | NodeJS.TypedArray | DataView): boolean;\n    /** @deprecated since v10.0.0 */\n    const DEFAULT_ENCODING: string;\n\n    export type KeyType = \'rsa\' | \'dsa\' | \'ec\';\n    export type KeyFormat = \'pem\' | \'der\';\n\n    interface BasePrivateKeyEncodingOptions<T extends KeyFormat> {\n        format: T;\n        cipher: string;\n        passphrase: string;\n    }\n\n    interface RSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * @default 0x10001\n         */\n        publicExponent?: number;\n\n        publicKeyEncoding: {\n            type: \'pkcs1\' | \'spki\';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \'pkcs1\' | \'pkcs8\';\n        };\n    }\n\n    interface DSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Size of q in bits\n         */\n        divisorLength: number;\n\n        publicKeyEncoding: {\n            type: \'spki\';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \'pkcs8\';\n        };\n    }\n\n    interface ECKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Name of the curve to use.\n         */\n        namedCurve: string;\n\n        publicKeyEncoding: {\n            type: \'pkcs1\' | \'spki\';\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \'sec1\' | \'pkcs8\';\n        };\n    }\n\n    interface KeyPairSyncResult<T1 extends string | Buffer, T2 extends string | Buffer> {\n        publicKey: T1;\n        privateKey: T2;\n    }\n\n    function generateKeyPairSync(type: \'rsa\', options: RSAKeyPairOptions<\'pem\', \'pem\'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: \'rsa\', options: RSAKeyPairOptions<\'pem\', \'der\'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: \'rsa\', options: RSAKeyPairOptions<\'der\', \'pem\'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: \'rsa\', options: RSAKeyPairOptions<\'der\', \'der\'>): KeyPairSyncResult<Buffer, Buffer>;\n\n    function generateKeyPairSync(type: \'dsa\', options: DSAKeyPairOptions<\'pem\', \'pem\'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: \'dsa\', options: DSAKeyPairOptions<\'pem\', \'der\'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: \'dsa\', options: DSAKeyPairOptions<\'der\', \'pem\'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: \'dsa\', options: DSAKeyPairOptions<\'der\', \'der\'>): KeyPairSyncResult<Buffer, Buffer>;\n\n    function generateKeyPairSync(type: \'ec\', options: ECKeyPairOptions<\'pem\', \'pem\'>): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(type: \'ec\', options: ECKeyPairOptions<\'pem\', \'der\'>): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(type: \'ec\', options: ECKeyPairOptions<\'der\', \'pem\'>): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(type: \'ec\', options: ECKeyPairOptions<\'der\', \'der\'>): KeyPairSyncResult<Buffer, Buffer>;\n\n    function generateKeyPair(type: \'rsa\', options: RSAKeyPairOptions<\'pem\', \'pem\'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: \'rsa\', options: RSAKeyPairOptions<\'pem\', \'der\'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: \'rsa\', options: RSAKeyPairOptions<\'der\', \'pem\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: \'rsa\', options: RSAKeyPairOptions<\'der\', \'der\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n\n    function generateKeyPair(type: \'dsa\', options: DSAKeyPairOptions<\'pem\', \'pem\'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: \'dsa\', options: DSAKeyPairOptions<\'pem\', \'der\'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: \'dsa\', options: DSAKeyPairOptions<\'der\', \'pem\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: \'dsa\', options: DSAKeyPairOptions<\'der\', \'der\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n\n    function generateKeyPair(type: \'ec\', options: ECKeyPairOptions<\'pem\', \'pem\'>, callback: (err: Error | null, publicKey: string, privateKey: string) => void): void;\n    function generateKeyPair(type: \'ec\', options: ECKeyPairOptions<\'pem\', \'der\'>, callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void): void;\n    function generateKeyPair(type: \'ec\', options: ECKeyPairOptions<\'der\', \'pem\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void): void;\n    function generateKeyPair(type: \'ec\', options: ECKeyPairOptions<\'der\', \'der\'>, callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void): void;\n\n    namespace generateKeyPair {\n        function __promisify__(type: "rsa", options: RSAKeyPairOptions<\'pem\', \'pem\'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: "rsa", options: RSAKeyPairOptions<\'pem\', \'der\'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: "rsa", options: RSAKeyPairOptions<\'der\', \'pem\'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: "rsa", options: RSAKeyPairOptions<\'der\', \'der\'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n\n        function __promisify__(type: "dsa", options: DSAKeyPairOptions<\'pem\', \'pem\'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: "dsa", options: DSAKeyPairOptions<\'pem\', \'der\'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: "dsa", options: DSAKeyPairOptions<\'der\', \'pem\'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: "dsa", options: DSAKeyPairOptions<\'der\', \'der\'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n\n        function __promisify__(type: "ec", options: ECKeyPairOptions<\'pem\', \'pem\'>): Promise<{ publicKey: string, privateKey: string }>;\n        function __promisify__(type: "ec", options: ECKeyPairOptions<\'pem\', \'der\'>): Promise<{ publicKey: string, privateKey: Buffer }>;\n        function __promisify__(type: "ec", options: ECKeyPairOptions<\'der\', \'pem\'>): Promise<{ publicKey: Buffer, privateKey: string }>;\n        function __promisify__(type: "ec", options: ECKeyPairOptions<\'der\', \'der\'>): Promise<{ publicKey: Buffer, privateKey: Buffer }>;\n    }\n}\n\ndeclare module "stream" {\n    import * as events from "events";\n\n    class internal extends events.EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal { }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            readable: boolean;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. readable\n             * 5. error\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "data", listener: (chunk: any) => void): this;\n            addListener(event: "end", listener: () => void): this;\n            addListener(event: "readable", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "data", chunk: any): boolean;\n            emit(event: "end"): boolean;\n            emit(event: "readable"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "data", listener: (chunk: any) => void): this;\n            on(event: "end", listener: () => void): this;\n            on(event: "readable", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "data", listener: (chunk: any) => void): this;\n            once(event: "end", listener: () => void): this;\n            once(event: "readable", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "data", listener: (chunk: any) => void): this;\n            prependListener(event: "end", listener: () => void): this;\n            prependListener(event: "readable", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "data", listener: (chunk: any) => void): this;\n            prependOnceListener(event: "end", listener: () => void): this;\n            prependOnceListener(event: "readable", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "data", listener: (chunk: any) => void): this;\n            removeListener(event: "end", listener: () => void): this;\n            removeListener(event: "readable", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            objectMode?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "drain", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "finish", listener: () => void): this;\n            addListener(event: "pipe", listener: (src: Readable) => void): this;\n            addListener(event: "unpipe", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "drain"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "finish"): boolean;\n            emit(event: "pipe", src: Readable): boolean;\n            emit(event: "unpipe", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "drain", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "finish", listener: () => void): this;\n            on(event: "pipe", listener: (src: Readable) => void): this;\n            on(event: "unpipe", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "drain", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "finish", listener: () => void): this;\n            once(event: "pipe", listener: (src: Readable) => void): this;\n            once(event: "unpipe", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "drain", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "finish", listener: () => void): this;\n            prependListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "drain", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "finish", listener: () => void): this;\n            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "drain", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "finish", listener: () => void): this;\n            removeListener(event: "pipe", listener: (src: Readable) => void): this;\n            removeListener(event: "unpipe", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            writable: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException) => void,\n        ): T;\n        function pipeline(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>, callback?: (err: NodeJS.ErrnoException) => void): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: Array<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n    }\n\n    export = internal;\n}\n\ndeclare module "util" {\n    interface InspectOptions extends NodeJS.InspectOptions { }\n    function format(format: any, ...param: any[]): string;\n    function formatWithOptions(inspectOptions: InspectOptions, format: string, ...param: any[]): string;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function debug(string: string): void;\n    /** @deprecated since v0.11.3 - use `console.error()` instead. */\n    function error(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function puts(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use `console.log()` instead. */\n    function print(...param: any[]): void;\n    /** @deprecated since v0.11.3 - use a third party module instead. */\n    function log(string: string): void;\n    const inspect: {\n        (object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n        (object: any, options: InspectOptions): string;\n        colors: {\n            [color: string]: [number, number] | undefined\n        }\n        styles: {\n            [style: string]: string | undefined\n        }\n        defaultOptions: InspectOptions;\n        custom: symbol;\n    };\n    /** @deprecated since v4.0.0 - use `Array.isArray()` instead. */\n    function isArray(object: any): object is any[];\n    /** @deprecated since v4.0.0 - use `util.types.isRegExp()` instead. */\n    function isRegExp(object: any): object is RegExp;\n    /** @deprecated since v4.0.0 - use `util.types.isDate()` instead. */\n    function isDate(object: any): object is Date;\n    /** @deprecated since v4.0.0 - use `util.types.isNativeError()` instead. */\n    function isError(object: any): object is Error;\n    function inherits(constructor: any, superConstructor: any): void;\n    function debuglog(key: string): (msg: string, ...param: any[]) => void;\n    /** @deprecated since v4.0.0 - use `typeof value === \'boolean\'` instead. */\n    function isBoolean(object: any): object is boolean;\n    /** @deprecated since v4.0.0 - use `Buffer.isBuffer()` instead. */\n    function isBuffer(object: any): object is Buffer;\n    /** @deprecated since v4.0.0 - use `typeof value === \'function\'` instead. */\n    function isFunction(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `value === null` instead. */\n    function isNull(object: any): object is null;\n    /** @deprecated since v4.0.0 - use `value === null || value === undefined` instead. */\n    function isNullOrUndefined(object: any): object is null | undefined;\n    /** @deprecated since v4.0.0 - use `typeof value === \'number\'` instead. */\n    function isNumber(object: any): object is number;\n    /** @deprecated since v4.0.0 - use `value !== null && typeof value === \'object\'` instead. */\n    function isObject(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `(typeof value !== \'object\' && typeof value !== \'function\') || value === null` instead. */\n    function isPrimitive(object: any): boolean;\n    /** @deprecated since v4.0.0 - use `typeof value === \'string\'` instead. */\n    function isString(object: any): object is string;\n    /** @deprecated since v4.0.0 - use `typeof value === \'symbol\'` instead. */\n    function isSymbol(object: any): object is symbol;\n    /** @deprecated since v4.0.0 - use `value === undefined` instead. */\n    function isUndefined(object: any): object is undefined;\n    function deprecate<T extends Function>(fn: T, message: string): T;\n    function isDeepStrictEqual(val1: any, val2: any): boolean;\n\n    interface CustomPromisify<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n\n    function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<TResult>(fn: () => Promise<TResult>): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1>(fn: (arg1: T1) => Promise<void>): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, TResult>(fn: (arg1: T1) => Promise<TResult>): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2>(fn: (arg1: T1, arg2: T2) => Promise<void>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2) => Promise<TResult>): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException) => void) => void;\n    function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n\n    function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    function promisify<TResult>(fn: (callback: (err: Error | null, result: TResult) => void) => void): () => Promise<TResult>;\n    function promisify(fn: (callback: (err?: Error | null) => void) => void): () => Promise<void>;\n    function promisify<T1, TResult>(fn: (arg1: T1, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1) => Promise<TResult>;\n    function promisify<T1>(fn: (arg1: T1, callback: (err?: Error | null) => void) => void): (arg1: T1) => Promise<void>;\n    function promisify<T1, T2, TResult>(fn: (arg1: T1, arg2: T2, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2) => Promise<TResult>;\n    function promisify<T1, T2>(fn: (arg1: T1, arg2: T2, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2) => Promise<void>;\n    function promisify<T1, T2, T3, TResult>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: Error | null, result: TResult) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    function promisify<T1, T2, T3>(fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: Error | null) => void) => void): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: Error | null, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: Error | null) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    function promisify(fn: Function): Function;\n    namespace promisify {\n        const custom: symbol;\n    }\n\n    namespace types {\n        function isAnyArrayBuffer(object: any): boolean;\n        function isArgumentsObject(object: any): object is IArguments;\n        function isArrayBuffer(object: any): object is ArrayBuffer;\n        function isAsyncFunction(object: any): boolean;\n        function isBooleanObject(object: any): object is Boolean;\n        function isBoxedPrimitive(object: any): object is (Number | Boolean | String | Symbol /* BigInt */);\n        function isDataView(object: any): object is DataView;\n        function isDate(object: any): object is Date;\n        function isExternal(object: any): boolean;\n        function isFloat32Array(object: any): object is Float32Array;\n        function isFloat64Array(object: any): object is Float64Array;\n        function isGeneratorFunction(object: any): boolean;\n        function isGeneratorObject(object: any): boolean;\n        function isInt8Array(object: any): object is Int8Array;\n        function isInt16Array(object: any): object is Int16Array;\n        function isInt32Array(object: any): object is Int32Array;\n        function isMap(object: any): boolean;\n        function isMapIterator(object: any): boolean;\n        function isNativeError(object: any): object is Error;\n        function isNumberObject(object: any): object is Number;\n        function isPromise(object: any): boolean;\n        function isProxy(object: any): boolean;\n        function isRegExp(object: any): object is RegExp;\n        function isSet(object: any): boolean;\n        function isSetIterator(object: any): boolean;\n        function isSharedArrayBuffer(object: any): boolean;\n        function isStringObject(object: any): boolean;\n        function isSymbolObject(object: any): boolean;\n        function isTypedArray(object: any): object is NodeJS.TypedArray;\n        function isUint8Array(object: any): object is Uint8Array;\n        function isUint8ClampedArray(object: any): object is Uint8ClampedArray;\n        function isUint16Array(object: any): object is Uint16Array;\n        function isUint32Array(object: any): object is Uint32Array;\n        function isWeakMap(object: any): boolean;\n        function isWeakSet(object: any): boolean;\n        function isWebAssemblyCompiledModule(object: any): boolean;\n    }\n\n    class TextDecoder {\n        readonly encoding: string;\n        readonly fatal: boolean;\n        readonly ignoreBOM: boolean;\n        constructor(\n          encoding?: string,\n          options?: { fatal?: boolean; ignoreBOM?: boolean }\n        );\n        decode(\n          input?: NodeJS.TypedArray | DataView | ArrayBuffer | null,\n          options?: { stream?: boolean }\n        ): string;\n    }\n\n    class TextEncoder {\n        readonly encoding: string;\n        constructor();\n        encode(input?: string): Uint8Array;\n    }\n}\n\ndeclare module "assert" {\n    function internal(value: any, message?: string | Error): void;\n    namespace internal {\n        class AssertionError implements Error {\n            name: string;\n            message: string;\n            actual: any;\n            expected: any;\n            operator: string;\n            generatedMessage: boolean;\n            code: \'ERR_ASSERTION\';\n\n            constructor(options?: {\n                message?: string; actual?: any; expected?: any;\n                operator?: string; stackStartFn?: Function\n            });\n        }\n\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(actual: any, expected: any, message?: string | Error, operator?: string, stackStartFn?: Function): never;\n        function ok(value: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use strictEqual() instead. */\n        function equal(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notStrictEqual() instead. */\n        function notEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use deepStrictEqual() instead. */\n        function deepEqual(actual: any, expected: any, message?: string | Error): void;\n        /** @deprecated since v9.9.0 - use notDeepStrictEqual() instead. */\n        function notDeepEqual(actual: any, expected: any, message?: string | Error): void;\n        function strictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function deepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n        function notDeepStrictEqual(actual: any, expected: any, message?: string | Error): void;\n\n        function throws(block: Function, message?: string | Error): void;\n        function throws(block: Function, error: RegExp | Function | Object | Error, message?: string | Error): void;\n        function doesNotThrow(block: Function, message?: string | Error): void;\n        function doesNotThrow(block: Function, error: RegExp | Function, message?: string | Error): void;\n\n        function ifError(value: any): void;\n\n        function rejects(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function rejects(block: Function | Promise<any>, error: RegExp | Function | Object | Error, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, message?: string | Error): Promise<void>;\n        function doesNotReject(block: Function | Promise<any>, error: RegExp | Function, message?: string | Error): Promise<void>;\n\n        const strict: typeof internal;\n    }\n\n    export = internal;\n}\n\ndeclare module "tty" {\n    import * as net from "net";\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        isRaw: boolean;\n        setRawMode(mode: boolean): void;\n        isTTY: boolean;\n    }\n    class WriteStream extends net.Socket {\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}\n\ndeclare module "domain" {\n    import * as events from "events";\n\n    class Domain extends events.EventEmitter implements NodeJS.Domain {\n        run(fn: Function): void;\n        add(emitter: events.EventEmitter): void;\n        remove(emitter: events.EventEmitter): void;\n        bind(cb: (err: Error, data: any) => any): any;\n        intercept(cb: (data: any) => any): any;\n        members: any[];\n        enter(): void;\n        exit(): void;\n    }\n\n    function create(): Domain;\n}\n\ndeclare module "constants" {\n    const E2BIG: number;\n    const EACCES: number;\n    const EADDRINUSE: number;\n    const EADDRNOTAVAIL: number;\n    const EAFNOSUPPORT: number;\n    const EAGAIN: number;\n    const EALREADY: number;\n    const EBADF: number;\n    const EBADMSG: number;\n    const EBUSY: number;\n    const ECANCELED: number;\n    const ECHILD: number;\n    const ECONNABORTED: number;\n    const ECONNREFUSED: number;\n    const ECONNRESET: number;\n    const EDEADLK: number;\n    const EDESTADDRREQ: number;\n    const EDOM: number;\n    const EEXIST: number;\n    const EFAULT: number;\n    const EFBIG: number;\n    const EHOSTUNREACH: number;\n    const EIDRM: number;\n    const EILSEQ: number;\n    const EINPROGRESS: number;\n    const EINTR: number;\n    const EINVAL: number;\n    const EIO: number;\n    const EISCONN: number;\n    const EISDIR: number;\n    const ELOOP: number;\n    const EMFILE: number;\n    const EMLINK: number;\n    const EMSGSIZE: number;\n    const ENAMETOOLONG: number;\n    const ENETDOWN: number;\n    const ENETRESET: number;\n    const ENETUNREACH: number;\n    const ENFILE: number;\n    const ENOBUFS: number;\n    const ENODATA: number;\n    const ENODEV: number;\n    const ENOENT: number;\n    const ENOEXEC: number;\n    const ENOLCK: number;\n    const ENOLINK: number;\n    const ENOMEM: number;\n    const ENOMSG: number;\n    const ENOPROTOOPT: number;\n    const ENOSPC: number;\n    const ENOSR: number;\n    const ENOSTR: number;\n    const ENOSYS: number;\n    const ENOTCONN: number;\n    const ENOTDIR: number;\n    const ENOTEMPTY: number;\n    const ENOTSOCK: number;\n    const ENOTSUP: number;\n    const ENOTTY: number;\n    const ENXIO: number;\n    const EOPNOTSUPP: number;\n    const EOVERFLOW: number;\n    const EPERM: number;\n    const EPIPE: number;\n    const EPROTO: number;\n    const EPROTONOSUPPORT: number;\n    const EPROTOTYPE: number;\n    const ERANGE: number;\n    const EROFS: number;\n    const ESPIPE: number;\n    const ESRCH: number;\n    const ETIME: number;\n    const ETIMEDOUT: number;\n    const ETXTBSY: number;\n    const EWOULDBLOCK: number;\n    const EXDEV: number;\n    const WSAEINTR: number;\n    const WSAEBADF: number;\n    const WSAEACCES: number;\n    const WSAEFAULT: number;\n    const WSAEINVAL: number;\n    const WSAEMFILE: number;\n    const WSAEWOULDBLOCK: number;\n    const WSAEINPROGRESS: number;\n    const WSAEALREADY: number;\n    const WSAENOTSOCK: number;\n    const WSAEDESTADDRREQ: number;\n    const WSAEMSGSIZE: number;\n    const WSAEPROTOTYPE: number;\n    const WSAENOPROTOOPT: number;\n    const WSAEPROTONOSUPPORT: number;\n    const WSAESOCKTNOSUPPORT: number;\n    const WSAEOPNOTSUPP: number;\n    const WSAEPFNOSUPPORT: number;\n    const WSAEAFNOSUPPORT: number;\n    const WSAEADDRINUSE: number;\n    const WSAEADDRNOTAVAIL: number;\n    const WSAENETDOWN: number;\n    const WSAENETUNREACH: number;\n    const WSAENETRESET: number;\n    const WSAECONNABORTED: number;\n    const WSAECONNRESET: number;\n    const WSAENOBUFS: number;\n    const WSAEISCONN: number;\n    const WSAENOTCONN: number;\n    const WSAESHUTDOWN: number;\n    const WSAETOOMANYREFS: number;\n    const WSAETIMEDOUT: number;\n    const WSAECONNREFUSED: number;\n    const WSAELOOP: number;\n    const WSAENAMETOOLONG: number;\n    const WSAEHOSTDOWN: number;\n    const WSAEHOSTUNREACH: number;\n    const WSAENOTEMPTY: number;\n    const WSAEPROCLIM: number;\n    const WSAEUSERS: number;\n    const WSAEDQUOT: number;\n    const WSAESTALE: number;\n    const WSAEREMOTE: number;\n    const WSASYSNOTREADY: number;\n    const WSAVERNOTSUPPORTED: number;\n    const WSANOTINITIALISED: number;\n    const WSAEDISCON: number;\n    const WSAENOMORE: number;\n    const WSAECANCELLED: number;\n    const WSAEINVALIDPROCTABLE: number;\n    const WSAEINVALIDPROVIDER: number;\n    const WSAEPROVIDERFAILEDINIT: number;\n    const WSASYSCALLFAILURE: number;\n    const WSASERVICE_NOT_FOUND: number;\n    const WSATYPE_NOT_FOUND: number;\n    const WSA_E_NO_MORE: number;\n    const WSA_E_CANCELLED: number;\n    const WSAEREFUSED: number;\n    const SIGHUP: number;\n    const SIGINT: number;\n    const SIGILL: number;\n    const SIGABRT: number;\n    const SIGFPE: number;\n    const SIGKILL: number;\n    const SIGSEGV: number;\n    const SIGTERM: number;\n    const SIGBREAK: number;\n    const SIGWINCH: number;\n    const SSL_OP_ALL: number;\n    const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\n    const SSL_OP_CIPHER_SERVER_PREFERENCE: number;\n    const SSL_OP_CISCO_ANYCONNECT: number;\n    const SSL_OP_COOKIE_EXCHANGE: number;\n    const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\n    const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\n    const SSL_OP_EPHEMERAL_RSA: number;\n    const SSL_OP_LEGACY_SERVER_CONNECT: number;\n    const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;\n    const SSL_OP_MICROSOFT_SESS_ID_BUG: number;\n    const SSL_OP_MSIE_SSLV2_RSA_PADDING: number;\n    const SSL_OP_NETSCAPE_CA_DN_BUG: number;\n    const SSL_OP_NETSCAPE_CHALLENGE_BUG: number;\n    const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;\n    const SSL_OP_NO_COMPRESSION: number;\n    const SSL_OP_NO_QUERY_MTU: number;\n    const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\n    const SSL_OP_NO_SSLv2: number;\n    const SSL_OP_NO_SSLv3: number;\n    const SSL_OP_NO_TICKET: number;\n    const SSL_OP_NO_TLSv1: number;\n    const SSL_OP_NO_TLSv1_1: number;\n    const SSL_OP_NO_TLSv1_2: number;\n    const SSL_OP_PKCS1_CHECK_1: number;\n    const SSL_OP_PKCS1_CHECK_2: number;\n    const SSL_OP_SINGLE_DH_USE: number;\n    const SSL_OP_SINGLE_ECDH_USE: number;\n    const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;\n    const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;\n    const SSL_OP_TLS_BLOCK_PADDING_BUG: number;\n    const SSL_OP_TLS_D5_BUG: number;\n    const SSL_OP_TLS_ROLLBACK_BUG: number;\n    const ENGINE_METHOD_DSA: number;\n    const ENGINE_METHOD_DH: number;\n    const ENGINE_METHOD_RAND: number;\n    const ENGINE_METHOD_ECDH: number;\n    const ENGINE_METHOD_ECDSA: number;\n    const ENGINE_METHOD_CIPHERS: number;\n    const ENGINE_METHOD_DIGESTS: number;\n    const ENGINE_METHOD_STORE: number;\n    const ENGINE_METHOD_PKEY_METHS: number;\n    const ENGINE_METHOD_PKEY_ASN1_METHS: number;\n    const ENGINE_METHOD_ALL: number;\n    const ENGINE_METHOD_NONE: number;\n    const DH_CHECK_P_NOT_SAFE_PRIME: number;\n    const DH_CHECK_P_NOT_PRIME: number;\n    const DH_UNABLE_TO_CHECK_GENERATOR: number;\n    const DH_NOT_SUITABLE_GENERATOR: number;\n    const NPN_ENABLED: number;\n    const RSA_PKCS1_PADDING: number;\n    const RSA_SSLV23_PADDING: number;\n    const RSA_NO_PADDING: number;\n    const RSA_PKCS1_OAEP_PADDING: number;\n    const RSA_X931_PADDING: number;\n    const RSA_PKCS1_PSS_PADDING: number;\n    const POINT_CONVERSION_COMPRESSED: number;\n    const POINT_CONVERSION_UNCOMPRESSED: number;\n    const POINT_CONVERSION_HYBRID: number;\n    const O_RDONLY: number;\n    const O_WRONLY: number;\n    const O_RDWR: number;\n    const S_IFMT: number;\n    const S_IFREG: number;\n    const S_IFDIR: number;\n    const S_IFCHR: number;\n    const S_IFBLK: number;\n    const S_IFIFO: number;\n    const S_IFSOCK: number;\n    const S_IRWXU: number;\n    const S_IRUSR: number;\n    const S_IWUSR: number;\n    const S_IXUSR: number;\n    const S_IRWXG: number;\n    const S_IRGRP: number;\n    const S_IWGRP: number;\n    const S_IXGRP: number;\n    const S_IRWXO: number;\n    const S_IROTH: number;\n    const S_IWOTH: number;\n    const S_IXOTH: number;\n    const S_IFLNK: number;\n    const O_CREAT: number;\n    const O_EXCL: number;\n    const O_NOCTTY: number;\n    const O_DIRECTORY: number;\n    const O_NOATIME: number;\n    const O_NOFOLLOW: number;\n    const O_SYNC: number;\n    const O_DSYNC: number;\n    const O_SYMLINK: number;\n    const O_DIRECT: number;\n    const O_NONBLOCK: number;\n    const O_TRUNC: number;\n    const O_APPEND: number;\n    const F_OK: number;\n    const R_OK: number;\n    const W_OK: number;\n    const X_OK: number;\n    const COPYFILE_EXCL: number;\n    const COPYFILE_FICLONE: number;\n    const COPYFILE_FICLONE_FORCE: number;\n    const UV_UDP_REUSEADDR: number;\n    const SIGQUIT: number;\n    const SIGTRAP: number;\n    const SIGIOT: number;\n    const SIGBUS: number;\n    const SIGUSR1: number;\n    const SIGUSR2: number;\n    const SIGPIPE: number;\n    const SIGALRM: number;\n    const SIGCHLD: number;\n    const SIGSTKFLT: number;\n    const SIGCONT: number;\n    const SIGSTOP: number;\n    const SIGTSTP: number;\n    const SIGTTIN: number;\n    const SIGTTOU: number;\n    const SIGURG: number;\n    const SIGXCPU: number;\n    const SIGXFSZ: number;\n    const SIGVTALRM: number;\n    const SIGPROF: number;\n    const SIGIO: number;\n    const SIGPOLL: number;\n    const SIGPWR: number;\n    const SIGSYS: number;\n    const SIGUNUSED: number;\n    const defaultCoreCipherList: string;\n    const defaultCipherList: string;\n    const ENGINE_METHOD_RSA: number;\n    const ALPN_ENABLED: number;\n}\n\ndeclare module "module" {\n    export = NodeJS.Module;\n}\n\ndeclare module "process" {\n    export = process;\n}\n\ndeclare module "v8" {\n    interface HeapSpaceInfo {\n        space_name: string;\n        space_size: number;\n        space_used_size: number;\n        space_available_size: number;\n        physical_space_size: number;\n    }\n\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\n    type DoesZapCodeSpaceFlag = 0 | 1;\n\n    interface HeapInfo {\n        total_heap_size: number;\n        total_heap_size_executable: number;\n        total_physical_size: number;\n        total_available_size: number;\n        used_heap_size: number;\n        heap_size_limit: number;\n        malloced_memory: number;\n        peak_malloced_memory: number;\n        does_zap_garbage: DoesZapCodeSpaceFlag;\n    }\n\n    function getHeapStatistics(): HeapInfo;\n    function getHeapSpaceStatistics(): HeapSpaceInfo[];\n    function setFlagsFromString(flags: string): void;\n}\n\ndeclare module "timers" {\n    function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    namespace setTimeout {\n        function __promisify__(ms: number): Promise<void>;\n        function __promisify__<T>(ms: number, value: T): Promise<T>;\n    }\n    function clearTimeout(timeoutId: NodeJS.Timeout): void;\n    function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS.Timeout;\n    function clearInterval(intervalId: NodeJS.Timeout): void;\n    function setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate;\n    namespace setImmediate {\n        function __promisify__(): Promise<void>;\n        function __promisify__<T>(value: T): Promise<T>;\n    }\n    function clearImmediate(immediateId: NodeJS.Immediate): void;\n}\n\ndeclare module "console" {\n    export = console;\n}\n\n/**\n * Async Hooks module: https://nodejs.org/api/async_hooks.html\n */\ndeclare module "async_hooks" {\n    /**\n     * Returns the asyncId of the current execution context.\n     */\n    function executionAsyncId(): number;\n\n    /**\n     * Returns the ID of the resource responsible for calling the callback that is currently being executed.\n     */\n    function triggerAsyncId(): number;\n\n    interface HookCallbacks {\n        /**\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\n         * @param asyncId a unique ID for the async resource\n         * @param type the type of the async resource\n         * @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created\n         * @param resource reference to the resource representing the async operation, needs to be released during destroy\n         */\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: Object): void;\n\n        /**\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\n         * The before callback is called just before said callback is executed.\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\n         */\n        before?(asyncId: number): void;\n\n        /**\n         * Called immediately after the callback specified in before is completed.\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\n         */\n        after?(asyncId: number): void;\n\n        /**\n         * Called when a promise has resolve() called. This may not be in the same execution id\n         * as the promise itself.\n         * @param asyncId the unique id for the promise that was resolve()d.\n         */\n        promiseResolve?(asyncId: number): void;\n\n        /**\n         * Called after the resource corresponding to asyncId is destroyed\n         * @param asyncId a unique ID for the async resource\n         */\n        destroy?(asyncId: number): void;\n    }\n\n    interface AsyncHook {\n        /**\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\n         */\n        enable(): this;\n\n        /**\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\n         */\n        disable(): this;\n    }\n\n    /**\n     * Registers functions to be called for different lifetime events of each async operation.\n     * @param options the callbacks to register\n     * @return an AsyncHooks instance used for disabling and enabling hooks\n     */\n    function createHook(options: HookCallbacks): AsyncHook;\n\n    interface AsyncResourceOptions {\n      /**\n       * The ID of the execution context that created this async event.\n       * Default: `executionAsyncId()`\n       */\n      triggerAsyncId?: number;\n\n      /**\n       * Disables automatic `emitDestroy` when the object is garbage collected.\n       * This usually does not need to be set (even if `emitDestroy` is called\n       * manually), unless the resource\'s `asyncId` is retrieved and the\n       * sensitive API\'s `emitDestroy` is called with it.\n       * Default: `false`\n       */\n      requireManualDestroy?: boolean;\n    }\n\n    /**\n     * The class AsyncResource was designed to be extended by the embedder\'s async resources.\n     * Using this users can easily trigger the lifetime events of their own resources.\n     */\n    class AsyncResource {\n        /**\n         * AsyncResource() is meant to be extended. Instantiating a\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n         * async_hook.executionAsyncId() is used.\n         * @param type The type of async event.\n         * @param triggerAsyncId The ID of the execution context that created\n         *   this async event (default: `executionAsyncId()`), or an\n         *   AsyncResourceOptions object (since 9.3)\n         */\n        constructor(type: string, triggerAsyncId?: number|AsyncResourceOptions);\n\n        /**\n         * Call AsyncHooks before callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitBefore(): void;\n\n        /**\n         * Call AsyncHooks after callbacks.\n         * @deprecated since 9.6 - Use asyncResource.runInAsyncScope() instead.\n         */\n        emitAfter(): void;\n\n        /**\n         * Call the provided function with the provided arguments in the\n         * execution context of the async resource. This will establish the\n         * context, trigger the AsyncHooks before callbacks, call the function,\n         * trigger the AsyncHooks after callbacks, and then restore the original\n         * execution context.\n         * @param fn The function to call in the execution context of this\n         *   async resource.\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runInAsyncScope<This, Result>(fn: (this: This, ...args: any[]) => Result, thisArg?: This, ...args: any[]): Result;\n\n        /**\n         * Call AsyncHooks destroy callbacks.\n         */\n        emitDestroy(): void;\n\n        /**\n         * @return the unique ID assigned to this AsyncResource instance.\n         */\n        asyncId(): number;\n\n        /**\n         * @return the trigger ID for this AsyncResource instance.\n         */\n        triggerAsyncId(): number;\n    }\n}\n\ndeclare module "http2" {\n    import * as events from "events";\n    import * as fs from "fs";\n    import * as net from "net";\n    import * as stream from "stream";\n    import * as tls from "tls";\n    import * as url from "url";\n\n    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders } from "http";\n    export { OutgoingHttpHeaders } from "http";\n\n    export interface IncomingHttpStatusHeader {\n        ":status"?: number;\n    }\n\n    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {\n        ":path"?: string;\n        ":method"?: string;\n        ":authority"?: string;\n        ":scheme"?: string;\n    }\n\n    // Http2Stream\n\n    export interface StreamPriorityOptions {\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        silent?: boolean;\n    }\n\n    export interface StreamState {\n        localWindowSize?: number;\n        state?: number;\n        streamLocalClose?: number;\n        streamRemoteClose?: number;\n        sumDependencyWeight?: number;\n        weight?: number;\n    }\n\n    export interface ServerStreamResponseOptions {\n        endStream?: boolean;\n        waitForTrailers?: boolean;\n    }\n\n    export interface StatOptions {\n        offset: number;\n        length: number;\n    }\n\n    export interface ServerStreamFileResponseOptions {\n        statCheck?: (stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions) => void | boolean;\n        getTrailers?: (trailers: OutgoingHttpHeaders) => void;\n        offset?: number;\n        length?: number;\n    }\n\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\n        onError?: (err: NodeJS.ErrnoException) => void;\n    }\n\n    export interface Http2Stream extends stream.Duplex {\n        readonly aborted: boolean;\n        readonly closed: boolean;\n        readonly destroyed: boolean;\n        readonly pending: boolean;\n        readonly rstCode: number;\n        readonly sentHeaders: OutgoingHttpHeaders;\n        readonly sentInfoHeaders?: OutgoingHttpHeaders[];\n        readonly sentTrailers?: OutgoingHttpHeaders;\n        readonly session: Http2Session;\n        readonly state: StreamState;\n        /**\n         * Set the true if the END_STREAM flag was set in the request or response HEADERS frame received,\n         * indicating that no additional data should be received and the readable side of the Http2Stream will be closed.\n         */\n        readonly endAfterHeaders: boolean;\n        close(code?: number, callback?: () => void): void;\n        priority(options: StreamPriorityOptions): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "aborted", listener: () => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "end", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "finish", listener: () => void): this;\n        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;\n        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;\n        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;\n        addListener(event: "streamClosed", listener: (code: number) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: "wantTrailers", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "aborted"): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "data", chunk: Buffer | string): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "end"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "finish"): boolean;\n        emit(event: "frameError", frameType: number, errorCode: number): boolean;\n        emit(event: "pipe", src: stream.Readable): boolean;\n        emit(event: "unpipe", src: stream.Readable): boolean;\n        emit(event: "streamClosed", code: number): boolean;\n        emit(event: "timeout"): boolean;\n        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: "wantTrailers"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "aborted", listener: () => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "data", listener: (chunk: Buffer | string) => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "end", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "finish", listener: () => void): this;\n        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;\n        on(event: "pipe", listener: (src: stream.Readable) => void): this;\n        on(event: "unpipe", listener: (src: stream.Readable) => void): this;\n        on(event: "streamClosed", listener: (code: number) => void): this;\n        on(event: "timeout", listener: () => void): this;\n        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: "wantTrailers", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "aborted", listener: () => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "data", listener: (chunk: Buffer | string) => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "end", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "finish", listener: () => void): this;\n        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;\n        once(event: "pipe", listener: (src: stream.Readable) => void): this;\n        once(event: "unpipe", listener: (src: stream.Readable) => void): this;\n        once(event: "streamClosed", listener: (code: number) => void): this;\n        once(event: "timeout", listener: () => void): this;\n        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: "wantTrailers", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "aborted", listener: () => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "end", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "finish", listener: () => void): this;\n        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;\n        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;\n        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;\n        prependListener(event: "streamClosed", listener: (code: number) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: "wantTrailers", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "aborted", listener: () => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "end", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "finish", listener: () => void): this;\n        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;\n        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: "wantTrailers", listener: () => void): this;\n\n        sendTrailers(headers: OutgoingHttpHeaders): this;\n    }\n\n    export interface ClientHttp2Stream extends Http2Stream {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "headers", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: "response", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "headers", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: "response", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "headers", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: "response", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "headers", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: "response", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "headers", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: "response", listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface ServerHttp2Stream extends Http2Stream {\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\n        readonly headersSent: boolean;\n        readonly pushAllowed: boolean;\n        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\n        respondWithFD(fd: number, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptions): void;\n        respondWithFile(path: string, headers?: OutgoingHttpHeaders, options?: ServerStreamFileResponseOptionsWithError): void;\n    }\n\n    // Http2Session\n\n    export interface Settings {\n        headerTableSize?: number;\n        enablePush?: boolean;\n        initialWindowSize?: number;\n        maxFrameSize?: number;\n        maxConcurrentStreams?: number;\n        maxHeaderListSize?: number;\n    }\n\n    export interface ClientSessionRequestOptions {\n        endStream?: boolean;\n        exclusive?: boolean;\n        parent?: number;\n        weight?: number;\n        getTrailers?: (trailers: OutgoingHttpHeaders, flags: number) => void;\n    }\n\n    export interface SessionState {\n        effectiveLocalWindowSize?: number;\n        effectiveRecvDataLength?: number;\n        nextStreamID?: number;\n        localWindowSize?: number;\n        lastProcStreamID?: number;\n        remoteWindowSize?: number;\n        outboundQueueSize?: number;\n        deflateDynamicTableSize?: number;\n        inflateDynamicTableSize?: number;\n    }\n\n    export interface Http2Session extends events.EventEmitter {\n        readonly alpnProtocol?: string;\n        close(callback?: () => void): void;\n        readonly closed: boolean;\n        readonly connecting: boolean;\n        destroy(error?: Error, code?: number): void;\n        readonly destroyed: boolean;\n        readonly encrypted?: boolean;\n        goaway(code?: number, lastStreamID?: number, opaqueData?: Buffer | DataView | NodeJS.TypedArray): void;\n        readonly localSettings: Settings;\n        readonly originSet?: string[];\n        readonly pendingSettingsAck: boolean;\n        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ping(payload: Buffer | DataView | NodeJS.TypedArray , callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ref(): void;\n        readonly remoteSettings: Settings;\n        rstStream(stream: Http2Stream, code?: number): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        readonly socket: net.Socket | tls.TLSSocket;\n        readonly state: SessionState;\n        priority(stream: Http2Stream, options: StreamPriorityOptions): void;\n        settings(settings: Settings): void;\n        readonly type: number;\n        unref(): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        addListener(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        addListener(event: "localSettings", listener: (settings: Settings) => void): this;\n        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n        addListener(event: "ping", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;\n        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;\n        emit(event: "localSettings", settings: Settings): boolean;\n        emit(event: "remoteSettings", settings: Settings): boolean;\n        emit(event: "timeout"): boolean;\n        emit(event: "ping"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        on(event: "localSettings", listener: (settings: Settings) => void): this;\n        on(event: "remoteSettings", listener: (settings: Settings) => void): this;\n        on(event: "timeout", listener: () => void): this;\n        on(event: "ping", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        once(event: "localSettings", listener: (settings: Settings) => void): this;\n        once(event: "remoteSettings", listener: (settings: Settings) => void): this;\n        once(event: "timeout", listener: () => void): this;\n        once(event: "ping", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependListener(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;\n        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n        prependListener(event: "ping", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        prependOnceListener(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;\n        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n        prependOnceListener(event: "ping", listener: () => void): this;\n    }\n\n    export interface ClientHttp2Session extends Http2Session {\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;\n        addListener(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: "stream", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;\n        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: "stream", stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;\n        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: "stream", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;\n        once(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: "stream", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependListener(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: "stream", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependOnceListener(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: "stream", listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;\n    }\n\n    export interface AlternativeServiceOptions {\n        origin: number | string | url.URL;\n    }\n\n    export interface ServerHttp2Session extends Http2Session {\n        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;\n        readonly server: Http2Server | Http2SecureServer;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        addListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "connect", session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        once(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "connect", listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        prependOnceListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n    }\n\n    // Http2Server\n\n    export interface SessionOptions {\n        maxDeflateDynamicTableSize?: number;\n        maxReservedRemoteStreams?: number;\n        maxSendHeaderBlockLength?: number;\n        paddingStrategy?: number;\n        peerMaxConcurrentStreams?: number;\n        selectPadding?: (frameLen: number, maxFrameLen: number) => number;\n        settings?: Settings;\n        createConnection?: (option: SessionOptions) => stream.Duplex;\n    }\n\n    export type ClientSessionOptions = SessionOptions;\n    export type ServerSessionOptions = SessionOptions;\n\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions { }\n    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions { }\n\n    export interface ServerOptions extends ServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface SecureServerOptions extends SecureServerSessionOptions {\n        allowHTTP1?: boolean;\n    }\n\n    export interface Http2Server extends net.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: "sessionError", listener: (err: Error) => void): this;\n        addListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "checkContinue", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: "request", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: "sessionError", err: Error): boolean;\n        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: "timeout"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: "sessionError", listener: (err: Error) => void): this;\n        on(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: "timeout", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: "sessionError", listener: (err: Error) => void): this;\n        once(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: "timeout", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: "sessionError", listener: (err: Error) => void): this;\n        prependListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;\n        prependOnceListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n    }\n\n    export interface Http2SecureServer extends tls.Server {\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        addListener(event: "sessionError", listener: (err: Error) => void): this;\n        addListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "checkContinue", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: "request", request: Http2ServerRequest, response: Http2ServerResponse): boolean;\n        emit(event: "sessionError", err: Error): boolean;\n        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: "timeout"): boolean;\n        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        on(event: "sessionError", listener: (err: Error) => void): this;\n        on(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: "timeout", listener: () => void): this;\n        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        once(event: "sessionError", listener: (err: Error) => void): this;\n        once(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: "timeout", listener: () => void): this;\n        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependListener(event: "sessionError", listener: (err: Error) => void): this;\n        prependListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "checkContinue", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: "request", listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;\n        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;\n        prependOnceListener(event: "stream", listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;\n    }\n\n    export class Http2ServerRequest extends stream.Readable {\n        private constructor();\n        headers: IncomingHttpHeaders;\n        httpVersion: string;\n        method: string;\n        rawHeaders: string[];\n        rawTrailers: string[];\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        stream: ServerHttp2Stream;\n        trailers: IncomingHttpHeaders;\n        url: string;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "aborted", hadError: boolean, code: number): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n    }\n\n    export class Http2ServerResponse extends events.EventEmitter {\n        private constructor();\n        addTrailers(trailers: OutgoingHttpHeaders): void;\n        connection: net.Socket | tls.TLSSocket;\n        end(callback?: () => void): void;\n        end(data?: string | Buffer, callback?: () => void): void;\n        end(data?: string | Buffer, encoding?: string, callback?: () => void): void;\n        readonly finished: boolean;\n        getHeader(name: string): string;\n        getHeaderNames(): string[];\n        getHeaders(): OutgoingHttpHeaders;\n        hasHeader(name: string): boolean;\n        readonly headersSent: boolean;\n        removeHeader(name: string): void;\n        sendDate: boolean;\n        setHeader(name: string, value: number | string | string[]): void;\n        setTimeout(msecs: number, callback?: () => void): void;\n        socket: net.Socket | tls.TLSSocket;\n        statusCode: number;\n        statusMessage: \'\';\n        stream: ServerHttp2Stream;\n        write(chunk: string | Buffer, callback?: (err: Error) => void): boolean;\n        write(chunk: string | Buffer, encoding?: string, callback?: (err: Error) => void): boolean;\n        writeContinue(): void;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): void;\n        writeHead(statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders): void;\n        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;\n\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "error", listener: (error: Error) => void): this;\n        addListener(event: "finish", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "aborted", hadError: boolean, code: number): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "error", error: Error): boolean;\n        emit(event: "finish"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "error", listener: (error: Error) => void): this;\n        on(event: "finish", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "error", listener: (error: Error) => void): this;\n        once(event: "finish", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "error", listener: (error: Error) => void): this;\n        prependListener(event: "finish", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (error: Error) => void): this;\n        prependOnceListener(event: "finish", listener: () => void): this;\n    }\n\n    // Public API\n\n    export namespace constants {\n        const NGHTTP2_SESSION_SERVER: number;\n        const NGHTTP2_SESSION_CLIENT: number;\n        const NGHTTP2_STREAM_STATE_IDLE: number;\n        const NGHTTP2_STREAM_STATE_OPEN: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_CLOSED: number;\n        const NGHTTP2_NO_ERROR: number;\n        const NGHTTP2_PROTOCOL_ERROR: number;\n        const NGHTTP2_INTERNAL_ERROR: number;\n        const NGHTTP2_FLOW_CONTROL_ERROR: number;\n        const NGHTTP2_SETTINGS_TIMEOUT: number;\n        const NGHTTP2_STREAM_CLOSED: number;\n        const NGHTTP2_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_REFUSED_STREAM: number;\n        const NGHTTP2_CANCEL: number;\n        const NGHTTP2_COMPRESSION_ERROR: number;\n        const NGHTTP2_CONNECT_ERROR: number;\n        const NGHTTP2_ENHANCE_YOUR_CALM: number;\n        const NGHTTP2_INADEQUATE_SECURITY: number;\n        const NGHTTP2_HTTP_1_1_REQUIRED: number;\n        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_FLAG_NONE: number;\n        const NGHTTP2_FLAG_END_STREAM: number;\n        const NGHTTP2_FLAG_END_HEADERS: number;\n        const NGHTTP2_FLAG_ACK: number;\n        const NGHTTP2_FLAG_PADDED: number;\n        const NGHTTP2_FLAG_PRIORITY: number;\n        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\n        const DEFAULT_SETTINGS_ENABLE_PUSH: number;\n        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\n        const MAX_MAX_FRAME_SIZE: number;\n        const MIN_MAX_FRAME_SIZE: number;\n        const MAX_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_DEFAULT_WEIGHT: number;\n        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\n        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\n        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\n        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\n        const PADDING_STRATEGY_NONE: number;\n        const PADDING_STRATEGY_MAX: number;\n        const PADDING_STRATEGY_CALLBACK: number;\n        const HTTP2_HEADER_STATUS: string;\n        const HTTP2_HEADER_METHOD: string;\n        const HTTP2_HEADER_AUTHORITY: string;\n        const HTTP2_HEADER_SCHEME: string;\n        const HTTP2_HEADER_PATH: string;\n        const HTTP2_HEADER_ACCEPT_CHARSET: string;\n        const HTTP2_HEADER_ACCEPT_ENCODING: string;\n        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\n        const HTTP2_HEADER_ACCEPT_RANGES: string;\n        const HTTP2_HEADER_ACCEPT: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\n        const HTTP2_HEADER_AGE: string;\n        const HTTP2_HEADER_ALLOW: string;\n        const HTTP2_HEADER_AUTHORIZATION: string;\n        const HTTP2_HEADER_CACHE_CONTROL: string;\n        const HTTP2_HEADER_CONNECTION: string;\n        const HTTP2_HEADER_CONTENT_DISPOSITION: string;\n        const HTTP2_HEADER_CONTENT_ENCODING: string;\n        const HTTP2_HEADER_CONTENT_LANGUAGE: string;\n        const HTTP2_HEADER_CONTENT_LENGTH: string;\n        const HTTP2_HEADER_CONTENT_LOCATION: string;\n        const HTTP2_HEADER_CONTENT_MD5: string;\n        const HTTP2_HEADER_CONTENT_RANGE: string;\n        const HTTP2_HEADER_CONTENT_TYPE: string;\n        const HTTP2_HEADER_COOKIE: string;\n        const HTTP2_HEADER_DATE: string;\n        const HTTP2_HEADER_ETAG: string;\n        const HTTP2_HEADER_EXPECT: string;\n        const HTTP2_HEADER_EXPIRES: string;\n        const HTTP2_HEADER_FROM: string;\n        const HTTP2_HEADER_HOST: string;\n        const HTTP2_HEADER_IF_MATCH: string;\n        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\n        const HTTP2_HEADER_IF_NONE_MATCH: string;\n        const HTTP2_HEADER_IF_RANGE: string;\n        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\n        const HTTP2_HEADER_LAST_MODIFIED: string;\n        const HTTP2_HEADER_LINK: string;\n        const HTTP2_HEADER_LOCATION: string;\n        const HTTP2_HEADER_MAX_FORWARDS: string;\n        const HTTP2_HEADER_PREFER: string;\n        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\n        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\n        const HTTP2_HEADER_RANGE: string;\n        const HTTP2_HEADER_REFERER: string;\n        const HTTP2_HEADER_REFRESH: string;\n        const HTTP2_HEADER_RETRY_AFTER: string;\n        const HTTP2_HEADER_SERVER: string;\n        const HTTP2_HEADER_SET_COOKIE: string;\n        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\n        const HTTP2_HEADER_TRANSFER_ENCODING: string;\n        const HTTP2_HEADER_TE: string;\n        const HTTP2_HEADER_UPGRADE: string;\n        const HTTP2_HEADER_USER_AGENT: string;\n        const HTTP2_HEADER_VARY: string;\n        const HTTP2_HEADER_VIA: string;\n        const HTTP2_HEADER_WWW_AUTHENTICATE: string;\n        const HTTP2_HEADER_HTTP2_SETTINGS: string;\n        const HTTP2_HEADER_KEEP_ALIVE: string;\n        const HTTP2_HEADER_PROXY_CONNECTION: string;\n        const HTTP2_METHOD_ACL: string;\n        const HTTP2_METHOD_BASELINE_CONTROL: string;\n        const HTTP2_METHOD_BIND: string;\n        const HTTP2_METHOD_CHECKIN: string;\n        const HTTP2_METHOD_CHECKOUT: string;\n        const HTTP2_METHOD_CONNECT: string;\n        const HTTP2_METHOD_COPY: string;\n        const HTTP2_METHOD_DELETE: string;\n        const HTTP2_METHOD_GET: string;\n        const HTTP2_METHOD_HEAD: string;\n        const HTTP2_METHOD_LABEL: string;\n        const HTTP2_METHOD_LINK: string;\n        const HTTP2_METHOD_LOCK: string;\n        const HTTP2_METHOD_MERGE: string;\n        const HTTP2_METHOD_MKACTIVITY: string;\n        const HTTP2_METHOD_MKCALENDAR: string;\n        const HTTP2_METHOD_MKCOL: string;\n        const HTTP2_METHOD_MKREDIRECTREF: string;\n        const HTTP2_METHOD_MKWORKSPACE: string;\n        const HTTP2_METHOD_MOVE: string;\n        const HTTP2_METHOD_OPTIONS: string;\n        const HTTP2_METHOD_ORDERPATCH: string;\n        const HTTP2_METHOD_PATCH: string;\n        const HTTP2_METHOD_POST: string;\n        const HTTP2_METHOD_PRI: string;\n        const HTTP2_METHOD_PROPFIND: string;\n        const HTTP2_METHOD_PROPPATCH: string;\n        const HTTP2_METHOD_PUT: string;\n        const HTTP2_METHOD_REBIND: string;\n        const HTTP2_METHOD_REPORT: string;\n        const HTTP2_METHOD_SEARCH: string;\n        const HTTP2_METHOD_TRACE: string;\n        const HTTP2_METHOD_UNBIND: string;\n        const HTTP2_METHOD_UNCHECKOUT: string;\n        const HTTP2_METHOD_UNLINK: string;\n        const HTTP2_METHOD_UNLOCK: string;\n        const HTTP2_METHOD_UPDATE: string;\n        const HTTP2_METHOD_UPDATEREDIRECTREF: string;\n        const HTTP2_METHOD_VERSION_CONTROL: string;\n        const HTTP_STATUS_CONTINUE: number;\n        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\n        const HTTP_STATUS_PROCESSING: number;\n        const HTTP_STATUS_OK: number;\n        const HTTP_STATUS_CREATED: number;\n        const HTTP_STATUS_ACCEPTED: number;\n        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\n        const HTTP_STATUS_NO_CONTENT: number;\n        const HTTP_STATUS_RESET_CONTENT: number;\n        const HTTP_STATUS_PARTIAL_CONTENT: number;\n        const HTTP_STATUS_MULTI_STATUS: number;\n        const HTTP_STATUS_ALREADY_REPORTED: number;\n        const HTTP_STATUS_IM_USED: number;\n        const HTTP_STATUS_MULTIPLE_CHOICES: number;\n        const HTTP_STATUS_MOVED_PERMANENTLY: number;\n        const HTTP_STATUS_FOUND: number;\n        const HTTP_STATUS_SEE_OTHER: number;\n        const HTTP_STATUS_NOT_MODIFIED: number;\n        const HTTP_STATUS_USE_PROXY: number;\n        const HTTP_STATUS_TEMPORARY_REDIRECT: number;\n        const HTTP_STATUS_PERMANENT_REDIRECT: number;\n        const HTTP_STATUS_BAD_REQUEST: number;\n        const HTTP_STATUS_UNAUTHORIZED: number;\n        const HTTP_STATUS_PAYMENT_REQUIRED: number;\n        const HTTP_STATUS_FORBIDDEN: number;\n        const HTTP_STATUS_NOT_FOUND: number;\n        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\n        const HTTP_STATUS_NOT_ACCEPTABLE: number;\n        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\n        const HTTP_STATUS_REQUEST_TIMEOUT: number;\n        const HTTP_STATUS_CONFLICT: number;\n        const HTTP_STATUS_GONE: number;\n        const HTTP_STATUS_LENGTH_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_FAILED: number;\n        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\n        const HTTP_STATUS_URI_TOO_LONG: number;\n        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\n        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\n        const HTTP_STATUS_EXPECTATION_FAILED: number;\n        const HTTP_STATUS_TEAPOT: number;\n        const HTTP_STATUS_MISDIRECTED_REQUEST: number;\n        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\n        const HTTP_STATUS_LOCKED: number;\n        const HTTP_STATUS_FAILED_DEPENDENCY: number;\n        const HTTP_STATUS_UNORDERED_COLLECTION: number;\n        const HTTP_STATUS_UPGRADE_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_REQUIRED: number;\n        const HTTP_STATUS_TOO_MANY_REQUESTS: number;\n        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\n        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\n        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\n        const HTTP_STATUS_NOT_IMPLEMENTED: number;\n        const HTTP_STATUS_BAD_GATEWAY: number;\n        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\n        const HTTP_STATUS_GATEWAY_TIMEOUT: number;\n        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\n        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\n        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\n        const HTTP_STATUS_LOOP_DETECTED: number;\n        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\n        const HTTP_STATUS_NOT_EXTENDED: number;\n        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\n    }\n\n    export function getDefaultSettings(): Settings;\n    export function getPackedSettings(settings: Settings): Settings;\n    export function getUnpackedSettings(buf: Buffer | Uint8Array): Settings;\n\n    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;\n\n    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;\n\n    export function connect(authority: string | url.URL, listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;\n    export function connect(\n        authority: string | url.URL,\n        options?: ClientSessionOptions | SecureClientSessionOptions,\n        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n    ): ClientHttp2Session;\n}\n\ndeclare module "perf_hooks" {\n    import { AsyncResource } from "async_hooks";\n\n    interface PerformanceEntry {\n        /**\n         * The total number of milliseconds elapsed for this entry.\n         * This value will not be meaningful for all Performance Entry types.\n         */\n        readonly duration: number;\n\n        /**\n         * The name of the performance entry.\n         */\n        readonly name: string;\n\n        /**\n         * The high resolution millisecond timestamp marking the starting time of the Performance Entry.\n         */\n        readonly startTime: number;\n\n        /**\n         * The type of the performance entry.\n         * Currently it may be one of: \'node\', \'mark\', \'measure\', \'gc\', or \'function\'.\n         */\n        readonly entryType: string;\n\n        /**\n         * When performanceEntry.entryType is equal to \'gc\', the performance.kind property identifies\n         * the type of garbage collection operation that occurred.\n         * The value may be one of perf_hooks.constants.\n         */\n        readonly kind?: number;\n    }\n\n    interface PerformanceNodeTiming extends PerformanceEntry {\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process completed bootstrap.\n         */\n        readonly bootstrapComplete: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing ended.\n         */\n        readonly clusterSetupEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which cluster processing started.\n         */\n        readonly clusterSetupStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop exited.\n         */\n        readonly loopExit: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js event loop started.\n         */\n        readonly loopStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load ended.\n         */\n        readonly moduleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which main module load started.\n         */\n        readonly moduleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the Node.js process was initialized.\n         */\n        readonly nodeStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load ended.\n         */\n        readonly preloadModuleLoadEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which preload module load started.\n         */\n        readonly preloadModuleLoadStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing ended.\n         */\n        readonly thirdPartyMainEnd: number;\n\n        /**\n         * The high resolution millisecond timestamp at which third_party_main processing started.\n         */\n        readonly thirdPartyMainStart: number;\n\n        /**\n         * The high resolution millisecond timestamp at which the V8 platform was initialized.\n         */\n        readonly v8Start: number;\n    }\n\n    interface Performance {\n        /**\n         * If name is not provided, removes all PerformanceFunction objects from the Performance Timeline.\n         * If name is provided, removes entries with name.\n         * @param name\n         */\n        clearFunctions(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.\n         * If name is provided, removes only the named mark.\n         * @param name\n         */\n        clearMarks(name?: string): void;\n\n        /**\n         * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.\n         * If name is provided, removes only objects whose performanceEntry.name matches name.\n         */\n        clearMeasures(name?: string): void;\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         * @return list of all PerformanceEntry objects\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         * @param name\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * Returns a list of all PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         * @param type\n         * @return list of all PerformanceEntry objects\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n\n        /**\n         * Creates a new PerformanceMark entry in the Performance Timeline.\n         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always \'mark\',\n         * and whose performanceEntry.duration is always 0.\n         * Performance marks are used to mark specific significant moments in the Performance Timeline.\n         * @param name\n         */\n        mark(name?: string): void;\n\n        /**\n         * Creates a new PerformanceMeasure entry in the Performance Timeline.\n         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always \'measure\',\n         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.\n         *\n         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify\n         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,\n         * then startMark is set to timeOrigin by default.\n         *\n         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp\n         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.\n         * @param name\n         * @param startMark\n         * @param endMark\n         */\n        measure(name: string, startMark: string, endMark: string): void;\n\n        /**\n         * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.\n         */\n        readonly nodeTiming: PerformanceNodeTiming;\n\n        /**\n         * @return the current high resolution millisecond timestamp\n         */\n        now(): number;\n\n        /**\n         * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.\n         */\n        readonly timeOrigin: number;\n\n        /**\n         * Wraps a function within a new function that measures the running time of the wrapped function.\n         * A PerformanceObserver must be subscribed to the \'function\' event type in order for the timing details to be accessed.\n         * @param fn\n         */\n        timerify<T extends (...optionalParams: any[]) => any>(fn: T): T;\n    }\n\n    interface PerformanceObserverEntryList {\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime.\n         */\n        getEntries(): PerformanceEntry[];\n\n        /**\n         * @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByName(name: string, type?: string): PerformanceEntry[];\n\n        /**\n         * @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime\n         * whose performanceEntry.entryType is equal to type.\n         */\n        getEntriesByType(type: string): PerformanceEntry[];\n    }\n\n    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;\n\n    class PerformanceObserver extends AsyncResource {\n        constructor(callback: PerformanceObserverCallback);\n\n        /**\n         * Disconnects the PerformanceObserver instance from all notifications.\n         */\n        disconnect(): void;\n\n        /**\n         * Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.\n         * When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.\n         * Property buffered defaults to false.\n         * @param options\n         */\n        observe(options: { entryTypes: string[], buffered?: boolean }): void;\n    }\n\n    namespace constants {\n        const NODE_PERFORMANCE_GC_MAJOR: number;\n        const NODE_PERFORMANCE_GC_MINOR: number;\n        const NODE_PERFORMANCE_GC_INCREMENTAL: number;\n        const NODE_PERFORMANCE_GC_WEAKCB: number;\n    }\n\n    const performance: Performance;\n}\n'},214:function(e,n){e.exports='// Type definitions for Chrome extension development\n// Project: http://developer.chrome.com/extensions/\n// Definitions by: Matthew Kimber <https://github.com/matthewkimber>, otiai10 <https://github.com/otiai10>, couven92 <https://github.com/couven92>, RReverser <https://github.com/rreverser>, sreimer15 <https://github.com/sreimer15>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.4\n\n/// <reference types="filesystem" />\n\n////////////////////\n// Global object\n////////////////////\ninterface Window {\n    chrome: typeof chrome;\n}\n\n////////////////////\n// Accessibility Features\n////////////////////\n/**\n * Use the chrome.accessibilityFeatures API to manage Chrome\'s accessibility features. This API relies on the ChromeSetting prototype of the type API for getting and setting individual accessibility features. In order to get feature states the extension must request accessibilityFeatures.read permission. For modifying feature state, the extension needs accessibilityFeatures.modify permission. Note that accessibilityFeatures.modify does not imply accessibilityFeatures.read permission.\n * Availability: Since Chrome 37.\n * Permissions: "accessibilityFeatures.read"\n * Important: This API works only on Chrome OS.\n */\ndeclare namespace chrome.accessibilityFeatures {\n    export interface AccessibilityFeaturesGetArg {\n        /** Optional. Whether to return the value that applies to the incognito session (default false).  */\n        incognito?: boolean;\n    }\n\n    export interface AccessibilityFeaturesCallbackArg {\n        /** The value of the setting. */\n        value: any;\n        /**\n         * One of\n         * \u2022 not_controllable: cannot be controlled by any extension\n         * \u2022 controlled_by_other_extensions: controlled by extensions with higher precedence\n         * \u2022 controllable_by_this_extension: can be controlled by this extension\n         * \u2022 controlled_by_this_extension: controlled by this extension\n         */\n        levelOfControl: string;\n        /** Optional. Whether the effective value is specific to the incognito session. This property will only be present if the incognito property in the details parameter of get() was true.  */\n        incognitoSpecific?: boolean;\n    }\n\n    export interface AccessibilityFeaturesSetArg {\n        /**\n         * The value of the setting.\n         * Note that every setting has a specific value type, which is described together with the setting. An extension should not set a value of a different type.\n         */\n        value: any;\n        /**\n         * Optional.\n          * The scope of the ChromeSetting. One of\n         * \u2022 regular: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n         * \u2022 regular_only: setting for the regular profile only (not inherited by the incognito profile),\n         * \u2022 incognito_persistent: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n         * \u2022 incognito_session_only: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n         */\n        scope?: string;\n    }\n\n    export interface AccessibilityFeaturesClearArg {\n        /**\n         * Optional.\n          * The scope of the ChromeSetting. One of\n         * \u2022 regular: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n         * \u2022 regular_only: setting for the regular profile only (not inherited by the incognito profile),\n         * \u2022 incognito_persistent: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n         * \u2022 incognito_session_only: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n         */\n        scope?: string;\n    }\n\n    export interface AccessibilityFeaturesSetting {\n        /**\n         * Gets the value of a setting.\n         * @param details Which setting to consider.\n         * @param callback The callback parameter should be a function that looks like this:\n         * function(object details) {...};\n         */\n        get(details: AccessibilityFeaturesGetArg, callback: (details: AccessibilityFeaturesCallbackArg) => void): void;\n        /**\n         * Sets the value of a setting.\n         * @param details Which setting to change.\n         * @param callback Called at the completion of the set operation.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        set(details: AccessibilityFeaturesSetArg, callback?: () => void): void;\n        /**\n         * Clears the setting, restoring any default value.\n         * @param details Which setting to clear.\n         * @param callback Called at the completion of the clear operation.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        clear(details: AccessibilityFeaturesClearArg, callback?: () => void): void;\n    }\n\n    export var spokenFeedback: AccessibilityFeaturesSetting;\n    export var largeCursor: AccessibilityFeaturesSetting;\n    export var stickyKeys: AccessibilityFeaturesSetting;\n    export var highContrast: AccessibilityFeaturesSetting;\n    export var screenMagnifier: AccessibilityFeaturesSetting;\n    export var autoclick: AccessibilityFeaturesSetting;\n    export var virtualKeyboard: AccessibilityFeaturesSetting;\n    export var animationPolicy: AccessibilityFeaturesSetting;\n}\n\n////////////////////\n// Alarms\n////////////////////\n/**\n * Use the chrome.alarms API to schedule code to run periodically or at a specified time in the future.\n * Availability: Since Chrome 22.\n * Permissions:  "alarms"\n */\ndeclare namespace chrome.alarms {\n    export interface AlarmCreateInfo {\n        /** Optional. Length of time in minutes after which the onAlarm event should fire.  */\n        delayInMinutes?: number;\n        /** Optional. If set, the onAlarm event should fire every periodInMinutes minutes after the initial event specified by when or delayInMinutes. If not set, the alarm will only fire once.  */\n        periodInMinutes?: number;\n        /** Optional. Time at which the alarm should fire, in milliseconds past the epoch (e.g. Date.now() + n).  */\n        when?: number;\n    }\n\n    export interface Alarm {\n        /** Optional. If not null, the alarm is a repeating alarm and will fire again in periodInMinutes minutes.  */\n        periodInMinutes?: number;\n        /** Time at which this alarm was scheduled to fire, in milliseconds past the epoch (e.g. Date.now() + n). For performance reasons, the alarm may have been delayed an arbitrary amount beyond this. */\n        scheduledTime: number;\n        /** Name of this alarm. */\n        name: string;\n    }\n\n    export interface AlarmEvent extends chrome.events.Event<(alarm: Alarm) => void> { }\n\n    /**\n     * Creates an alarm. Near the time(s) specified by alarmInfo, the onAlarm event is fired. If there is another alarm with the same name (or no name if none is specified), it will be cancelled and replaced by this alarm.\n     * In order to reduce the load on the user\'s machine, Chrome limits alarms to at most once every 1 minute but may delay them an arbitrary amount more. That is, setting delayInMinutes or periodInMinutes to less than 1 will not be honored and will cause a warning. when can be set to less than 1 minute after "now" without warning but won\'t actually cause the alarm to fire for at least 1 minute.\n     * To help you debug your app or extension, when you\'ve loaded it unpacked, there\'s no limit to how often the alarm can fire.\n     * @param alarmInfo Describes when the alarm should fire. The initial time must be specified by either when or delayInMinutes (but not both). If periodInMinutes is set, the alarm will repeat every periodInMinutes minutes after the initial event. If neither when or delayInMinutes is set for a repeating alarm, periodInMinutes is used as the default for delayInMinutes.\n     */\n    export function create(alarmInfo: AlarmCreateInfo): void;\n    /**\n     * Creates an alarm. Near the time(s) specified by alarmInfo, the onAlarm event is fired. If there is another alarm with the same name (or no name if none is specified), it will be cancelled and replaced by this alarm.\n     * In order to reduce the load on the user\'s machine, Chrome limits alarms to at most once every 1 minute but may delay them an arbitrary amount more. That is, setting delayInMinutes or periodInMinutes to less than 1 will not be honored and will cause a warning. when can be set to less than 1 minute after "now" without warning but won\'t actually cause the alarm to fire for at least 1 minute.\n     * To help you debug your app or extension, when you\'ve loaded it unpacked, there\'s no limit to how often the alarm can fire.\n     * @param name Optional name to identify this alarm. Defaults to the empty string.\n     * @param alarmInfo Describes when the alarm should fire. The initial time must be specified by either when or delayInMinutes (but not both). If periodInMinutes is set, the alarm will repeat every periodInMinutes minutes after the initial event. If neither when or delayInMinutes is set for a repeating alarm, periodInMinutes is used as the default for delayInMinutes.\n     */\n    export function create(name: string, alarmInfo: AlarmCreateInfo): void;\n    /**\n     * Gets an array of all the alarms.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of Alarm alarms) {...};\n     */\n    export function getAll(callback: (alarms: Alarm[]) => void): void;\n    /**\n     * Clears all alarms.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean wasCleared) {...};\n     */\n    export function clearAll(callback?: (wasCleared: boolean) => void): void;\n    /**\n     * Clears the alarm with the given name.\n     * @param name The name of the alarm to clear. Defaults to the empty string.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean wasCleared) {...};\n     */\n    export function clear(name?: string, callback?: (wasCleared: boolean) => void): void;\n    /**\n     * Clears the alarm without a name.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean wasCleared) {...};\n     */\n    export function clear(callback: (wasCleared: boolean) => void): void;\n    /**\n     * Retrieves details about the specified alarm.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( Alarm alarm) {...};\n     */\n    export function get(callback: (alarm: Alarm) => void): void;\n    /**\n     * Retrieves details about the specified alarm.\n     * @param name The name of the alarm to get. Defaults to the empty string.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( Alarm alarm) {...};\n     */\n    export function get(name: string, callback: (alarm: Alarm) => void): void;\n\n    /** Fired when an alarm has elapsed. Useful for event pages. */\n    export var onAlarm: AlarmEvent;\n}\n\n////////////////////\n// Browser\n////////////////////\n/**\n * Use the chrome.browser API to interact with the Chrome browser associated with\n * the current application and Chrome profile.\n */\ndeclare namespace chrome.browser {\n    export interface Options {\n        /** The URL to navigate to when the new tab is initially opened. */\n        url: string;\n    }\n\n    /**\n     * Opens a new tab in a browser window associated with the current application\n     * and Chrome profile. If no browser window for the Chrome profile is opened,\n     * a new one is opened prior to creating the new tab.\n     * @param options Configures how the tab should be opened.\n     * @param callback Called when the tab was successfully\n     * created, or failed to be created. If failed, runtime.lastError will be set.\n     */\n    export function openTab(options: Options, callback: () => void): void;\n\n    /**\n    * Opens a new tab in a browser window associated with the current application\n    * and Chrome profile. If no browser window for the Chrome profile is opened,\n    * a new one is opened prior to creating the new tab. Since Chrome 42 only.\n    * @param options Configures how the tab should be opened.\n    */\n    export function openTab(options: Options): void;\n}\n\n////////////////////\n// Bookmarks\n////////////////////\n/**\n * Use the chrome.bookmarks API to create, organize, and otherwise manipulate bookmarks. Also see Override Pages, which you can use to create a custom Bookmark Manager page.\n * Availability: Since Chrome 5.\n * Permissions:  "bookmarks"\n */\ndeclare namespace chrome.bookmarks {\n    /** A node (either a bookmark or a folder) in the bookmark tree. Child nodes are ordered within their parent folder. */\n    export interface BookmarkTreeNode {\n        /** Optional. The 0-based position of this node within its parent folder.  */\n        index?: number;\n        /** Optional. When this node was created, in milliseconds since the epoch (new Date(dateAdded)).  */\n        dateAdded?: number;\n        /** The text displayed for the node. */\n        title: string;\n        /** Optional. The URL navigated to when a user clicks the bookmark. Omitted for folders.   */\n        url?: string;\n        /** Optional. When the contents of this folder last changed, in milliseconds since the epoch.   */\n        dateGroupModified?: number;\n        /** The unique identifier for the node. IDs are unique within the current profile, and they remain valid even after the browser is restarted.  */\n        id: string;\n        /** Optional. The id of the parent folder. Omitted for the root node.   */\n        parentId?: string;\n        /** Optional. An ordered list of children of this node.  */\n        children?: BookmarkTreeNode[];\n        /**\n         * Optional.\n          * Since Chrome 37.\n         * Indicates the reason why this node is unmodifiable. The managed value indicates that this node was configured by the system administrator or by the custodian of a supervised user. Omitted if the node can be modified by the user and the extension (default).\n         */\n        unmodifiable?: any;\n    }\n\n    export interface BookmarkRemoveInfo {\n        index: number;\n        parentId: string;\n        node: BookmarkTreeNode;\n    }\n\n    export interface BookmarkMoveInfo {\n        index: number;\n        oldIndex: number;\n        parentId: string;\n        oldParentId: string;\n    }\n\n    export interface BookmarkChangeInfo {\n        url?: string;\n        title: string;\n    }\n\n    export interface BookmarkReorderInfo {\n        childIds: string[];\n    }\n\n    export interface BookmarkRemovedEvent extends chrome.events.Event<(id: string, removeInfo: BookmarkRemoveInfo) => void> { }\n\n    export interface BookmarkImportEndedEvent extends chrome.events.Event<() => void> { }\n\n    export interface BookmarkMovedEvent extends chrome.events.Event<(id: string, moveInfo: BookmarkMoveInfo) => void> { }\n\n    export interface BookmarkImportBeganEvent extends chrome.events.Event<() => void> { }\n\n    export interface BookmarkChangedEvent extends chrome.events.Event<(id: string, changeInfo: BookmarkChangeInfo) => void> { }\n\n    export interface BookmarkCreatedEvent extends chrome.events.Event<(id: string, bookmark: BookmarkTreeNode) => void> { }\n\n    export interface BookmarkChildrenReordered extends chrome.events.Event<(id: string, reorderInfo: BookmarkReorderInfo) => void> { }\n\n    export interface BookmarkSearchQuery {\n        query?: string;\n        url?: string;\n        title?: string;\n    }\n\n    export interface BookmarkCreateArg {\n        /** Optional. Defaults to the Other Bookmarks folder.  */\n        parentId?: string;\n        index?: number;\n        title?: string;\n        url?: string;\n    }\n\n    export interface BookmarkDestinationArg {\n        parentId?: string;\n        index?: number;\n    }\n\n    export interface BookmarkChangesArg {\n        title?: string;\n        url?: string;\n    }\n\n    /** @deprecated since Chrome 38. Bookmark write operations are no longer limited by Chrome. */\n    export var MAX_WRITE_OPERATIONS_PER_HOUR: number;\n    /** @deprecated since Chrome 38. Bookmark write operations are no longer limited by Chrome. */\n    export var MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE: number;\n\n    /**\n     * Searches for BookmarkTreeNodes matching the given query. Queries specified with an object produce BookmarkTreeNodes matching all specified properties.\n     * @param query A string of words and quoted phrases that are matched against bookmark URLs and titles.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function search(query: string, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Searches for BookmarkTreeNodes matching the given query. Queries specified with an object produce BookmarkTreeNodes matching all specified properties.\n     * @param query An object with one or more of the properties query, url, and title specified. Bookmarks matching all specified properties will be produced.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function search(query: BookmarkSearchQuery, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Retrieves the entire Bookmarks hierarchy.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function getTree(callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Retrieves the recently added bookmarks.\n     * @param numberOfItems The maximum number of items to return.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function getRecent(numberOfItems: number, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Retrieves the specified BookmarkTreeNode.\n     * @param id A single string-valued id\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function get(id: string, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Retrieves the specified BookmarkTreeNode.\n     * @param idList An array of string-valued ids\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function get(idList: string[], callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Creates a bookmark or folder under the specified parentId. If url is NULL or missing, it will be a folder.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( BookmarkTreeNode result) {...};\n     */\n    export function create(bookmark: BookmarkCreateArg, callback?: (result: BookmarkTreeNode) => void): void;\n    /**\n     * Moves the specified BookmarkTreeNode to the provided location.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( BookmarkTreeNode result) {...};\n     */\n    export function move(id: string, destination: BookmarkDestinationArg, callback?: (result: BookmarkTreeNode) => void): void;\n    /**\n     * Updates the properties of a bookmark or folder. Specify only the properties that you want to change; unspecified properties will be left unchanged. Note: Currently, only \'title\' and \'url\' are supported.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( BookmarkTreeNode result) {...};\n     */\n    export function update(id: string, changes: BookmarkChangesArg, callback?: (result: BookmarkTreeNode) => void): void;\n    /**\n     * Removes a bookmark or an empty bookmark folder.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function remove(id: string, callback?: Function): void;\n    /**\n     * Retrieves the children of the specified BookmarkTreeNode id.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function getChildren(id: string, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Since Chrome 14.\n     * Retrieves part of the Bookmarks hierarchy, starting at the specified node.\n     * @param id The ID of the root of the subtree to retrieve.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of BookmarkTreeNode results) {...};\n     */\n    export function getSubTree(id: string, callback: (results: BookmarkTreeNode[]) => void): void;\n    /**\n     * Recursively removes a bookmark folder.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeTree(id: string, callback?: Function): void;\n\n    /** Fired when a bookmark or folder is removed. When a folder is removed recursively, a single notification is fired for the folder, and none for its contents. */\n    export var onRemoved: BookmarkRemovedEvent;\n    /** Fired when a bookmark import session is ended. */\n    export var onImportEnded: BookmarkImportEndedEvent;\n    /** Fired when a bookmark import session is begun. Expensive observers should ignore onCreated updates until onImportEnded is fired. Observers should still handle other notifications immediately. */\n    export var onImportBegan: BookmarkImportBeganEvent;\n    /** Fired when a bookmark or folder changes. Note: Currently, only title and url changes trigger this. */\n    export var onChanged: BookmarkChangedEvent;\n    /** Fired when a bookmark or folder is moved to a different parent folder. */\n    export var onMoved: BookmarkMovedEvent;\n    /** Fired when a bookmark or folder is created. */\n    export var onCreated: BookmarkCreatedEvent;\n    /** Fired when the children of a folder have changed their order due to the order being sorted in the UI. This is not called as a result of a move(). */\n    export var onChildrenReordered: BookmarkChildrenReordered;\n}\n\n////////////////////\n// Browser Action\n////////////////////\n/**\n * Use browser actions to put icons in the main Google Chrome toolbar, to the right of the address bar. In addition to its icon, a browser action can also have a tooltip, a badge, and a popup.\n * Availability: Since Chrome 5.\n * Manifest:  "browser_action": {...}\n */\ndeclare namespace chrome.browserAction {\n    export interface BadgeBackgroundColorDetails {\n        /** An array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is [255, 0, 0, 255]. Can also be a string with a CSS value, with opaque red being #FF0000 or #F00. */\n        color: string | ColorArray;\n        /** Optional. Limits the change to when a particular tab is selected. Automatically resets when the tab is closed.  */\n        tabId?: number;\n    }\n\n    export interface BadgeTextDetails {\n        /** Any number of characters can be passed, but only about four can fit in the space. */\n        text: string;\n        /** Optional. Limits the change to when a particular tab is selected. Automatically resets when the tab is closed.  */\n        tabId?: number;\n    }\n\n    export type ColorArray = [number, number, number, number];\n\n    export interface TitleDetails {\n        /** The string the browser action should display when moused over. */\n        title: string;\n        /** Optional. Limits the change to when a particular tab is selected. Automatically resets when the tab is closed.  */\n        tabId?: number;\n    }\n\n    export interface TabDetails {\n        /** Optional. Specify the tab to get the information. If no tab is specified, the non-tab-specific information is returned.  */\n        tabId?: number;\n    }\n\n    export interface TabIconDetails {\n        /** Optional. Either a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen\'s pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * 19 will be selected. Initially only scales 1 and 2 will be supported. At least one image must be specified. Note that \'details.path = foo\' is equivalent to \'details.imageData = {\'19\': foo}\'  */\n        path?: any;\n        /** Optional. Limits the change to when a particular tab is selected. Automatically resets when the tab is closed.  */\n        tabId?: number;\n        /** Optional. Either an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen\'s pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * 19 will be selected. Initially only scales 1 and 2 will be supported. At least one image must be specified. Note that \'details.imageData = foo\' is equivalent to \'details.imageData = {\'19\': foo}\'  */\n        imageData?: ImageData | { [index: number]: ImageData };\n    }\n\n    export interface PopupDetails {\n        /** Optional. Limits the change to when a particular tab is selected. Automatically resets when the tab is closed.  */\n        tabId?: number;\n        /** The html file to show in a popup. If set to the empty string (\'\'), no popup is shown. */\n        popup: string;\n    }\n\n    export interface BrowserClickedEvent extends chrome.events.Event<(tab: chrome.tabs.Tab) => void> { }\n\n    /**\n     * Since Chrome 22.\n     * Enables the browser action for a tab. By default, browser actions are enabled.\n     * @param tabId The id of the tab for which you want to modify the browser action.\n     */\n    export function enable(tabId?: number): void;\n    /** Sets the background color for the badge. */\n    export function setBadgeBackgroundColor(details: BadgeBackgroundColorDetails): void;\n    /** Sets the badge text for the browser action. The badge is displayed on top of the icon. */\n    export function setBadgeText(details: BadgeTextDetails): void;\n    /** Sets the title of the browser action. This shows up in the tooltip. */\n    export function setTitle(details: TitleDetails): void;\n    /**\n     * Since Chrome 19.\n     * Gets the badge text of the browser action. If no tab is specified, the non-tab-specific badge text is returned.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string result) {...};\n     */\n    export function getBadgeText(details: TabDetails, callback: (result: string) => void): void;\n    /** Sets the html document to be opened as a popup when the user clicks on the browser action\'s icon. */\n    export function setPopup(details: PopupDetails): void;\n    /**\n     * Since Chrome 22.\n     * Disables the browser action for a tab.\n     * @param tabId The id of the tab for which you want to modify the browser action.\n     */\n    export function disable(tabId?: number): void;\n    /**\n     * Since Chrome 19.\n     * Gets the title of the browser action.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string result) {...};\n     */\n    export function getTitle(details: TabDetails, callback: (result: string) => void): void;\n    /**\n     * Since Chrome 19.\n     * Gets the background color of the browser action.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( ColorArray result) {...};\n     */\n    export function getBadgeBackgroundColor(details: TabDetails, callback: (result: ColorArray) => void): void;\n    /**\n     * Since Chrome 19.\n     * Gets the html document set as the popup for this browser action.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string result) {...};\n     */\n    export function getPopup(details: TabDetails, callback: (result: string) => void): void;\n    /**\n     * Sets the icon for the browser action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setIcon(details: TabIconDetails, callback?: Function): void;\n\n    /** Fired when a browser action icon is clicked. This event will not fire if the browser action has a popup. */\n    export var onClicked: BrowserClickedEvent;\n}\n\n////////////////////\n// Browsing Data\n////////////////////\n/**\n * Use the chrome.browsingData API to remove browsing data from a user\'s local profile.\n * Availability: Since Chrome 19.\n * Permissions:  "browsingData"\n */\ndeclare namespace chrome.browsingData {\n    export interface OriginTypes {\n        /** Optional. Websites that have been installed as hosted applications (be careful!).  */\n        protectedWeb?: boolean;\n        /** Optional. Extensions and packaged applications a user has installed (be _really_ careful!).  */\n        extension?: boolean;\n        /** Optional. Normal websites.  */\n        unprotectedWeb?: boolean;\n    }\n\n    /** Options that determine exactly what data will be removed. */\n    export interface RemovalOptions {\n        /**\n         * Optional.\n          * Since Chrome 21.\n         * An object whose properties specify which origin types ought to be cleared. If this object isn\'t specified, it defaults to clearing only "unprotected" origins. Please ensure that you really want to remove application data before adding \'protectedWeb\' or \'extensions\'.\n         */\n        originTypes?: OriginTypes;\n        /** Optional. Remove data accumulated on or after this date, represented in milliseconds since the epoch (accessible via the getTime method of the JavaScript Date object). If absent, defaults to 0 (which would remove all browsing data).  */\n        since?: number;\n    }\n\n    /**\n     * Since Chrome 27.\n     * A set of data types. Missing data types are interpreted as false.\n     */\n    export interface DataTypeSet {\n        /** Optional. Websites\' WebSQL data.  */\n        webSQL?: boolean;\n        /** Optional. Websites\' IndexedDB data.  */\n        indexedDB?: boolean;\n        /** Optional. The browser\'s cookies.  */\n        cookies?: boolean;\n        /** Optional. Stored passwords.  */\n        passwords?: boolean;\n        /** Optional. Server-bound certificates.  */\n        serverBoundCertificates?: boolean;\n        /** Optional. The browser\'s download list.  */\n        downloads?: boolean;\n        /** Optional. The browser\'s cache. Note: when removing data, this clears the entire cache: it is not limited to the range you specify.  */\n        cache?: boolean;\n        /** Optional. Websites\' appcaches.  */\n        appcache?: boolean;\n        /** Optional. Websites\' file systems.  */\n        fileSystems?: boolean;\n        /** Optional. Plugins\' data.  */\n        pluginData?: boolean;\n        /** Optional. Websites\' local storage data.  */\n        localStorage?: boolean;\n        /** Optional. The browser\'s stored form data.  */\n        formData?: boolean;\n        /** Optional. The browser\'s history.  */\n        history?: boolean;\n        /**\n         * Optional.\n          * Since Chrome 39.\n         * Service Workers.\n         */\n        serviceWorkers?: boolean;\n    }\n\n    export interface SettingsCallback {\n        options: RemovalOptions;\n        /** All of the types will be present in the result, with values of true if they are both selected to be removed and permitted to be removed, otherwise false. */\n        dataToRemove: DataTypeSet;\n        /** All of the types will be present in the result, with values of true if they are permitted to be removed (e.g., by enterprise policy) and false if not. */\n        dataRemovalPermitted: DataTypeSet;\n    }\n\n    /**\n     * Since Chrome 26.\n     * Reports which types of data are currently selected in the \'Clear browsing data\' settings UI. Note: some of the data types included in this API are not available in the settings UI, and some UI settings control more than one data type listed here.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(object result) {...};\n     */\n    export function settings(callback: (result: SettingsCallback) => void): void;\n    /**\n     * Clears plugins\' data.\n     * @param callback Called when plugins\' data has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removePluginData(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears the browser\'s stored form data (autofill).\n     * @param callback Called when the browser\'s form data has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeFormData(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears websites\' file system data.\n     * @param callback Called when websites\' file systems have been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeFileSystems(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears various types of browsing data stored in a user\'s profile.\n     * @param dataToRemove The set of data types to remove.\n     * @param callback Called when deletion has completed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function remove(options: RemovalOptions, dataToRemove: DataTypeSet, callback?: () => void): void;\n    /**\n     * Clears the browser\'s stored passwords.\n     * @param callback Called when the browser\'s passwords have been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removePasswords(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears the browser\'s cookies and server-bound certificates modified within a particular timeframe.\n     * @param callback Called when the browser\'s cookies and server-bound certificates have been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeCookies(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears websites\' WebSQL data.\n     * @param callback Called when websites\' WebSQL databases have been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeWebSQL(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears websites\' appcache data.\n     * @param callback Called when websites\' appcache data has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeAppcache(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears the browser\'s list of downloaded files (not the downloaded files themselves).\n     * @param callback Called when the browser\'s list of downloaded files has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeDownloads(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears websites\' local storage data.\n     * @param callback Called when websites\' local storage has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeLocalStorage(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears the browser\'s cache.\n     * @param callback Called when the browser\'s cache has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeCache(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears the browser\'s history.\n     * @param callback Called when the browser\'s history has cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeHistory(options: RemovalOptions, callback?: () => void): void;\n    /**\n     * Clears websites\' IndexedDB data.\n     * @param callback Called when websites\' IndexedDB data has been cleared.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeIndexedDB(options: RemovalOptions, callback?: () => void): void;\n}\n\n////////////////////\n// Commands\n////////////////////\n/**\n * Use the commands API to add keyboard shortcuts that trigger actions in your extension, for example, an action to open the browser action or send a command to the extension.\n * Availability: Since Chrome 25.\n * Manifest:  "commands": {...}\n */\ndeclare namespace chrome.commands {\n    export interface Command {\n        /** Optional. The name of the Extension Command  */\n        name?: string;\n        /** Optional. The Extension Command description  */\n        description?: string;\n        /** Optional. The shortcut active for this command, or blank if not active.  */\n        shortcut?: string;\n    }\n\n    export interface CommandEvent extends chrome.events.Event<(command: string) => void> { }\n\n    /**\n     * Returns all the registered extension commands for this extension and their shortcut (if active).\n     * @param callback Called to return the registered commands.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(array of Command commands) {...};\n     */\n    export function getAll(callback: (commands: Command[]) => void): void;\n\n    /** Fired when a registered command is activated using a keyboard shortcut. */\n    export var onCommand: CommandEvent;\n}\n\n////////////////////\n// Content Settings\n////////////////////\n/**\n * Use the chrome.contentSettings API to change settings that control whether websites can use features such as cookies, JavaScript, and plugins. More generally speaking, content settings allow you to customize Chrome\'s behavior on a per-site basis instead of globally.\n * Availability: Since Chrome 16.\n * Permissions:  "contentSettings"\n */\ndeclare namespace chrome.contentSettings {\n    export interface ClearDetails {\n        /**\n         * Optional.\n          * Where to clear the setting (default: regular).\n         * The scope of the ContentSetting. One of\n         * * regular: setting for regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n         * * incognito_session_only: setting for incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular settings).\n         */\n        scope?: string;\n    }\n\n    export interface SetDetails {\n        /** Optional. The resource identifier for the content type.  */\n        resourceIdentifier?: ResourceIdentifier;\n        /** The setting applied by this rule. See the description of the individual ContentSetting objects for the possible values. */\n        setting: any;\n        /** Optional. The pattern for the secondary URL. Defaults to matching all URLs. For details on the format of a pattern, see Content Setting Patterns.  */\n        secondaryPattern?: string;\n        /** Optional. Where to set the setting (default: regular).  */\n        scope?: string;\n        /** The pattern for the primary URL. For details on the format of a pattern, see Content Setting Patterns. */\n        primaryPattern: string;\n    }\n\n    export interface GetDetails {\n        /** Optional. The secondary URL for which the content setting should be retrieved. Defaults to the primary URL. Note that the meaning of a secondary URL depends on the content type, and not all content types use secondary URLs.  */\n        secondaryUrl?: string;\n        /** Optional. A more specific identifier of the type of content for which the settings should be retrieved.  */\n        resourceIdentifier?: ResourceIdentifier;\n        /** Optional. Whether to check the content settings for an incognito session. (default false)  */\n        incognito?: boolean;\n        /** The primary URL for which the content setting should be retrieved. Note that the meaning of a primary URL depends on the content type. */\n        primaryUrl: string;\n    }\n\n    export interface ReturnedDetails {\n        /** The content setting. See the description of the individual ContentSetting objects for the possible values. */\n        setting: any;\n    }\n\n    export interface ContentSetting {\n        /**\n         * Clear all content setting rules set by this extension.\n         * @param callback If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        clear(details: ClearDetails, callback?: () => void): void;\n        /**\n         * Applies a new content setting rule.\n         * @param callback If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        set(details: SetDetails, callback?: () => void): void;\n        /**\n         * @param callback The callback parameter should be a function that looks like this:\n         * function(array of ResourceIdentifier resourceIdentifiers) {...};\n         * Parameter resourceIdentifiers: A list of resource identifiers for this content type, or undefined if this content type does not use resource identifiers.\n         */\n        getResourceIdentifiers(callback: (resourceIdentifiers?: ResourceIdentifier[]) => void): void;\n        /**\n         * Gets the current content setting for a given pair of URLs.\n         * @param callback The callback parameter should be a function that looks like this:\n         * function(object details) {...};\n         */\n        get(details: GetDetails, callback: (details: ReturnedDetails) => void): void;\n    }\n\n    /** The only content type using resource identifiers is contentSettings.plugins. For more information, see Resource Identifiers. */\n    export interface ResourceIdentifier {\n        /** The resource identifier for the given content type. */\n        id: string;\n        /** Optional. A human readable description of the resource.  */\n        description?: string;\n    }\n\n    /**\n     * Whether to allow cookies and other local data to be set by websites. One of\n     * allow: Accept cookies,\n     * block: Block cookies,\n     * session_only: Accept cookies only for the current session.\n     * Default is allow.\n     * The primary URL is the URL representing the cookie origin. The secondary URL is the URL of the top-level frame.\n     */\n    export var cookies: ContentSetting;\n    /**\n     * Whether to allow sites to show pop-ups. One of\n     * allow: Allow sites to show pop-ups,\n     * block: Don\'t allow sites to show pop-ups.\n     * Default is block.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var popups: ContentSetting;\n    /**\n     * Whether to run JavaScript. One of\n     * allow: Run JavaScript,\n     * block: Don\'t run JavaScript.\n     * Default is allow.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var javascript: ContentSetting;\n    /**\n     * Whether to allow sites to show desktop notifications. One of\n     * allow: Allow sites to show desktop notifications,\n     * block: Don\'t allow sites to show desktop notifications,\n     * ask: Ask when a site wants to show desktop notifications.\n     * Default is ask.\n     * The primary URL is the URL of the document which wants to show the notification. The secondary URL is not used.\n     */\n    export var notifications: ContentSetting;\n    /**\n     * Whether to run plugins. One of\n     * allow: Run plugins automatically,\n     * block: Don\'t run plugins automatically,\n     * detect_important_content: Only run automatically those plugins that are detected as the website\'s main content.\n     * Default is allow.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var plugins: ContentSetting;\n    /**\n     * Whether to show images. One of\n     * allow: Show images,\n     * block: Don\'t show images.\n     * Default is allow.\n     * The primary URL is the URL of the top-level frame. The secondary URL is the URL of the image.\n     */\n    export var images: ContentSetting;\n    /**\n     * Since Chrome 42.\n     * Whether to allow Geolocation. One of\n     * allow: Allow sites to track your physical location,\n     * block: Don\'t allow sites to track your physical location,\n     * ask: Ask before allowing sites to track your physical location.\n     * Default is ask.\n     * The primary URL is the URL of the document which requested location data. The secondary URL is the URL of the top-level frame (which may or may not differ from the requesting URL).\n     */\n    export var location: ContentSetting;\n    /**\n     * Since Chrome 42.\n     * Whether to allow sites to toggle the fullscreen mode. One of\n     * allow: Allow sites to toggle the fullscreen mode,\n     * ask: Ask when a site wants to toggle the fullscreen mode.\n     * Default is ask.\n     * The primary URL is the URL of the document which requested to toggle the fullscreen mode. The secondary URL is the URL of the top-level frame (which may or may not differ from the requesting URL).\n     */\n    export var fullscreen: ContentSetting;\n    /**\n     * Since Chrome 42.\n     * Whether to allow sites to disable the mouse cursor. One of\n     * allow: Allow sites to disable the mouse cursor,\n     * block: Don\'t allow sites to disable the mouse cursor,\n     * ask: Ask when a site wants to disable the mouse cursor.\n     * Default is ask.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var mouselock: ContentSetting;\n    /**\n     * Since Chrome 42.\n     * Whether to allow sites to run plugins unsandboxed. One of\n     * allow: Allow sites to run plugins unsandboxed,\n     * block: Don\'t allow sites to run plugins unsandboxed,\n     * ask: Ask when a site wants to run a plugin unsandboxed.\n     * Default is ask.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var unsandboxedPlugins: ContentSetting;\n    /**\n     * Since Chrome 42.\n     * Whether to allow sites to download multiple files automatically. One of\n     * allow: Allow sites to download multiple files automatically,\n     * block: Don\'t allow sites to download multiple files automatically,\n     * ask: Ask when a site wants to download files automatically after the first file.\n     * Default is ask.\n     * The primary URL is the URL of the top-level frame. The secondary URL is not used.\n     */\n    export var automaticDownloads: ContentSetting;\n}\n\n////////////////////\n// Context Menus\n////////////////////\n/**\n * Use the chrome.contextMenus API to add items to Google Chrome\'s context menu. You can choose what types of objects your context menu additions apply to, such as images, hyperlinks, and pages.\n * Availability: Since Chrome 6.\n * Permissions:  "contextMenus"\n */\ndeclare namespace chrome.contextMenus {\n    export interface OnClickData {\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * The text for the context selection, if any.\n         */\n        selectionText?: string;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * A flag indicating the state of a checkbox or radio item after it is clicked.\n         */\n        checked?: boolean;\n        /**\n         * Since Chrome 35.\n         * The ID of the menu item that was clicked.\n         */\n        menuItemId: any;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * The URL of the frame of the element where the context menu was clicked, if it was in a frame.\n         */\n        frameUrl?: string;\n        /**\n         * Since Chrome 35.\n         * A flag indicating whether the element is editable (text input, textarea, etc.).\n         */\n        editable: boolean;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * One of \'image\', \'video\', or \'audio\' if the context menu was activated on one of these types of elements.\n         */\n        mediaType?: string;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * A flag indicating the state of a checkbox or radio item before it was clicked.\n         */\n        wasChecked?: boolean;\n        /**\n         * Since Chrome 35.\n         * The URL of the page where the menu item was clicked. This property is not set if the click occured in a context where there is no current page, such as in a launcher context menu.\n         */\n        pageUrl: string;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * If the element is a link, the URL it points to.\n         */\n        linkUrl?: string;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * The parent ID, if any, for the item clicked.\n         */\n        parentMenuItemId?: any;\n        /**\n         * Optional.\n          * Since Chrome 35.\n         * Will be present for elements with a \'src\' URL.\n         */\n        srcUrl?: string;\n    }\n\n    export interface CreateProperties {\n        /** Optional. Lets you restrict the item to apply only to documents whose URL matches one of the given patterns. (This applies to frames as well.) For details on the format of a pattern, see Match Patterns.  */\n        documentUrlPatterns?: string[];\n        /** Optional. The initial state of a checkbox or radio item: true for selected and false for unselected. Only one radio item can be selected at a time in a given group of radio items.  */\n        checked?: boolean;\n        /** Optional. The text to be displayed in the item; this is required unless type is \'separator\'. When the context is \'selection\', you can use %s within the string to show the selected text. For example, if this parameter\'s value is "Translate \'%s\' to Pig Latin" and the user selects the word "cool", the context menu item for the selection is "Translate \'cool\' to Pig Latin".  */\n        title?: string;\n        /** Optional. List of contexts this menu item will appear in. Defaults to [\'page\'] if not specified.  */\n        contexts?: string[];\n        /**\n         * Optional.\n          * Since Chrome 20.\n         * Whether this context menu item is enabled or disabled. Defaults to true.\n         */\n        enabled?: boolean;\n        /** Optional. Similar to documentUrlPatterns, but lets you filter based on the src attribute of img/audio/video tags and the href of anchor tags.  */\n        targetUrlPatterns?: string[];\n        /**\n         * Optional.\n          * A function that will be called back when the menu item is clicked. Event pages cannot use this; instead, they should register a listener for chrome.contextMenus.onClicked.\n         * @param info Information sent when a context menu item is clicked.\n         * @param tab The details of the tab where the click took place. Note: this parameter only present for extensions.\n         */\n        onclick?: (info: OnClickData, tab: chrome.tabs.Tab) => void;\n        /** Optional. The ID of a parent menu item; this makes the item a child of a previously added item.  */\n        parentId?: any;\n        /** Optional. The type of menu item. Defaults to \'normal\' if not specified.  */\n        type?: string;\n        /**\n         * Optional.\n          * Since Chrome 21.\n         * The unique ID to assign to this item. Mandatory for event pages. Cannot be the same as another ID for this extension.\n         */\n        id?: string;\n    }\n\n    export interface UpdateProperties {\n        documentUrlPatterns?: string[];\n        checked?: boolean;\n        title?: string;\n        contexts?: string[];\n        /** Optional. Since Chrome 20.  */\n        enabled?: boolean;\n        targetUrlPatterns?: string[];\n        onclick?: Function;\n        /** Optional. Note: You cannot change an item to be a child of one of its own descendants.  */\n        parentId?: any;\n        type?: string;\n    }\n\n    export interface MenuClickedEvent extends chrome.events.Event<(info: OnClickData, tab?: chrome.tabs.Tab) => void> { }\n\n    /**\n     * Since Chrome 38.\n     * The maximum number of top level extension items that can be added to an extension action context menu. Any items beyond this limit will be ignored.\n     */\n    export var ACTION_MENU_TOP_LEVEL_LIMIT: number;\n\n    /**\n     * Removes all context menu items added by this extension.\n     * @param callback Called when removal is complete.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeAll(callback?: () => void): void;\n    /**\n     * Creates a new context menu item. Note that if an error occurs during creation, you may not find out until the creation callback fires (the details will be in chrome.runtime.lastError).\n     * @param callback Called when the item has been created in the browser. If there were any problems creating the item, details will be available in chrome.runtime.lastError.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function create(createProperties: CreateProperties, callback?: () => void): void;\n    /**\n     * Updates a previously created context menu item.\n     * @param id The ID of the item to update.\n     * @param updateProperties The properties to update. Accepts the same values as the create function.\n     * @param callback Called when the context menu has been updated.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function update(id: string, updateProperties: UpdateProperties, callback?: () => void): void;\n    /**\n     * Updates a previously created context menu item.\n     * @param id The ID of the item to update.\n     * @param updateProperties The properties to update. Accepts the same values as the create function.\n     * @param callback Called when the context menu has been updated.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function update(id: number, updateProperties: UpdateProperties, callback?: () => void): void;\n    /**\n     * Removes a context menu item.\n     * @param menuItemId The ID of the context menu item to remove.\n     * @param callback Called when the context menu has been removed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function remove(menuItemId: string, callback?: () => void): void;\n    /**\n     * Removes a context menu item.\n     * @param menuItemId The ID of the context menu item to remove.\n     * @param callback Called when the context menu has been removed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function remove(menuItemId: number, callback?: () => void): void;\n\n    /**\n     * Since Chrome 21.\n     * Fired when a context menu item is clicked.\n     */\n    export var onClicked: MenuClickedEvent;\n}\n\n////////////////////\n// Cookies\n////////////////////\n/**\n * Use the chrome.cookies API to query and modify cookies, and to be notified when they change.\n * Availability: Since Chrome 6.\n * Permissions:  "cookies", host permissions\n */\ndeclare namespace chrome.cookies {\n    /** Represents information about an HTTP cookie. */\n    export interface Cookie {\n        /** The domain of the cookie (e.g. "www.google.com", "example.com"). */\n        domain: string;\n        /** The name of the cookie. */\n        name: string;\n        /** The ID of the cookie store containing this cookie, as provided in getAllCookieStores(). */\n        storeId: string;\n        /** The value of the cookie. */\n        value: string;\n        /** True if the cookie is a session cookie, as opposed to a persistent cookie with an expiration date. */\n        session: boolean;\n        /** True if the cookie is a host-only cookie (i.e. a request\'s host must exactly match the domain of the cookie). */\n        hostOnly: boolean;\n        /** Optional. The expiration date of the cookie as the number of seconds since the UNIX epoch. Not provided for session cookies.  */\n        expirationDate?: number;\n        /** The path of the cookie. */\n        path: string;\n        /** True if the cookie is marked as HttpOnly (i.e. the cookie is inaccessible to client-side scripts). */\n        httpOnly: boolean;\n        /** True if the cookie is marked as Secure (i.e. its scope is limited to secure channels, typically HTTPS). */\n        secure: boolean;\n    }\n\n    /** Represents a cookie store in the browser. An incognito mode window, for instance, uses a separate cookie store from a non-incognito window. */\n    export interface CookieStore {\n        /** The unique identifier for the cookie store. */\n        id: string;\n        /** Identifiers of all the browser tabs that share this cookie store. */\n        tabIds: number[];\n    }\n\n    export interface GetAllDetails {\n        /** Optional. Restricts the retrieved cookies to those whose domains match or are subdomains of this one.  */\n        domain?: string;\n        /** Optional. Filters the cookies by name.  */\n        name?: string;\n        /** Optional. Restricts the retrieved cookies to those that would match the given URL.  */\n        url?: string;\n        /** Optional. The cookie store to retrieve cookies from. If omitted, the current execution context\'s cookie store will be used.  */\n        storeId?: string;\n        /** Optional. Filters out session vs. persistent cookies.  */\n        session?: boolean;\n        /** Optional. Restricts the retrieved cookies to those whose path exactly matches this string.  */\n        path?: string;\n        /** Optional. Filters the cookies by their Secure property.  */\n        secure?: boolean;\n    }\n\n    export interface SetDetails {\n        /** Optional. The domain of the cookie. If omitted, the cookie becomes a host-only cookie.  */\n        domain?: string;\n        /** Optional. The name of the cookie. Empty by default if omitted.  */\n        name?: string;\n        /** The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie. If host permissions for this URL are not specified in the manifest file, the API call will fail. */\n        url: string;\n        /** Optional. The ID of the cookie store in which to set the cookie. By default, the cookie is set in the current execution context\'s cookie store.  */\n        storeId?: string;\n        /** Optional. The value of the cookie. Empty by default if omitted.  */\n        value?: string;\n        /** Optional. The expiration date of the cookie as the number of seconds since the UNIX epoch. If omitted, the cookie becomes a session cookie.  */\n        expirationDate?: number;\n        /** Optional. The path of the cookie. Defaults to the path portion of the url parameter.  */\n        path?: string;\n        /** Optional. Whether the cookie should be marked as HttpOnly. Defaults to false.  */\n        httpOnly?: boolean;\n        /** Optional. Whether the cookie should be marked as Secure. Defaults to false.  */\n        secure?: boolean;\n    }\n\n    export interface Details {\n        name: string;\n        url: string;\n        storeId?: string;\n    }\n\n    export interface CookieChangeInfo {\n        /** Information about the cookie that was set or removed. */\n        cookie: Cookie;\n        /** True if a cookie was removed. */\n        removed: boolean;\n        /**\n         * Since Chrome 12.\n         * The underlying reason behind the cookie\'s change.\n         */\n        cause: string;\n    }\n\n    export interface CookieChangedEvent extends chrome.events.Event<(changeInfo: CookieChangeInfo) => void> { }\n\n    /**\n     * Lists all existing cookie stores.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of CookieStore cookieStores) {...};\n     * Parameter cookieStores: All the existing cookie stores.\n     */\n    export function getAllCookieStores(callback: (cookieStores: CookieStore[]) => void): void;\n    /**\n     * Retrieves all cookies from a single cookie store that match the given information. The cookies returned will be sorted, with those with the longest path first. If multiple cookies have the same path length, those with the earliest creation time will be first.\n     * @param details Information to filter the cookies being retrieved.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of Cookie cookies) {...};\n     * Parameter cookies: All the existing, unexpired cookies that match the given cookie info.\n     */\n    export function getAll(details: GetAllDetails, callback: (cookies: Cookie[]) => void): void;\n    /**\n     * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n     * @param details Details about the cookie being set.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( Cookie cookie) {...};\n     * Optional parameter cookie: Contains details about the cookie that\'s been set. If setting failed for any reason, this will be "null", and "chrome.runtime.lastError" will be set.\n     */\n    export function set(details: SetDetails, callback?: (cookie: Cookie | null) => void): void;\n    /**\n     * Deletes a cookie by name.\n     * @param details Information to identify the cookie to remove.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function remove(details: Details, callback?: (details: Details) => void): void;\n    /**\n     * Retrieves information about a single cookie. If more than one cookie of the same name exists for the given URL, the one with the longest path will be returned. For cookies with the same path length, the cookie with the earliest creation time will be returned.\n     * @param details Details to identify the cookie being retrieved.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( Cookie cookie) {...};\n     * Parameter cookie: Contains details about the cookie. This parameter is null if no such cookie was found.\n     */\n    export function get(details: Details, callback: (cookie: Cookie | null) => void): void;\n\n    /** Fired when a cookie is set or removed. As a special case, note that updating a cookie\'s properties is implemented as a two step process: the cookie to be updated is first removed entirely, generating a notification with "cause" of "overwrite" . Afterwards, a new cookie is written with the updated values, generating a second notification with "cause" "explicit". */\n    export var onChanged: CookieChangedEvent;\n}\n\n////////////////////\n// Debugger\n////////////////////\n/**\n * The chrome.debugger API serves as an alternate transport for Chrome\'s remote debugging protocol. Use chrome.debugger to attach to one or more tabs to instrument network interaction, debug JavaScript, mutate the DOM and CSS, etc. Use the Debuggee tabId to target tabs with sendCommand and route events by tabId from onEvent callbacks.\n * Availability: Since Chrome 18.\n * Permissions:  "debugger"\n */\ndeclare module chrome {\n    namespace _debugger {\n        /** Debuggee identifier. Either tabId or extensionId must be specified */\n        export interface Debuggee {\n            /** Optional. The id of the tab which you intend to debug.  */\n            tabId?: number;\n            /**\n             * Optional.\n             * Since Chrome 27.\n             * The id of the extension which you intend to debug. Attaching to an extension background page is only possible when \'silent-debugger-extension-api\' flag is enabled on the target browser.\n             */\n            extensionId?: string;\n            /**\n             * Optional.\n             * Since Chrome 28.\n             * The opaque id of the debug target.\n             */\n            targetId?: string;\n        }\n\n        /**\n         * Since Chrome 28.\n         * Debug target information\n         */\n        export interface TargetInfo {\n            /** Target type. */\n            type: string;\n            /** Target id. */\n            id: string;\n            /**\n             * Optional.\n             * Since Chrome 30.\n             * The tab id, defined if type == \'page\'.\n             */\n            tabId?: number;\n            /**\n             * Optional.\n             * Since Chrome 30.\n             * The extension id, defined if type = \'background_page\'.\n             */\n            extensionId?: string;\n            /** True if debugger is already attached. */\n            attached: boolean;\n            /** Target page title. */\n            title: string;\n            /** Target URL. */\n            url: string;\n            /** Optional. Target favicon URL.  */\n            faviconUrl?: string;\n        }\n\n        export interface DebuggerDetachedEvent extends chrome.events.Event<(source: Debuggee, reason: string) => void> { }\n\n        export interface DebuggerEventEvent extends chrome.events.Event<(source: Debuggee, method: string, params?: Object) => void> { }\n\n        /**\n         * Attaches debugger to the given target.\n         * @param target Debugging target to which you want to attach.\n         * @param requiredVersion Required debugging protocol version ("0.1"). One can only attach to the debuggee with matching major version and greater or equal minor version. List of the protocol versions can be obtained in the documentation pages.\n         * @param callback Called once the attach operation succeeds or fails. Callback receives no arguments. If the attach fails, runtime.lastError will be set to the error message.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        export function attach(target: Debuggee, requiredVersion: string, callback?: () => void): void;\n        /**\n         * Detaches debugger from the given target.\n         * @param target Debugging target from which you want to detach.\n         * @param callback Called once the detach operation succeeds or fails. Callback receives no arguments. If the detach fails, runtime.lastError will be set to the error message.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        export function detach(target: Debuggee, callback?: () => void): void;\n        /**\n         * Sends given command to the debugging target.\n         * @param target Debugging target to which you want to send the command.\n         * @param method Method name. Should be one of the methods defined by the remote debugging protocol.\n         * @param commandParams Since Chrome 22.\n         * JSON object with request parameters. This object must conform to the remote debugging params scheme for given method.\n         * @param callback Response body. If an error occurs while posting the message, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function(object result) {...};\n         */\n        export function sendCommand(target: Debuggee, method: string, commandParams?: Object, callback?: (result?: Object) => void): void;\n        /**\n         * Since Chrome 28.\n         * Returns the list of available debug targets.\n         * @param callback The callback parameter should be a function that looks like this:\n         * function(array of TargetInfo result) {...};\n         * Parameter result: Array of TargetInfo objects corresponding to the available debug targets.\n         */\n        export function getTargets(callback: (result: TargetInfo[]) => void): void;\n\n        /** Fired when browser terminates debugging session for the tab. This happens when either the tab is being closed or Chrome DevTools is being invoked for the attached tab. */\n        export var onDetach: DebuggerDetachedEvent;\n        /** Fired whenever debugging target issues instrumentation event. */\n        export var onEvent: DebuggerEventEvent;\n    }\n\n    export { _debugger as debugger }\n}\n////////////////////\n// Declarative Content\n////////////////////\n/**\n * Use the chrome.declarativeContent API to take actions depending on the content of a page, without requiring permission to read the page\'s content.\n * Availability: Since Chrome 33.\n * Permissions:  "declarativeContent"\n */\ndeclare namespace chrome.declarativeContent {\n    export interface PageStateUrlDetails {\n        /** Optional. Matches if the host name of the URL contains a specified string. To test whether a host name component has a prefix \'foo\', use hostContains: \'.foo\'. This matches \'www.foobar.com\' and \'foo.com\', because an implicit dot is added at the beginning of the host name. Similarly, hostContains can be used to match against component suffix (\'foo.\') and to exactly match against components (\'.foo.\'). Suffix- and exact-matching for the last components need to be done separately using hostSuffix, because no implicit dot is added at the end of the host name.  */\n        hostContains?: string;\n        /** Optional. Matches if the host name of the URL is equal to a specified string.  */\n        hostEquals?: string;\n        /** Optional. Matches if the host name of the URL starts with a specified string.  */\n        hostPrefix?: string;\n        /** Optional. Matches if the host name of the URL ends with a specified string.  */\n        hostSuffix?: string;\n        /** Optional. Matches if the path segment of the URL contains a specified string.  */\n        pathContains?: string;\n        /** Optional. Matches if the path segment of the URL is equal to a specified string.  */\n        pathEquals?: string;\n        /** Optional. Matches if the path segment of the URL starts with a specified string.  */\n        pathPrefix?: string;\n        /** Optional. Matches if the path segment of the URL ends with a specified string.  */\n        pathSuffix?: string;\n        /** Optional. Matches if the query segment of the URL contains a specified string.  */\n        queryContains?: string;\n        /** Optional. Matches if the query segment of the URL is equal to a specified string.  */\n        queryEquals?: string;\n        /** Optional. Matches if the query segment of the URL starts with a specified string.  */\n        queryPrefix?: string;\n        /** Optional. Matches if the query segment of the URL ends with a specified string.  */\n        querySuffix?: string;\n        /** Optional. Matches if the URL (without fragment identifier) contains a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlContains?: string;\n        /** Optional. Matches if the URL (without fragment identifier) is equal to a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlEquals?: string;\n        /** Optional. Matches if the URL (without fragment identifier) matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.  */\n        urlMatches?: string;\n        /** Optional. Matches if the URL without query segment and fragment identifier matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.  */\n        originAndPathMatches?: string;\n        /** Optional. Matches if the URL (without fragment identifier) starts with a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlPrefix?: string;\n        /** Optional. Matches if the URL (without fragment identifier) ends with a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlSuffix?: string;\n        /** Optional. Matches if the scheme of the URL is equal to any of the schemes specified in the array.  */\n        schemes?: string[];\n        /** Optional. Matches if the port of the URL is contained in any of the specified port lists. For example [80, 443, [1000, 1200]] matches all requests on port 80, 443 and in the range 1000-1200.  */\n        ports?: (number | number[])[];\n    }\n\n    export class PageStateMatcherProperties {\n        /** Optional. Filters URLs for various criteria. See event filtering. All criteria are case sensitive.  */\n        pageUrl?: PageStateUrlDetails;\n        /** Optional. Matches if all of the CSS selectors in the array match displayed elements in a frame with the same origin as the page\'s main frame. All selectors in this array must be compound selectors to speed up matching. Note that listing hundreds of CSS selectors or CSS selectors that match hundreds of times per page can still slow down web sites.  */\n        css?: string[];\n        /**\n         * Optional.\n          * Since Chrome 45. Warning: this is the current Beta channel. More information available on the API documentation pages.\n         * Matches if the bookmarked state of the page is equal to the specified value. Requres the bookmarks permission.\n         */\n        isBookmarked?: boolean;\n    }\n\n    /** Matches the state of a web page by various criteria. */\n    export class PageStateMatcher {\n        constructor (options: PageStateMatcherProperties);\n    }\n\n    /** Declarative event action that shows the extension\'s page action while the corresponding conditions are met. */\n    export class ShowPageAction { }\n\n    /** Provides the Declarative Event API consisting of addRules, removeRules, and getRules. */\n    export interface PageChangedEvent extends chrome.events.Event<() => void> { }\n\n    export var onPageChanged: PageChangedEvent;\n}\n\n////////////////////\n// Declarative Web Request\n////////////////////\ndeclare namespace chrome.declarativeWebRequest {\n    export interface HeaderFilter {\n        nameEquals?: string;\n        valueContains?: any;\n        nameSuffix?: string;\n        valueSuffix?: string;\n        valuePrefix?: string;\n        nameContains?: any;\n        valueEquals?: string;\n        namePrefix?: string;\n    }\n\n    export interface AddResponseHeader {\n        name: string;\n        value: string;\n    }\n\n    export interface RemoveResponseCookie {\n        filter: ResponseCookie;\n    }\n\n    export interface RemoveResponseHeader {\n        name: string;\n        value?: string;\n    }\n\n    export interface RequestMatcher {\n        contentType?: string[];\n        url?: chrome.events.UrlFilter;\n        excludeContentType?: string[];\n        excludeResponseHeader?: HeaderFilter[];\n        resourceType?: string;\n        responseHeaders?: HeaderFilter[];\n    }\n\n    export interface IgnoreRules {\n        lowerPriorityThan: number;\n    }\n\n    export interface RedirectToEmptyDocument { }\n\n    export interface RedirectRequest {\n        redirectUrl: string;\n    }\n\n    export interface ResponseCookie {\n        domain?: string;\n        name?: string;\n        expires?: string;\n        maxAge?: number;\n        value?: string;\n        path?: string;\n        httpOnly?: string;\n        secure?: string;\n    }\n\n    export interface AddResponseCookie {\n        cookie: ResponseCookie;\n    }\n\n    export interface EditResponseCookie {\n        filter: ResponseCookie;\n        modification: ResponseCookie;\n    }\n\n    export interface CancelRequest { }\n\n    export interface RemoveRequestHeader {\n        name: string;\n    }\n\n    export interface EditRequestCookie {\n        filter: RequestCookie;\n        modification: RequestCookie;\n    }\n\n    export interface SetRequestHeader {\n        name: string;\n        value: string;\n    }\n\n    export interface RequestCookie {\n        name?: string;\n        value?: string;\n    }\n\n    export interface RedirectByRegEx {\n        to: string;\n        from: string;\n    }\n\n    export interface RedirectToTransparentImage { }\n\n    export interface AddRequestCookie {\n        cookie: RequestCookie;\n    }\n\n    export interface RemoveRequestCookie {\n        filter: RequestCookie;\n    }\n\n    export interface RequestedEvent extends chrome.events.Event<Function> { }\n\n    export var onRequest: RequestedEvent;\n}\n\n////////////////////\n// DesktopCapture\n////////////////////\n/**\n * Desktop Capture API that can be used to capture content of screen, individual windows or tabs.\n * Availability: Since Chrome 34.\n * Permissions:  "desktopCapture"\n */\ndeclare namespace chrome.desktopCapture {\n    /**\n     * Shows desktop media picker UI with the specified set of sources.\n     * @param sources Set of sources that should be shown to the user.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string streamId) {...};\n     * Parameter streamId: An opaque string that can be passed to getUserMedia() API to generate media stream that corresponds to the source selected by the user. If user didn\'t select any source (i.e. canceled the prompt) then the callback is called with an empty streamId. The created streamId can be used only once and expires after a few seconds when it is not used.\n     */\n    export function chooseDesktopMedia(sources: string[], callback: (streamId: string) => void): number;\n    /**\n     * Shows desktop media picker UI with the specified set of sources.\n     * @param sources Set of sources that should be shown to the user.\n     * @param targetTab Optional tab for which the stream is created. If not specified then the resulting stream can be used only by the calling extension. The stream can only be used by frames in the given tab whose security origin matches tab.url.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string streamId) {...};\n     * Parameter streamId: An opaque string that can be passed to getUserMedia() API to generate media stream that corresponds to the source selected by the user. If user didn\'t select any source (i.e. canceled the prompt) then the callback is called with an empty streamId. The created streamId can be used only once and expires after a few seconds when it is not used.\n     */\n    export function chooseDesktopMedia(sources: string[], targetTab: chrome.tabs.Tab, callback: (streamId: string) => void): number;\n    /**\n     * Hides desktop media picker dialog shown by chooseDesktopMedia().\n     * @param desktopMediaRequestId Id returned by chooseDesktopMedia()\n     */\n    export function cancelChooseDesktopMedia(desktopMediaRequestId: number): void;\n}\n\n////////////////////\n// Dev Tools - Inspected Window\n////////////////////\n/**\n * Use the chrome.devtools.inspectedWindow API to interact with the inspected window: obtain the tab ID for the inspected page, evaluate the code in the context of the inspected window, reload the page, or obtain the list of resources within the page.\n * Availability: Since Chrome 18.\n */\ndeclare namespace chrome.devtools.inspectedWindow {\n    /** A resource within the inspected page, such as a document, a script, or an image. */\n    export interface Resource {\n        /** The URL of the resource. */\n        url: string;\n        /**\n         * Gets the content of the resource.\n         * @param callback A function that receives resource content when the request completes.\n         * The callback parameter should be a function that looks like this:\n         * function(string content, string encoding) {...};\n         * Parameter content: Content of the resource (potentially encoded).\n         * Parameter encoding: Empty if content is not encoded, encoding name otherwise. Currently, only base64 is supported.\n         */\n        getContent(callback: (content: string, encoding: string) => void): void;\n        /**\n         * Sets the content of the resource.\n         * @param content New content of the resource. Only resources with the text type are currently supported.\n         * @param commit True if the user has finished editing the resource, and the new content of the resource should be persisted; false if this is a minor change sent in progress of the user editing the resource.\n         * @param callback A function called upon request completion.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function(object error) {...};\n         * Optional parameter error: Set to undefined if the resource content was set successfully; describes error otherwise.\n         */\n        setContent(content: string, commit: boolean, callback?: (error: Object) => void): void;\n    }\n\n    export interface ReloadOptions {\n        /** Optional. If specified, the string will override the value of the User-Agent HTTP header that\'s sent while loading the resources of the inspected page. The string will also override the value of the navigator.userAgent property that\'s returned to any scripts that are running within the inspected page.  */\n        userAgent?: string;\n        /** Optional. When true, the loader will ignore the cache for all inspected page resources loaded before the load event is fired. The effect is similar to pressing Ctrl+Shift+R in the inspected window or within the Developer Tools window.  */\n        ignoreCache?: boolean;\n        /** Optional. If specified, the script will be injected into every frame of the inspected page immediately upon load, before any of the frame\'s scripts. The script will not be injected after subsequent reloads\u2014for example, if the user presses Ctrl+R.  */\n        injectedScript?: string;\n        /**\n         * Optional.\n          * If specified, this script evaluates into a function that accepts three string arguments: the source to preprocess, the URL of the source, and a function name if the source is an DOM event handler. The preprocessorerScript function should return a string to be compiled by Chrome in place of the input source. In the case that the source is a DOM event handler, the returned source must compile to a single JS function.\n         * @deprecated Deprecated since Chrome 41. Please avoid using this parameter, it will be removed soon.\n         */\n        preprocessorScript?: string;\n    }\n\n    export interface EvaluationExceptionInfo {\n        /** Set if the error occurred on the DevTools side before the expression is evaluated. */\n        isError: boolean;\n        /** Set if the error occurred on the DevTools side before the expression is evaluated. */\n        code: string;\n        /** Set if the error occurred on the DevTools side before the expression is evaluated. */\n        description: string;\n        /** Set if the error occurred on the DevTools side before the expression is evaluated, contains the array of the values that may be substituted into the description string to provide more information about the cause of the error. */\n        details: any[];\n        /** Set if the evaluated code produces an unhandled exception. */\n        isException: boolean;\n        /** Set if the evaluated code produces an unhandled exception. */\n        value: string;\n    }\n\n    export interface ResourceAddedEvent extends chrome.events.Event<(resource: Resource) => void> { }\n\n    export interface ResourceContentCommittedEvent extends chrome.events.Event<(resource: Resource, content: string) => void> { }\n\n    /** The ID of the tab being inspected. This ID may be used with chrome.tabs.* API. */\n    export var tabId: number;\n\n    /** Reloads the inspected page. */\n    export function reload(reloadOptions: ReloadOptions): void;\n    /**\n     * Evaluates a JavaScript expression in the context of the main frame of the inspected page. The expression must evaluate to a JSON-compliant object, otherwise an exception is thrown. The eval function can report either a DevTools-side error or a JavaScript exception that occurs during evaluation. In either case, the result parameter of the callback is undefined. In the case of a DevTools-side error, the isException parameter is non-null and has isError set to true and code set to an error code. In the case of a JavaScript error, isException is set to true and value is set to the string value of thrown object.\n     * @param expression An expression to evaluate.\n     * @param callback A function called when evaluation completes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(object result, object exceptionInfo) {...};\n     * Parameter result: The result of evaluation.\n     * Parameter exceptionInfo: An object providing details if an exception occurred while evaluating the expression.\n     */\n    export function eval<T>(expression: string, callback?: (result: T, exceptionInfo: EvaluationExceptionInfo) => void): void;\n    /**\n     * Evaluates a JavaScript expression in the context of the main frame of the inspected page. The expression must evaluate to a JSON-compliant object, otherwise an exception is thrown. The eval function can report either a DevTools-side error or a JavaScript exception that occurs during evaluation. In either case, the result parameter of the callback is undefined. In the case of a DevTools-side error, the isException parameter is non-null and has isError set to true and code set to an error code. In the case of a JavaScript error, isException is set to true and value is set to the string value of thrown object.\n     * @param expression An expression to evaluate.\n     * @param options The options parameter can contain one or more options.\n     * @param callback A function called when evaluation completes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(object result, object exceptionInfo) {...};\n     * Parameter result: The result of evaluation.\n     * Parameter exceptionInfo: An object providing details if an exception occurred while evaluating the expression.\n     */\n    export function eval<T>(expression: string, options: EvalOptions, callback?: (result: T, exceptionInfo: EvaluationExceptionInfo) => void): void;\n    /**\n     * Retrieves the list of resources from the inspected page.\n     * @param callback A function that receives the list of resources when the request completes.\n     * The callback parameter should be a function that looks like this:\n     * function(array of Resource resources) {...};\n     */\n    export function getResources(callback: (resources: Resource[]) => void): void;\n\n    /** Fired when a new resource is added to the inspected page. */\n    export var onResourceAdded: ResourceAddedEvent;\n    /** Fired when a new revision of the resource is committed (e.g. user saves an edited version of the resource in the Developer Tools). */\n    export var onResourceContentCommitted: ResourceContentCommittedEvent;\n\n    export interface EvalOptions {\n        /** If specified, the expression is evaluated on the iframe whose URL matches the one specified. By default, the expression is evaluated in the top frame of the inspected page. */\n        frameURL?: string;\n        /** Evaluate the expression in the context of the content script of the calling extension, provided that the content script is already injected into the inspected page. If not, the expression is not evaluated and the callback is invoked with the exception parameter set to an object that has the isError field set to true and the code field set to E_NOTFOUND. */\n        useContentScriptContext?: boolean;\n        /** Evaluate the expression in the context of a content script of an extension that matches the specified origin. If given, contextSecurityOrigin overrides the \'true\' setting on userContentScriptContext. */\n        contextSecurityOrigin?: string;\n    }\n}\n\n////////////////////\n// Dev Tools - Network\n////////////////////\n/**\n * Use the chrome.devtools.network API to retrieve the information about network requests displayed by the Developer Tools in the Network panel.\n * Availability: Since Chrome 18.\n */\ndeclare namespace chrome.devtools.network {\n    /** Represents a network request for a document resource (script, image and so on). See HAR Specification for reference. */\n    export interface Request {\n        /**\n         * Returns content of the response body.\n         * @param callback A function that receives the response body when the request completes.\n         * The callback parameter should be a function that looks like this:\n         * function(string content, string encoding) {...};\n         * Parameter content: Content of the response body (potentially encoded).\n         * Parameter encoding: Empty if content is not encoded, encoding name otherwise. Currently, only base64 is supported.\n         */\n        getContent(callback: (content: string, encoding: string) => void): void;\n    }\n\n    export interface RequestFinishedEvent extends chrome.events.Event<(request: Request) => void> { }\n\n    export interface NavigatedEvent extends chrome.events.Event<(url: string) => void> { }\n\n    /**\n     * Returns HAR log that contains all known network requests.\n     * @param callback A function that receives the HAR log when the request completes.\n     * The callback parameter should be a function that looks like this:\n     * function(object harLog) {...};\n     * Parameter harLog: A HAR log. See HAR specification for details.\n     */\n    export function getHAR(callback: (harLog: Object) => void): void;\n\n    /** Fired when a network request is finished and all request data are available. */\n    export var onRequestFinished: RequestFinishedEvent;\n    /** Fired when the inspected window navigates to a new page. */\n    export var onNavigated: NavigatedEvent;\n}\n\n////////////////////\n// Dev Tools - Panels\n////////////////////\n/**\n * Use the chrome.devtools.panels API to integrate your extension into Developer Tools window UI: create your own panels, access existing panels, and add sidebars.\n * Availability: Since Chrome 18.\n */\ndeclare namespace chrome.devtools.panels {\n    export interface PanelShownEvent extends chrome.events.Event<(window: Window) => void> { }\n\n    export interface PanelHiddenEvent extends chrome.events.Event<() => void> { }\n\n    export interface PanelSearchEvent extends chrome.events.Event<(action: string, queryString?: string) => void> { }\n\n    /** Represents a panel created by extension. */\n    export interface ExtensionPanel {\n        /**\n         * Appends a button to the status bar of the panel.\n         * @param iconPath Path to the icon of the button. The file should contain a 64x24-pixel image composed of two 32x24 icons. The left icon is used when the button is inactive; the right icon is displayed when the button is pressed.\n         * @param tooltipText Text shown as a tooltip when user hovers the mouse over the button.\n         * @param disabled Whether the button is disabled.\n         */\n        createStatusBarButton(iconPath: string, tooltipText: string, disabled: boolean): Button;\n        /** Fired when the user switches to the panel. */\n        onShown: PanelShownEvent;\n        /** Fired when the user switches away from the panel. */\n        onHidden: PanelHiddenEvent;\n        /** Fired upon a search action (start of a new search, search result navigation, or search being canceled). */\n        onSearch: PanelSearchEvent;\n    }\n\n    export interface ButtonClickedEvent extends chrome.events.Event<() => void> { }\n\n    /** A button created by the extension. */\n    export interface Button {\n        /**\n         * Updates the attributes of the button. If some of the arguments are omitted or null, the corresponding attributes are not updated.\n         * @param iconPath Path to the new icon of the button.\n         * @param tooltipText Text shown as a tooltip when user hovers the mouse over the button.\n         * @param disabled Whether the button is disabled.\n         */\n        update(iconPath?: string | null, tooltipText?: string | null, disabled?: boolean | null): void;\n        /** Fired when the button is clicked. */\n        onClicked: ButtonClickedEvent;\n    }\n\n    export interface SelectionChangedEvent extends chrome.events.Event<() => void> { }\n\n    /** Represents the Elements panel. */\n    export interface ElementsPanel {\n        /**\n         * Creates a pane within panel\'s sidebar.\n         * @param title Text that is displayed in sidebar caption.\n         * @param callback A callback invoked when the sidebar is created.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function( ExtensionSidebarPane result) {...};\n         * Parameter result: An ExtensionSidebarPane object for created sidebar pane.\n         */\n        createSidebarPane(title: string, callback?: (result: ExtensionSidebarPane) => void): void;\n        /** Fired when an object is selected in the panel. */\n        onSelectionChanged: SelectionChangedEvent;\n    }\n\n    /**\n     * Since Chrome 41.\n     * Represents the Sources panel.\n     */\n    export interface SourcesPanel {\n        /**\n         * Creates a pane within panel\'s sidebar.\n         * @param title Text that is displayed in sidebar caption.\n         * @param callback A callback invoked when the sidebar is created.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function( ExtensionSidebarPane result) {...};\n         * Parameter result: An ExtensionSidebarPane object for created sidebar pane.\n         */\n        createSidebarPane(title: string, callback?: (result: ExtensionSidebarPane) => void): void;\n        /** Fired when an object is selected in the panel. */\n        onSelectionChanged: SelectionChangedEvent;\n    }\n\n    export interface ExtensionSidebarPaneShownEvent extends chrome.events.Event<(window: chrome.windows.Window) => void> { }\n\n    export interface ExtensionSidebarPaneHiddenEvent extends chrome.events.Event<() => void> { }\n\n    /** A sidebar created by the extension. */\n    export interface ExtensionSidebarPane {\n        /**\n         * Sets the height of the sidebar.\n         * @param height A CSS-like size specification, such as \'100px\' or \'12ex\'.\n         */\n        setHeight(height: string): void;\n        /**\n         * Sets an expression that is evaluated within the inspected page. The result is displayed in the sidebar pane.\n         * @param expression An expression to be evaluated in context of the inspected page. JavaScript objects and DOM nodes are displayed in an expandable tree similar to the console/watch.\n         * @param rootTitle An optional title for the root of the expression tree.\n         * @param callback A callback invoked after the sidebar pane is updated with the expression evaluation results.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        setExpression(expression: string, rootTitle?: string, callback?: () => void): void;\n        /**\n         * Sets an expression that is evaluated within the inspected page. The result is displayed in the sidebar pane.\n         * @param expression An expression to be evaluated in context of the inspected page. JavaScript objects and DOM nodes are displayed in an expandable tree similar to the console/watch.\n         * @param callback A callback invoked after the sidebar pane is updated with the expression evaluation results.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        setExpression(expression: string, callback?: () => void): void;\n        /**\n         * Sets a JSON-compliant object to be displayed in the sidebar pane.\n         * @param jsonObject An object to be displayed in context of the inspected page. Evaluated in the context of the caller (API client).\n         * @param rootTitle An optional title for the root of the expression tree.\n         * @param callback A callback invoked after the sidebar is updated with the object.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        setObject(jsonObject: Object, rootTitle?: string, callback?: () => void): void;\n        /**\n         * Sets a JSON-compliant object to be displayed in the sidebar pane.\n         * @param jsonObject An object to be displayed in context of the inspected page. Evaluated in the context of the caller (API client).\n         * @param callback A callback invoked after the sidebar is updated with the object.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        setObject(jsonObject: Object, callback?: () => void): void;\n        /**\n         * Sets an HTML page to be displayed in the sidebar pane.\n         * @param path Relative path of an extension page to display within the sidebar.\n         */\n        setPage(path: string): void;\n        /** Fired when the sidebar pane becomes visible as a result of user switching to the panel that hosts it. */\n        onShown: ExtensionSidebarPaneShownEvent;\n        /** Fired when the sidebar pane becomes hidden as a result of the user switching away from the panel that hosts the sidebar pane. */\n        onHidden: ExtensionSidebarPaneHiddenEvent;\n    }\n\n    /** Elements panel. */\n    export var elements: ElementsPanel;\n    /**\n     * Since Chrome 38.\n     * Sources panel.\n     */\n    export var sources: SourcesPanel;\n\n    /**\n     * Creates an extension panel.\n     * @param title Title that is displayed next to the extension icon in the Developer Tools toolbar.\n     * @param iconPath Path of the panel\'s icon relative to the extension directory.\n     * @param pagePath Path of the panel\'s HTML page relative to the extension directory.\n     * @param callback A function that is called when the panel is created.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function( ExtensionPanel panel) {...};\n     * Parameter panel: An ExtensionPanel object representing the created panel.\n     */\n    export function create(title: string, iconPath: string, pagePath: string, callback?: (panel: ExtensionPanel) => void): void;\n    /**\n     * Specifies the function to be called when the user clicks a resource link in the Developer Tools window. To unset the handler, either call the method with no parameters or pass null as the parameter.\n     * @param callback A function that is called when the user clicks on a valid resource link in Developer Tools window. Note that if the user clicks an invalid URL or an XHR, this function is not called.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function( devtools.inspectedWindow.Resource resource) {...};\n     * Parameter resource: A devtools.inspectedWindow.Resource object for the resource that was clicked.\n     */\n    export function setOpenResourceHandler(callback?: (resource: chrome.devtools.inspectedWindow.Resource) => void): void;\n    /**\n     * Since Chrome 38.\n     * Requests DevTools to open a URL in a Developer Tools panel.\n     * @param url The URL of the resource to open.\n     * @param lineNumber Specifies the line number to scroll to when the resource is loaded.\n     * @param callback A function that is called when the resource has been successfully loaded.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function openResource(url: string, lineNumber: number, callback: () => void): void;\n}\n\n////////////////////\n// Document Scan\n////////////////////\n/**\n * Use the chrome.documentScan API to discover and retrieve images from attached paper document scanners.\n * Availability: Since Chrome 44.\n * Permissions:  "documentScan"\n * Important: This API works only on Chrome OS.\n */\ndeclare namespace chrome.documentScan {\n    export interface DocumentScanOptions {\n        /** Optional. The MIME types that are accepted by the caller.  */\n        mimeTypes?: string[];\n        /** Optional. The number of scanned images allowed (defaults to 1).  */\n        maxImages?: number;\n    }\n\n    export interface DocumentScanCallbackArg {\n        /** The data image URLs in a form that can be passed as the "src" value to an image tag. */\n        dataUrls: string[];\n        /** The MIME type of dataUrls. */\n        mimeType: string;\n    }\n\n    /**\n     * Performs a document scan. On success, the PNG data will be sent to the callback.\n     * @param options Object containing scan parameters.\n     * @param callback Called with the result and data from the scan.\n     * The callback parameter should be a function that looks like this:\n     * function(object result) {...};\n     */\n    export function scan(options: DocumentScanOptions, callback: (result: DocumentScanCallbackArg) => void): void;\n}\n\n////////////////////\n// Dev Tools - Downloads\n////////////////////\n/**\n * Use the chrome.downloads API to programmatically initiate, monitor, manipulate, and search for downloads.\n * Availability: Since Chrome 31.\n * Permissions:  "downloads"\n */\ndeclare namespace chrome.downloads {\n    export interface HeaderNameValuePair {\n        /** Name of the HTTP header. */\n        name: string;\n        /** Value of the HTTP header. */\n        value: string;\n    }\n\n    export interface DownloadOptions {\n        /** Optional. Post body.  */\n        body?: string;\n        /** Optional. Use a file-chooser to allow the user to select a filename regardless of whether filename is set or already exists.  */\n        saveAs?: boolean;\n        /** The URL to download. */\n        url: string;\n        /** Optional. A file path relative to the Downloads directory to contain the downloaded file, possibly containing subdirectories. Absolute paths, empty paths, and paths containing back-references ".." will cause an error. onDeterminingFilename allows suggesting a filename after the file\'s MIME type and a tentative filename have been determined.  */\n        filename?: string;\n        /** Optional. Extra HTTP headers to send with the request if the URL uses the HTTP[s] protocol. Each header is represented as a dictionary containing the keys name and either value or binaryValue, restricted to those allowed by XMLHttpRequest.  */\n        headers?: HeaderNameValuePair[];\n        /** Optional. The HTTP method to use if the URL uses the HTTP[S] protocol.  */\n        method?: string;\n        /** Optional. The action to take if filename already exists.  */\n        conflictAction?: string;\n    }\n\n    export interface DownloadDelta {\n        /** Optional. The change in danger, if any.  */\n        danger?: StringDelta;\n        /** Optional. The change in url, if any.  */\n        url?: StringDelta;\n        /** Optional. The change in totalBytes, if any.  */\n        totalBytes?: DoubleDelta;\n        /** Optional. The change in filename, if any.  */\n        filename?: StringDelta;\n        /** Optional. The change in paused, if any.  */\n        paused?: BooleanDelta;\n        /** Optional. The change in state, if any.  */\n        state?: StringDelta;\n        /** Optional. The change in mime, if any.  */\n        mime?: StringDelta;\n        /** Optional. The change in fileSize, if any.  */\n        fileSize?: DoubleDelta;\n        /** Optional. The change in startTime, if any.  */\n        startTime?: DoubleDelta;\n        /** Optional. The change in error, if any.  */\n        error?: StringDelta;\n        /** Optional. The change in endTime, if any.  */\n        endTime?: DoubleDelta;\n        /** The id of the DownloadItem that changed. */\n        id: number;\n        /** Optional. The change in canResume, if any.  */\n        canResume?: BooleanDelta;\n        /** Optional. The change in exists, if any.  */\n        exists?: BooleanDelta;\n    }\n\n    export interface BooleanDelta {\n        current?: boolean;\n        previous?: boolean;\n    }\n\n    /** Since Chrome 34. */\n    export interface DoubleDelta {\n        current?: number;\n        previous?: number;\n    }\n\n    export interface StringDelta {\n        current?: string;\n        previous?: string;\n    }\n\n    export interface DownloadItem {\n        /** Number of bytes received so far from the host, without considering file compression. */\n        bytesReceived: number;\n        /** Indication of whether this download is thought to be safe or known to be suspicious. */\n        danger: string;\n        /** Absolute URL. */\n        url: string;\n        /** Number of bytes in the whole file, without considering file compression, or -1 if unknown. */\n        totalBytes: number;\n        /** Absolute local path. */\n        filename: string;\n        /** True if the download has stopped reading data from the host, but kept the connection open. */\n        paused: boolean;\n        /** Indicates whether the download is progressing, interrupted, or complete. */\n        state: string;\n        /** The file\'s MIME type. */\n        mime: string;\n        /** Number of bytes in the whole file post-decompression, or -1 if unknown. */\n        fileSize: number;\n        /** The time when the download began in ISO 8601 format. May be passed directly to the Date constructor: chrome.downloads.search({}, function(items){items.forEach(function(item){console.log(new Date(item.startTime))})}) */\n        startTime: string;\n        /** Optional. Why the download was interrupted. Several kinds of HTTP errors may be grouped under one of the errors beginning with SERVER_. Errors relating to the network begin with NETWORK_, errors relating to the process of writing the file to the file system begin with FILE_, and interruptions initiated by the user begin with USER_.  */\n        error?: string;\n        /** Optional. The time when the download ended in ISO 8601 format. May be passed directly to the Date constructor: chrome.downloads.search({}, function(items){items.forEach(function(item){if (item.endTime) console.log(new Date(item.endTime))})})  */\n        endTime?: string;\n        /** An identifier that is persistent across browser sessions. */\n        id: number;\n        /** False if this download is recorded in the history, true if it is not recorded. */\n        incognito: boolean;\n        /** Absolute URL. */\n        referrer: string;\n        /** Optional. Estimated time when the download will complete in ISO 8601 format. May be passed directly to the Date constructor: chrome.downloads.search({}, function(items){items.forEach(function(item){if (item.estimatedEndTime) console.log(new Date(item.estimatedEndTime))})})  */\n        estimatedEndTime?: string;\n        /** True if the download is in progress and paused, or else if it is interrupted and can be resumed starting from where it was interrupted. */\n        canResume: boolean;\n        /** Whether the downloaded file still exists. This information may be out of date because Chrome does not automatically watch for file removal. Call search() in order to trigger the check for file existence. When the existence check completes, if the file has been deleted, then an onChanged event will fire. Note that search() does not wait for the existence check to finish before returning, so results from search() may not accurately reflect the file system. Also, search() may be called as often as necessary, but will not check for file existence any more frequently than once every 10 seconds. */\n        exists: boolean;\n        /** Optional. The identifier for the extension that initiated this download if this download was initiated by an extension. Does not change once it is set.  */\n        byExtensionId?: string;\n        /** Optional. The localized name of the extension that initiated this download if this download was initiated by an extension. May change if the extension changes its name or if the user changes their locale.  */\n        byExtensionName?: string;\n    }\n\n    export interface GetFileIconOptions {\n        /** Optional. * The size of the returned icon. The icon will be square with dimensions size * size pixels. The default and largest size for the icon is 32x32 pixels. The only supported sizes are 16 and 32. It is an error to specify any other size.\n */\n        size?: number;\n    }\n\n    export interface DownloadQuery {\n        /** Optional. Set elements of this array to DownloadItem properties in order to sort search results. For example, setting orderBy=[\'startTime\'] sorts the DownloadItem by their start time in ascending order. To specify descending order, prefix with a hyphen: \'-startTime\'.  */\n        orderBy?: string[];\n        /** Optional. Limits results to DownloadItem whose url matches the given regular expression.  */\n        urlRegex?: string;\n        /** Optional. Limits results to DownloadItem that ended before the given ms since the epoch.  */\n        endedBefore?: number;\n        /** Optional. Limits results to DownloadItem whose totalBytes is greater than the given integer.  */\n        totalBytesGreater?: number;\n        /** Optional. Indication of whether this download is thought to be safe or known to be suspicious.  */\n        danger?: string;\n        /** Optional. Number of bytes in the whole file, without considering file compression, or -1 if unknown.  */\n        totalBytes?: number;\n        /** Optional. True if the download has stopped reading data from the host, but kept the connection open.  */\n        paused?: boolean;\n        /** Optional. Limits results to DownloadItem whose filename matches the given regular expression.  */\n        filenameRegex?: string;\n        /** Optional. This array of search terms limits results to DownloadItem whose filename or url contain all of the search terms that do not begin with a dash \'-\' and none of the search terms that do begin with a dash.  */\n        query?: string[];\n        /** Optional. Limits results to DownloadItem whose totalBytes is less than the given integer.  */\n        totalBytesLess?: number;\n        /** Optional. The id of the DownloadItem to query.  */\n        id?: number;\n        /** Optional. Number of bytes received so far from the host, without considering file compression.  */\n        bytesReceived?: number;\n        /** Optional. Limits results to DownloadItem that ended after the given ms since the epoch.  */\n        endedAfter?: number;\n        /** Optional. Absolute local path.  */\n        filename?: string;\n        /** Optional. Indicates whether the download is progressing, interrupted, or complete.  */\n        state?: string;\n        /** Optional. Limits results to DownloadItem that started after the given ms since the epoch.  */\n        startedAfter?: number;\n        /** Optional. The file\'s MIME type.  */\n        mime?: string;\n        /** Optional. Number of bytes in the whole file post-decompression, or -1 if unknown.  */\n        fileSize?: number;\n        /** Optional. The time when the download began in ISO 8601 format.  */\n        startTime?: number;\n        /** Optional. Absolute URL.  */\n        url?: string;\n        /** Optional. Limits results to DownloadItem that started before the given ms since the epoch.  */\n        startedBefore?: number;\n        /** Optional. The maximum number of matching DownloadItem returned. Defaults to 1000. Set to 0 in order to return all matching DownloadItem. See search for how to page through results.  */\n        limit?: number;\n        /** Optional. Why a download was interrupted.  */\n        error?: number;\n        /** Optional. The time when the download ended in ISO 8601 format.  */\n        endTime?: number;\n        /** Optional. Whether the downloaded file exists;  */\n        exists?: boolean;\n    }\n\n    export interface DownloadFilenameSuggestion {\n        /** The DownloadItem\'s new target DownloadItem.filename, as a path relative to the user\'s default Downloads directory, possibly containing subdirectories. Absolute paths, empty paths, and paths containing back-references ".." will be ignored. */\n        filename: string;\n        /** Optional. The action to take if filename already exists.  */\n        conflictAction?: string;\n    }\n\n    export interface DownloadChangedEvent extends chrome.events.Event<(downloadDelta: DownloadDelta) => void> { }\n\n    export interface DownloadCreatedEvent extends chrome.events.Event<(downloadItem: DownloadItem) => void> { }\n\n    export interface DownloadErasedEvent extends chrome.events.Event<(downloadId: number) => void> { }\n\n    export interface DownloadDeterminingFilenameEvent extends chrome.events.Event<(downloadItem: DownloadItem, suggest: (suggestion?: DownloadFilenameSuggestion) => void) => void> { }\n\n    /**\n     * Find DownloadItem. Set query to the empty object to get all DownloadItem. To get a specific DownloadItem, set only the id field. To page through a large number of items, set orderBy: [\'-startTime\'], set limit to the number of items per page, and set startedAfter to the startTime of the last item from the last page.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of DownloadItem results) {...};\n     */\n    export function search(query: DownloadQuery, callback: (results: DownloadItem[]) => void): void;\n    /**\n     * Pause the download. If the request was successful the download is in a paused state. Otherwise runtime.lastError contains an error message. The request will fail if the download is not active.\n     * @param downloadId The id of the download to pause.\n     * @param callback Called when the pause request is completed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function pause(downloadId: number, callback?: () => void): void;\n    /**\n     * Retrieve an icon for the specified download. For new downloads, file icons are available after the onCreated event has been received. The image returned by this function while a download is in progress may be different from the image returned after the download is complete. Icon retrieval is done by querying the underlying operating system or toolkit depending on the platform. The icon that is returned will therefore depend on a number of factors including state of the download, platform, registered file types and visual theme. If a file icon cannot be determined, runtime.lastError will contain an error message.\n     * @param downloadId The identifier for the download.\n     * @param callback A URL to an image that represents the download.\n     * The callback parameter should be a function that looks like this:\n     * function(string iconURL) {...};\n     */\n    export function getFileIcon(downloadId: number, callback: (iconURL: string) => void): void;\n    /**\n     * Retrieve an icon for the specified download. For new downloads, file icons are available after the onCreated event has been received. The image returned by this function while a download is in progress may be different from the image returned after the download is complete. Icon retrieval is done by querying the underlying operating system or toolkit depending on the platform. The icon that is returned will therefore depend on a number of factors including state of the download, platform, registered file types and visual theme. If a file icon cannot be determined, runtime.lastError will contain an error message.\n     * @param downloadId The identifier for the download.\n     * @param callback A URL to an image that represents the download.\n     * The callback parameter should be a function that looks like this:\n     * function(string iconURL) {...};\n     */\n    export function getFileIcon(downloadId: number, options: GetFileIconOptions, callback: (iconURL: string) => void): void;\n    /**\n     * Resume a paused download. If the request was successful the download is in progress and unpaused. Otherwise runtime.lastError contains an error message. The request will fail if the download is not active.\n     * @param downloadId The id of the download to resume.\n     * @param callback  Called when the resume request is completed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function resume(downloadId: number, callback?: () => void): void;\n    /**\n     * Cancel a download. When callback is run, the download is cancelled, completed, interrupted or doesn\'t exist anymore.\n     * @param downloadId The id of the download to cancel.\n     * @param callback Called when the cancel request is completed.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function cancel(downloadId: number, callback?: () => void): void;\n    /**\n     * Download a URL. If the URL uses the HTTP[S] protocol, then the request will include all cookies currently set for its hostname. If both filename and saveAs are specified, then the Save As dialog will be displayed, pre-populated with the specified filename. If the download started successfully, callback will be called with the new DownloadItem\'s downloadId. If there was an error starting the download, then callback will be called with downloadId=undefined and runtime.lastError will contain a descriptive string. The error strings are not guaranteed to remain backwards compatible between releases. Extensions must not parse it.\n     * @param options What to download and how.\n     * @param callback Called with the id of the new DownloadItem.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(integer downloadId) {...};\n     */\n    export function download(options: DownloadOptions, callback?: (downloadId: number) => void): void;\n    /**\n     * Open the downloaded file now if the DownloadItem is complete; otherwise returns an error through runtime.lastError. Requires the "downloads.open" permission in addition to the "downloads" permission. An onChanged event will fire when the item is opened for the first time.\n     * @param downloadId The identifier for the downloaded file.\n     */\n    export function open(downloadId: number): void;\n    /**\n     * Show the downloaded file in its folder in a file manager.\n     * @param downloadId The identifier for the downloaded file.\n     */\n    export function show(downloadId: number): void;\n    /** Show the default Downloads folder in a file manager. */\n    export function showDefaultFolder(): void;\n    /**\n     * Erase matching DownloadItem from history without deleting the downloaded file. An onErased event will fire for each DownloadItem that matches query, then callback will be called.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(array of integer erasedIds) {...};\n     */\n    export function erase(query: DownloadQuery, callback: (erasedIds: number[]) => void): void;\n    /**\n     * Remove the downloaded file if it exists and the DownloadItem is complete; otherwise return an error through runtime.lastError.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeFile(downloadId: number, callback?: () => void): void;\n    /**\n     * Prompt the user to accept a dangerous download. Can only be called from a visible context (tab, window, or page/browser action popup). Does not automatically accept dangerous downloads. If the download is accepted, then an onChanged event will fire, otherwise nothing will happen. When all the data is fetched into a temporary file and either the download is not dangerous or the danger has been accepted, then the temporary file is renamed to the target filename, the |state| changes to \'complete\', and onChanged fires.\n     * @param downloadId The identifier for the DownloadItem.\n     * @param callback Called when the danger prompt dialog closes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function acceptDanger(downloadId: number, callback: () => void): void;\n    /** Initiate dragging the downloaded file to another application. Call in a javascript ondragstart handler. */\n    export function drag(downloadId: number): void;\n    /** Enable or disable the gray shelf at the bottom of every window associated with the current browser profile. The shelf will be disabled as long as at least one extension has disabled it. Enabling the shelf while at least one other extension has disabled it will return an error through runtime.lastError. Requires the "downloads.shelf" permission in addition to the "downloads" permission. */\n    export function setShelfEnabled(enabled: boolean): void;\n\n    /** When any of a DownloadItem\'s properties except bytesReceived and estimatedEndTime changes, this event fires with the downloadId and an object containing the properties that changed. */\n    export var onChanged: DownloadChangedEvent;\n    /** This event fires with the DownloadItem object when a download begins. */\n    export var onCreated: DownloadCreatedEvent;\n    /** Fires with the downloadId when a download is erased from history. */\n    export var onErased: DownloadErasedEvent;\n    /** During the filename determination process, extensions will be given the opportunity to override the target DownloadItem.filename. Each extension may not register more than one listener for this event. Each listener must call suggest exactly once, either synchronously or asynchronously. If the listener calls suggest asynchronously, then it must return true. If the listener neither calls suggest synchronously nor returns true, then suggest will be called automatically. The DownloadItem will not complete until all listeners have called suggest. Listeners may call suggest without any arguments in order to allow the download to use downloadItem.filename for its filename, or pass a suggestion object to suggest in order to override the target filename. If more than one extension overrides the filename, then the last extension installed whose listener passes a suggestion object to suggest wins. In order to avoid confusion regarding which extension will win, users should not install extensions that may conflict. If the download is initiated by download and the target filename is known before the MIME type and tentative filename have been determined, pass filename to download instead. */\n    export var onDeterminingFilename: DownloadDeterminingFilenameEvent;\n}\n\n////////////////////\n// Enterprise Platform Keys\n////////////////////\n/**\n * Use the chrome.enterprise.platformKeys API to generate hardware-backed keys and to install certificates for these keys. The certificates will be managed by the platform and can be used for TLS authentication, network access or by other extension through chrome.platformKeys.\n * Availability: Since Chrome 37.\n * Permissions:  "enterprise.platformKeys"\n * Important: This API works only on Chrome OS.\n * Note:  This API is only for extensions pre-installed by policy.\n */\ndeclare namespace chrome.enterprise.platformKeys {\n    export interface Token {\n        /**\n         * Uniquely identifies this Token.\n         * Static IDs are "user" and "system", referring to the platform\'s user-specific and the system-wide hardware token, respectively. Any other tokens (with other identifiers) might be returned by enterprise.platformKeys.getTokens.\n         */\n        id: string;\n        /**\n         * Implements the WebCrypto\'s SubtleCrypto interface. The cryptographic operations, including key generation, are hardware-backed.\n         * Only non-extractable RSASSA-PKCS1-V1_5 keys with modulusLength up to 2048 can be generated. Each key can be used for signing data at most once.\n         * Keys generated on a specific Token cannot be used with any other Tokens, nor can they be used with window.crypto.subtle. Equally, Key objects created with window.crypto.subtle cannot be used with this interface.\n         */\n        subtleCrypto: SubtleCrypto;\n    }\n\n    /**\n     * Returns the available Tokens. In a regular user\'s session the list will always contain the user\'s token with id "user". If a system-wide TPM token is available, the returned list will also contain the system-wide token with id "system". The system-wide token will be the same for all sessions on this device (device in the sense of e.g. a Chromebook).\n     * @param callback Invoked by getTokens with the list of available Tokens.\n     * The callback parameter should be a function that looks like this:\n     * function(array of Token tokens) {...};\n     * Parameter tokens: The list of available tokens.\n     */\n    export function getToken(callback: (tokens: Token[]) => void): void;\n    /**\n     * Returns the list of all client certificates available from the given token. Can be used to check for the existence and expiration of client certificates that are usable for a certain authentication.\n     * @param tokenId The id of a Token returned by getTokens.\n     * @param callback Called back with the list of the available certificates.\n     * The callback parameter should be a function that looks like this:\n     * function(array of ArrayBuffer certificates) {...};\n     * Parameter certificates: The list of certificates, each in DER encoding of a X.509 certificate.\n     */\n    export function getCertificates(tokenId: string, callback: (certificates: ArrayBuffer) => void): void;\n    /**\n     * Imports certificate to the given token if the certified key is already stored in this token. After a successful certification request, this function should be used to store the obtained certificate and to make it available to the operating system and browser for authentication.\n     * @param tokenId The id of a Token returned by getTokens.\n     * @param certificate The DER encoding of a X.509 certificate.\n     * @param callback Called back when this operation is finished.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function importCertificate(tokenId: string, certificate: ArrayBuffer, callback?: () => void): void;\n    /**\n     * Removes certificate from the given token if present. Should be used to remove obsolete certificates so that they are not considered during authentication and do not clutter the certificate choice. Should be used to free storage in the certificate store.\n     * @param tokenId The id of a Token returned by getTokens.\n     * @param certificate The DER encoding of a X.509 certificate.\n     * @param callback Called back when this operation is finished.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeCertificate(tokenId: string, certificate: ArrayBuffer, callback?: () => void): void;\n}\n\n////////////////////\n// Enterprise Device Attributes\n////////////////////\n/**\n * Use the <code>chrome.enterprise.deviceAttributes</code> API to read device attributes.\n * Permissions:  "enterprise.deviceAttributes"\n * Since: Chrome 46\n * Important: This API works only on Chrome OS.\n * Note: This API is only for extensions pre-installed by policy.\n */\ndeclare namespace chrome.enterprise.deviceAttributes {\n    /**\n     * @description Fetches the value of the device identifier of the directory API, that is generated by the server and identifies the cloud record of the device for querying in the cloud directory API.\n     * @export\n     * @param callback Called with the device identifier of the directory API when received.\n     * The callback parameter should be a function that looks like this:\n     * function(string deviceId) {...};\n     */\n    export function getDirectoryDeviceId(callback: (deviceId: string) => void): void;\n}\n\n////////////////////\n// Events\n////////////////////\n/**\n * The chrome.events namespace contains common types used by APIs dispatching events to notify you when something interesting happens.\n * Availability: Since Chrome 21.\n */\ndeclare namespace chrome.events {\n    /** Filters URLs for various criteria. See event filtering. All criteria are case sensitive. */\n    export interface UrlFilter {\n        /** Optional. Matches if the scheme of the URL is equal to any of the schemes specified in the array.  */\n        schemes?: string[];\n        /**\n         * Optional.\n          * Since Chrome 23.\n         * Matches if the URL (without fragment identifier) matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n         */\n        urlMatches?: string;\n        /** Optional. Matches if the path segment of the URL contains a specified string.  */\n        pathContains?: string;\n        /** Optional. Matches if the host name of the URL ends with a specified string.  */\n        hostSuffix?: string;\n        /** Optional. Matches if the host name of the URL starts with a specified string.  */\n        hostPrefix?: string;\n        /** Optional. Matches if the host name of the URL contains a specified string. To test whether a host name component has a prefix \'foo\', use hostContains: \'.foo\'. This matches \'www.foobar.com\' and \'foo.com\', because an implicit dot is added at the beginning of the host name. Similarly, hostContains can be used to match against component suffix (\'foo.\') and to exactly match against components (\'.foo.\'). Suffix- and exact-matching for the last components need to be done separately using hostSuffix, because no implicit dot is added at the end of the host name.  */\n        hostContains?: string;\n        /** Optional. Matches if the URL (without fragment identifier) contains a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlContains?: string;\n        /** Optional. Matches if the query segment of the URL ends with a specified string.  */\n        querySuffix?: string;\n        /** Optional. Matches if the URL (without fragment identifier) starts with a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlPrefix?: string;\n        /** Optional. Matches if the host name of the URL is equal to a specified string.  */\n        hostEquals?: string;\n        /** Optional. Matches if the URL (without fragment identifier) is equal to a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlEquals?: string;\n        /** Optional. Matches if the query segment of the URL contains a specified string.  */\n        queryContains?: string;\n        /** Optional. Matches if the path segment of the URL starts with a specified string.  */\n        pathPrefix?: string;\n        /** Optional. Matches if the path segment of the URL is equal to a specified string.  */\n        pathEquals?: string;\n        /** Optional. Matches if the path segment of the URL ends with a specified string.  */\n        pathSuffix?: string;\n        /** Optional. Matches if the query segment of the URL is equal to a specified string.  */\n        queryEquals?: string;\n        /** Optional. Matches if the query segment of the URL starts with a specified string.  */\n        queryPrefix?: string;\n        /** Optional. Matches if the URL (without fragment identifier) ends with a specified string. Port numbers are stripped from the URL if they match the default port number.  */\n        urlSuffix?: string;\n        /** Optional. Matches if the port of the URL is contained in any of the specified port lists. For example [80, 443, [1000, 1200]] matches all requests on port 80, 443 and in the range 1000-1200.  */\n        ports?: any[];\n        /**\n         * Optional.\n          * Since Chrome 28.\n         * Matches if the URL without query segment and fragment identifier matches a specified regular expression. Port numbers are stripped from the URL if they match the default port number. The regular expressions use the RE2 syntax.\n         */\n        originAndPathMatches?: string;\n    }\n\n    /** An object which allows the addition and removal of listeners for a Chrome event. */\n    export interface Event<T extends Function> {\n        /**\n         * Registers an event listener callback to an event.\n         * @param callback Called when an event occurs. The parameters of this function depend on the type of event.\n         * The callback parameter should be a function that looks like this:\n         * function() {...};\n         */\n        addListener(callback: T): void;\n        /**\n         * Returns currently registered rules.\n         * @param callback Called with registered rules.\n         * The callback parameter should be a function that looks like this:\n         * function(array of Rule rules) {...};\n         * Parameter rules: Rules that were registered, the optional parameters are filled with values.\n         */\n        getRules(callback: (rules: Rule[]) => void): void;\n        /**\n         * Returns currently registered rules.\n         * @param ruleIdentifiers If an array is passed, only rules with identifiers contained in this array are returned.\n         * @param callback Called with registered rules.\n         * The callback parameter should be a function that looks like this:\n         * function(array of Rule rules) {...};\n         * Parameter rules: Rules that were registered, the optional parameters are filled with values.\n         */\n        getRules(ruleIdentifiers: string[], callback: (rules: Rule[]) => void): void;\n        /**\n         * @param callback Listener whose registration status shall be tested.\n         */\n        hasListener(callback: T): boolean;\n        /**\n         * Unregisters currently registered rules.\n         * @param ruleIdentifiers If an array is passed, only rules with identifiers contained in this array are unregistered.\n         * @param callback Called when rules were unregistered.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        removeRules(ruleIdentifiers?: string[], callback?: () => void): void;\n        /**\n         * Unregisters currently registered rules.\n         * @param callback Called when rules were unregistered.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function() {...};\n         */\n        removeRules(callback?: () => void): void;\n        /**\n         * Registers rules to handle events.\n         * @param rules Rules to be registered. These do not replace previously registered rules.\n         * @param callback Called with registered rules.\n         * If you specify the callback parameter, it should be a function that looks like this:\n         * function(array of Rule rules) {...};\n         * Parameter rules: Rules that were registered, the optional parameters are filled with values.\n         */\n        addRules(rules: Rule[], callback?: (rules: Rule[]) => void): void;\n        /**\n         * Deregisters an event listener callback from an event.\n         * @param callback Listener that shall be unregistered.\n         * The callback parameter should be a function that looks like this:\n         * function() {...};\n         */\n        removeListener(callback: T): void;\n        hasListeners(): boolean;\n    }\n\n    /** Description of a declarative rule for handling events. */\n    export interface Rule {\n        /** Optional. Optional priority of this rule. Defaults to 100.  */\n        priority?: number;\n        /** List of conditions that can trigger the actions. */\n        conditions: any[];\n        /** Optional. Optional identifier that allows referencing this rule.  */\n        id?: string;\n        /** List of actions that are triggered if one of the condtions is fulfilled. */\n        actions: any[];\n        /**\n         * Optional.\n          * Since Chrome 28.\n         * Tags can be used to annotate rules and perform operations on sets of rules.\n         */\n        tags?: string[];\n    }\n}\n\n////////////////////\n// Extension\n////////////////////\n/**\n * The chrome.extension API has utilities that can be used by any extension page. It includes support for exchanging messages between an extension and its content scripts or between extensions, as described in detail in Message Passing.\n * Availability: Since Chrome 5.\n */\ndeclare namespace chrome.extension {\n    export interface FetchProperties {\n        /** Optional. The window to restrict the search to. If omitted, returns all views.  */\n        windowId?: number;\n        /** Optional. The type of view to get. If omitted, returns all views (including background pages and tabs). Valid values: \'tab\', \'notification\', \'popup\'.  */\n        type?: string;\n    }\n\n    export interface LastError {\n        /** Description of the error that has taken place. */\n        message: string;\n    }\n\n    export interface OnRequestEvent extends chrome.events.Event<((request: any, sender: runtime.MessageSender, sendResponse: (response: any) => void) => void) | ((sender: runtime.MessageSender, sendResponse: (response: any) => void) => void)> { }\n\n    /**\n     * Since Chrome 7.\n     * True for content scripts running inside incognito tabs, and for extension pages running inside an incognito process. The latter only applies to extensions with \'split\' incognito_behavior.\n     */\n    export var inIncognitoContext: boolean;\n    /** Set for the lifetime of a callback if an ansychronous extension api has resulted in an error. If no error has occured lastError will be undefined. */\n    export var lastError: LastError;\n\n    /** Returns the JavaScript \'window\' object for the background page running inside the current extension. Returns null if the extension has no background page. */\n    export function getBackgroundPage(): Window | null;\n    /**\n     * Converts a relative path within an extension install directory to a fully-qualified URL.\n     * @param path A path to a resource within an extension expressed relative to its install directory.\n     */\n    export function getURL(path: string): string;\n    /**\n     * Sets the value of the ap CGI parameter used in the extension\'s update URL. This value is ignored for extensions that are hosted in the Chrome Extension Gallery.\n     * Since Chrome 9.\n     */\n    export function setUpdateUrlData(data: string): void;\n    /** Returns an array of the JavaScript \'window\' objects for each of the pages running inside the current extension. */\n    export function getViews(fetchProperties?: FetchProperties): Window[];\n    /**\n     * Retrieves the state of the extension\'s access to the \'file://\' scheme (as determined by the user-controlled \'Allow access to File URLs\' checkbox.\n     * Since Chrome 12.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(boolean isAllowedAccess) {...};\n     * Parameter isAllowedAccess: True if the extension can access the \'file://\' scheme, false otherwise.\n     */\n    export function isAllowedFileSchemeAccess(callback: (isAllowedAccess: boolean) => void): void;\n    /**\n     * Retrieves the state of the extension\'s access to Incognito-mode (as determined by the user-controlled \'Allowed in Incognito\' checkbox.\n     * Since Chrome 12.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(boolean isAllowedAccess) {...};\n     * Parameter isAllowedAccess: True if the extension has access to Incognito mode, false otherwise.\n     */\n    export function isAllowedIncognitoAccess(callback: (isAllowedAccess: boolean) => void): void;\n    /**\n     * Sends a single request to other listeners within the extension. Similar to runtime.connect, but only sends a single request with an optional response. The extension.onRequest event is fired in each page of the extension.\n     * @deprecated Deprecated since Chrome 33. Please use runtime.sendMessage.\n     * @param extensionId The extension ID of the extension you want to connect to. If omitted, default is your own extension.\n     * @param responseCallback If you specify the responseCallback parameter, it should be a function that looks like this:\n     * function(any response) {...};\n     * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendRequest(extensionId: string, request: any, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single request to other listeners within the extension. Similar to runtime.connect, but only sends a single request with an optional response. The extension.onRequest event is fired in each page of the extension.\n     * @deprecated Deprecated since Chrome 33. Please use runtime.sendMessage.\n     * @param responseCallback If you specify the responseCallback parameter, it should be a function that looks like this:\n     * function(any response) {...};\n     * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendRequest(request: any, responseCallback?: (response: any) => void): void;\n    /**\n     * Returns an array of the JavaScript \'window\' objects for each of the tabs running inside the current extension. If windowId is specified, returns only the \'window\' objects of tabs attached to the specified window.\n     * @deprecated Deprecated since Chrome 33. Please use extension.getViews {type: "tab"}.\n     */\n    export function getExtensionTabs(windowId?: number): Window[];\n\n    /**\n     * Fired when a request is sent from either an extension process or a content script.\n     * @deprecated Deprecated since Chrome 33. Please use runtime.onMessage.\n     */\n    export var onRequest: OnRequestEvent;\n    /**\n     * Fired when a request is sent from another extension.\n     * @deprecated Deprecated since Chrome 33. Please use runtime.onMessageExternal.\n     */\n    export var onRequestExternal: OnRequestEvent;\n}\n\n////////////////////\n// File Browser Handler\n////////////////////\n/**\n * Use the chrome.fileBrowserHandler API to extend the Chrome OS file browser. For example, you can use this API to enable users to upload files to your website.\n * Availability: Since Chrome 12.\n * Permissions:  "fileBrowserHandler"\n * Important: This API works only on Chrome OS.\n */\ndeclare namespace chrome.fileBrowserHandler {\n    export interface SelectionParams {\n        /**\n         * Optional.\n          * List of file extensions that the selected file can have. The list is also used to specify what files to be shown in the select file dialog. Files with the listed extensions are only shown in the dialog. Extensions should not include the leading \'.\'. Example: [\'jpg\', \'png\']\n         * Since Chrome 23.\n         */\n        allowedFileExtensions?: string[];\n        /** Suggested name for the file. */\n        suggestedName: string;\n    }\n\n    export interface SelectionResult {\n        /** Optional. Selected file entry. It will be null if a file hasn\'t been selected.  */\n        entry?: Object | null;\n        /** Whether the file has been selected. */\n        success: boolean;\n    }\n\n    /** Event details payload for fileBrowserHandler.onExecute event. */\n    export interface FileHandlerExecuteEventDetails {\n        /** Optional. The ID of the tab that raised this event. Tab IDs are unique within a browser session.  */\n        tab_id?: number;\n        /** Array of Entry instances representing files that are targets of this action (selected in ChromeOS file browser). */\n        entries: any[];\n    }\n\n    export interface FileBrowserHandlerExecuteEvent extends chrome.events.Event<(id: string, details: FileHandlerExecuteEventDetails) => void> { }\n\n    /**\n     * Prompts user to select file path under which file should be saved. When the file is selected, file access permission required to use the file (read, write and create) are granted to the caller. The file will not actually get created during the function call, so function caller must ensure its existence before using it. The function has to be invoked with a user gesture.\n     * Since Chrome 21.\n     * @param selectionParams Parameters that will be used while selecting the file.\n     * @param callback Function called upon completion.\n     * The callback parameter should be a function that looks like this:\n     * function(object result) {...};\n     * Parameter result: Result of the method.\n     */\n    export function selectFile(selectionParams: SelectionParams, callback: (result: SelectionResult) => void): void;\n\n    /** Fired when file system action is executed from ChromeOS file browser. */\n    export var onExecute: FileBrowserHandlerExecuteEvent;\n}\n\n////////////////////\n// File System Provider\n////////////////////\n/**\n * Use the chrome.fileSystemProvider API to create file systems, that can be accessible from the file manager on Chrome OS.\n * Availability: Since Chrome 40.\n * Permissions:  "fileSystemProvider"\n * Important: This API works only on Chrome OS.\n */\ndeclare namespace chrome.fileSystemProvider {\n    export interface OpenedFileInfo {\n        /** A request ID to be be used by consecutive read/write and close requests. */\n        openRequestId: number;\n        /** The path of the opened file. */\n        filePath: string;\n        /** Whether the file was opened for reading or writing. */\n        mode: string;\n    }\n\n    export interface FileWatchersInfo {\n        /** The path of the entry being observed. */\n        entryPath: string;\n        /** Whether watching should include all child entries recursively. It can be true for directories only. */\n        recursive: boolean;\n        /** Optional. Tag used by the last notification for the watcher.  */\n        lastTag?: string;\n    }\n\n    export interface EntryMetadata {\n        /** True if it is a directory. */\n        isDirectory: boolean;\n        /** Name of this entry (not full path name). Must not contain \'/\'. For root it must be empty. */\n        name: string;\n        /** File size in bytes. */\n        size: number;\n        /** The last modified time of this entry. */\n        modificationTime: Date;\n        /** Optional. Mime type for the entry.  */\n        mimeType?: string;\n        /** Optional. Thumbnail image as a data URI in either PNG, JPEG or WEBP format, at most 32 KB in size. Optional, but can be provided only when explicitly requested by the onGetMetadataRequested event.  */\n        thumbnail?: string;\n    }\n\n    export interface FileSystemInfo {\n        /** The identifier of the file system. */\n        fileSystemId: string;\n        /** A human-readable name for the file system. */\n        displayName: string;\n        /** Whether the file system supports operations which may change contents of the file system (such as creating, deleting or writing to files). */\n        writable: boolean;\n        /**\n         * The maximum number of files that can be opened at once. If 0, then not limited.\n         * @since Since Chrome 42.\n         */\n        openedFilesLimit: number;\n        /**\n         * List of currently opened files.\n         * @since Since Chrome 42.\n         */\n        openedFiles: OpenedFileInfo[];\n        /**\n         * Optional.\n          * Whether the file system supports the tag field for observing directories.\n         * @since Since Chrome 45. Warning: this is the current Beta channel.\n         */\n        supportsNotifyTag?: boolean;\n        /**\n         * List of watchers.\n         * @since Since Chrome 45. Warning: this is the current Beta channel.\n         */\n        watchers: FileWatchersInfo[];\n    }\n\n    /** @since Since Chrome 45. Warning: this is the current Beta channel. */\n    export interface GetActionsRequestedOptions {\n        /** The identifier of the file system related to this operation. */\n        fileSystemId: string;\n        /** The unique identifier of this request. */\n        requestId: number;\n        /** The path of the entry to return the list of actions for. */\n        entryPath: string;\n    }\n\n    /** @since Since Chrome 45. Warning: this is the current Beta channel. */\n    export interface Action {\n        /** The identifier of the action. Any string or CommonActionId for common actions. */\n        id: string;\n        /** Optional. The title of the action. It may be ignored for common actions.  */\n        title?: string;\n    }\n\n    /** @since Since Chrome 45. Warning: this is the current Beta channel. */\n    export interface ExecuteActionRequestedOptions {\n        /** The identifier of the file system related to this operation. */\n        fileSystemId: string;\n        /** The unique identifier of this request. */\n        requestId: number;\n        /** The path of the entry to be used for the action. */\n        entryPath: string;\n        /** The identifier of the action to be executed. */\n        actionId: string;\n    }\n\n    export interface MountOptions {\n        /** The string indentifier of the file system. Must be unique per each extension. */\n        fileSystemId: string;\n        /** A human-readable name for the file system. */\n        displayName: string;\n        /** Optional. Whether the file system supports operations which may change contents of the file system (such as creating, deleting or writing to files).  */\n        writable?: boolean;\n        /**\n         * Optional.\n          * The maximum number of files that can be opened at once. If not specified, or 0, then not limited.\n         * @since Since Chrome 41.\n         */\n        openedFilesLimit?: number;\n        /**\n         * Optional.\n          * Whether the file system supports the tag field for observed directories.\n         * @since Since Chrome 45. Warning: this is the current Beta channel.\n         */\n        supportsNotifyTag?: boolean;\n    }\n\n    export interface UnmountOptions {\n        /** The identifier of the file system to be unmounted. */\n        fileSystemId: string;\n    }\n\n    export interface NotificationChange {\n        /** The path of the changed entry. */\n        entryPath: string;\n        /** The type of the change which happened to the entry. */\n        changeType: string;\n    }\n\n    export interface NotificationOptions {\n        /** The identifier of the file system related to this change. */\n        fileSystemId: string;\n        /** The path of the observed entry. */\n        observedPath: string;\n        /** Mode of the observed entry. */\n        recursive: boolean;\n        /** The type of the change which happened to the observed entry. If it is DELETED, then the observed entry will be automatically removed from the list of observed entries. */\n        changeType: string;\n        /** Optional. List of changes to entries within the observed directory (including the entry itself)  */\n        changes?: NotificationChange[];\n        /** Optional. Tag for the notification. Required if the file system was mounted with the supportsNotifyTag option. Note, that this flag is necessary to provide notifications about changes which changed even when the system was shutdown.  */\n        tag?: string;\n    }\n\n    export interface RequestedEventOptions {\n        /** The identifier of the file system related to this operation. */\n        fileSystemId: string;\n        /** The unique identifier of this request. */\n        requestId: number;\n    }\n\n    export interface EntryPathRequestedEventOptions extends RequestedEventOptions {\n        /** The path of the entry to which this operation is related to. */\n        entryPath: string;\n    }\n\n    export interface MetadataRequestedEventOptions extends EntryPathRequestedEventOptions {\n        /** Set to true if the thumbnail is requested. */\n        thumbnail: boolean;\n    }\n\n    export interface DirectoryPathRequestedEventOptions extends RequestedEventOptions {\n        /** The path of the directory which is to be operated on. */\n        directoryPath: string;\n    }\n\n    export interface FilePathRequestedEventOptions extends RequestedEventOptions {\n        /** The path of the entry for the operation */\n        filePath: string;\n    }\n\n    export interface OpenFileRequestedEventOptions extends FilePathRequestedEventOptions {\n        /** Whether the file will be used for reading or writing. */\n        mode: string;\n    }\n\n    export interface OpenedFileRequestedEventOptions extends RequestedEventOptions {\n        /** A request ID used to open the file. */\n        openRequestId: number;\n    }\n\n    export interface OpenedFileOffsetRequestedEventOptions extends OpenedFileRequestedEventOptions {\n        /** Position in the file (in bytes) to start reading from. */\n        offset: number;\n        /** Number of bytes to be returned. */\n        length: number;\n    }\n\n    export interface DirectoryPathRecursiveRequestedEventOptions extends DirectoryPathRequestedEventOptions {\n        /** Whether the operation is recursive (for directories only). */\n        recursive: boolean;\n    }\n\n    export interface EntryPathRecursiveRequestedEventOptions extends EntryPathRequestedEventOptions {\n        /** Whether the operation is recursive (for directories only). */\n        recursive: boolean;\n    }\n\n    export interface SourceTargetPathRequestedEventOptions extends RequestedEventOptions {\n        /** The source path for the operation. */\n        sourcePath: string;\n        /** The destination path for the operation. */\n        targetPath: string;\n    }\n\n    export interface FilePathLengthRequestedEventOptions extends FilePathRequestedEventOptions {\n        /** Number of bytes to be retained after the operation completes. */\n        length: number;\n    }\n\n    export interface OpenedFileIoRequestedEventOptions extends OpenedFileRequestedEventOptions {\n        /** Position in the file (in bytes) to start operating from. */\n        offset: number;\n        /** Buffer of bytes to be operated on the file. */\n        data: ArrayBuffer;\n    }\n\n    export interface OperationRequestedEventOptions extends RequestedEventOptions {\n        /** An ID of the request to which this operation is related. */\n        operationRequestId: number;\n    }\n\n    export interface RequestedEvent extends chrome.events.Event<(options: RequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface MetadataRequestedEvent extends chrome.events.Event<(options: MetadataRequestedEventOptions, successCallback: (metadata: EntryMetadata) => void, errorCallback: (error: string) => void) => void> { }\n\n    export interface DirectoryPathRequestedEvent extends chrome.events.Event<(options: DirectoryPathRequestedEventOptions, successCallback: (entries: EntryMetadata[], hasMore: boolean) => void, errorCallback: (error: string) => void) => void> { }\n\n    export interface OpenFileRequestedEvent extends chrome.events.Event<(options: OpenFileRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface OpenedFileRequestedEvent extends chrome.events.Event<(options: OpenedFileRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface OpenedFileOffsetRequestedEvent extends chrome.events.Event<(options: OpenedFileOffsetRequestedEventOptions, successCallback: (data: ArrayBuffer, hasMore: boolean) => void, errorCallback: (error: string) => void) => void> { }\n\n    export interface DirectoryPathRecursiveRequestedEvent extends chrome.events.Event<(options: DirectoryPathRecursiveRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface EntryPathRecursiveRequestedEvent extends chrome.events.Event<(options: EntryPathRecursiveRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface FilePathRequestedEvent extends chrome.events.Event<(options: FilePathRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface SourceTargetPathRequestedEvent extends chrome.events.Event<(options: SourceTargetPathRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface FilePathLengthRequestedEvent extends chrome.events.Event<(options: FilePathLengthRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface OpenedFileIoRequestedEvent extends chrome.events.Event<(options: OpenedFileIoRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface OperationRequestedEvent extends chrome.events.Event<(options: OperationRequestedEventOptions, successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    export interface OptionlessRequestedEvent extends chrome.events.Event<(successCallback: Function, errorCallback: (error: string) => void) => void> { }\n\n    /**\n     * Mounts a file system with the given fileSystemId and displayName. displayName will be shown in the left panel of Files.app. displayName can contain any characters including \'/\', but cannot be an empty string. displayName must be descriptive but doesn\'t have to be unique. The fileSystemId must not be an empty string.\n     * Depending on the type of the file system being mounted, the source option must be set appropriately.\n     * In case of an error, runtime.lastError will be set with a corresponding error code.\n     * @param callback A generic result callback to indicate success or failure.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function mount(options: MountOptions, callback?: () => void): void;\n    /**\n     * Unmounts a file system with the given fileSystemId. It must be called after onUnmountRequested is invoked. Also, the providing extension can decide to perform unmounting if not requested (eg. in case of lost connection, or a file error).\n     * In case of an error, runtime.lastError will be set with a corresponding error code.\n     * @param callback A generic result callback to indicate success or failure.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function unmount(options: UnmountOptions, callback?: () => void): void;\n    /**\n     * Returns all file systems mounted by the extension.\n     * @param callback Callback to receive the result of getAll function.\n     * The callback parameter should be a function that looks like this:\n     * function(array of FileSystemInfo fileSystems) {...};\n     */\n    export function getAll(callback: (fileSystems: FileSystemInfo[]) => void): void;\n    /**\n     * Returns information about a file system with the passed fileSystemId.\n     * @since Since Chrome 42.\n     * @param callback Callback to receive the result of get function.\n     * The callback parameter should be a function that looks like this:\n     * function(FileSystemInfo fileSystem) {...};\n     */\n    export function get(fileSystemId: string, callback: (fileSystem: FileSystemInfo) => void): void;\n    /**\n     * Notifies about changes in the watched directory at observedPath in recursive mode. If the file system is mounted with supportsNofityTag, then tag must be provided, and all changes since the last notification always reported, even if the system was shutdown. The last tag can be obtained with getAll.\n     * To use, the file_system_provider.notify manifest option must be set to true.\n     * Value of tag can be any string which is unique per call, so it\'s possible to identify the last registered notification. Eg. if the providing extension starts after a reboot, and the last registered notification\'s tag is equal to "123", then it should call notify for all changes which happened since the change tagged as "123". It cannot be an empty string.\n     * Not all providers are able to provide a tag, but if the file system has a changelog, then the tag can be eg. a change number, or a revision number.\n     * Note that if a parent directory is removed, then all descendant entries are also removed, and if they are watched, then the API must be notified about the fact. Also, if a directory is renamed, then all descendant entries are in fact removed, as there is no entry under their original paths anymore.\n     * In case of an error, runtime.lastError will be set will a corresponding error code.\n     * @param callback A generic result callback to indicate success or failure.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function notify(options: NotificationOptions, callback: () => void): void;\n\n    /** Raised when unmounting for the file system with the fileSystemId identifier is requested. In the response, the unmount API method must be called together with successCallback. If unmounting is not possible (eg. due to a pending operation), then errorCallback must be called.  */\n    export var onUnmountRequested: RequestedEvent;\n    /** Raised when metadata of a file or a directory at entryPath is requested. The metadata must be returned with the successCallback call. In case of an error, errorCallback must be called. */\n    export var onGetMetadataRequested: MetadataRequestedEvent;\n    /** Raised when contents of a directory at directoryPath are requested. The results must be returned in chunks by calling the successCallback several times. In case of an error, errorCallback must be called. */\n    export var onReadDirectoryRequested: DirectoryPathRequestedEvent;\n    /** Raised when opening a file at filePath is requested. If the file does not exist, then the operation must fail. Maximum number of files opened at once can be specified with MountOptions. */\n    export var onOpenFileRequested: OpenFileRequestedEvent;\n    /** Raised when opening a file previously opened with openRequestId is requested to be closed. */\n    export var onCloseFileRequested: OpenedFileRequestedEvent;\n    /** Raised when reading contents of a file opened previously with openRequestId is requested. The results must be returned in chunks by calling successCallback several times. In case of an error, errorCallback must be called. */\n    export var onReadFileRequested: OpenedFileOffsetRequestedEvent;\n    /** Raised when creating a directory is requested. The operation must fail with the EXISTS error if the target directory already exists. If recursive is true, then all of the missing directories on the directory path must be created. */\n    export var onCreateDirectoryRequested: DirectoryPathRecursiveRequestedEvent;\n    /** Raised when deleting an entry is requested. If recursive is true, and the entry is a directory, then all of the entries inside must be recursively deleted as well. */\n    export var onDeleteEntryRequested: EntryPathRecursiveRequestedEvent;\n    /** Raised when creating a file is requested. If the file already exists, then errorCallback must be called with the "EXISTS" error code. */\n    export var onCreateFileRequested: FilePathRequestedEvent;\n    /** Raised when copying an entry (recursively if a directory) is requested. If an error occurs, then errorCallback must be called. */\n    export var onCopyEntryRequested: SourceTargetPathRequestedEvent;\n    /** Raised when moving an entry (recursively if a directory) is requested. If an error occurs, then errorCallback must be called. */\n    export var onMoveEntryRequested: SourceTargetPathRequestedEvent;\n    /** Raised when truncating a file to a desired length is requested. If an error occurs, then errorCallback must be called. */\n    export var onTruncateRequested: FilePathLengthRequestedEvent;\n    /** Raised when writing contents to a file opened previously with openRequestId is requested. */\n    export var onWriteFileRequested: OpenedFileIoRequestedEvent;\n    /** Raised when aborting an operation with operationRequestId is requested. The operation executed with operationRequestId must be immediately stopped and successCallback of this abort request executed. If aborting fails, then errorCallback must be called. Note, that callbacks of the aborted operation must not be called, as they will be ignored. Despite calling errorCallback, the request may be forcibly aborted. */\n    export var onAbortRequested: OperationRequestedEvent;\n    /**\n     * Raised when showing a configuration dialog for fileSystemId is requested. If it\'s handled, the file_system_provider.configurable manfiest option must be set to true.\n     * @since Since Chrome 44.\n     */\n    export var onConfigureRequested: RequestedEvent;\n    /**\n     * Raised when showing a dialog for mounting a new file system is requested. If the extension/app is a file handler, then this event shouldn\'t be handled. Instead app.runtime.onLaunched should be handled in order to mount new file systems when a file is opened. For multiple mounts, the file_system_provider.multiple_mounts manifest option must be set to true.\n     * @since Since Chrome 44.\n     */\n    export var onMountRequested: OptionlessRequestedEvent;\n    /**\n     * Raised when setting a new directory watcher is requested. If an error occurs, then errorCallback must be called.\n     * @since Since Chrome 45. Warning: this is the current Beta channel.\n     */\n    export var onAddWatcherRequested: EntryPathRecursiveRequestedEvent;\n    /**\n     * Raised when the watcher should be removed. If an error occurs, then errorCallback must be called.\n     * @since Since Chrome 45. Warning: this is the current Beta channel.\n     */\n    export var onRemoveWatcherRequested: EntryPathRecursiveRequestedEvent;\n}\n\n////////////////////\n// Font Settings\n////////////////////\n/**\n * Use the chrome.fontSettings API to manage Chrome\'s font settings.\n * Availability: Since Chrome 22.\n * Permissions:  "fontSettings"\n */\ndeclare namespace chrome.fontSettings {\n    /** Represents a font name. */\n    export interface FontName {\n        /** The display name of the font. */\n        displayName: string;\n        /** The font ID. */\n        fontId: string;\n    }\n\n    export interface DefaultFontSizeDetails {\n        /** The font size in pixels. */\n        pixelSize: number;\n    }\n\n    export interface FontDetails {\n        /** The generic font family for the font. */\n        genericFamily: string;\n        /** Optional. The script for the font. If omitted, the global script font setting is affected.  */\n        script?: string;\n    }\n\n    export interface FullFontDetails {\n        /** The generic font family for which the font setting has changed. */\n        genericFamily: string;\n        /** The level of control this extension has over the setting. */\n        levelOfControl: string;\n        /** Optional. The script code for which the font setting has changed.  */\n        script?: string;\n        /** The font ID. See the description in getFont. */\n        fontId: string;\n    }\n\n    export interface FontDetailsResult {\n        /** The level of control this extension has over the setting. */\n        levelOfControl: string;\n        /** The font ID. Rather than the literal font ID preference value, this may be the ID of the font that the system resolves the preference value to. So, fontId can differ from the font passed to setFont, if, for example, the font is not available on the system. The empty string signifies fallback to the global script font setting. */\n        fontId: string;\n    }\n\n    export interface FontSizeDetails {\n        /** The font size in pixels. */\n        pixelSize: number;\n        /** The level of control this extension has over the setting. */\n        levelOfControl: string;\n    }\n\n    export interface SetFontSizeDetails {\n        /** The font size in pixels. */\n        pixelSize: number;\n    }\n\n    export interface SetFontDetails extends FontDetails {\n        /** The font ID. The empty string means to fallback to the global script font setting. */\n        fontId: string;\n    }\n\n    export interface DefaultFixedFontSizeChangedEvent extends chrome.events.Event<(details: FontSizeDetails) => void> { }\n\n    export interface DefaultFontSizeChangedEvent extends chrome.events.Event<(details: FontSizeDetails) => void> { }\n\n    export interface MinimumFontSizeChangedEvent extends chrome.events.Event<(details: FontSizeDetails) => void> { }\n\n    export interface FontChangedEvent extends chrome.events.Event<(details: FullFontDetails) => void> { }\n\n    /**\n     * Sets the default font size.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setDefaultFontSize(details: DefaultFontSizeDetails, callback?: Function): void;\n    /**\n     * Gets the font for a given script and generic font family.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function getFont(details: FontDetails, callback?: (details: FontDetailsResult) => void): void;\n    /**\n     * Gets the default font size.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function getDefaultFontSize(details?: Object, callback?: (options: FontSizeDetails) => void): void;\n    /**\n     * Gets the minimum font size.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function getMinimumFontSize(details?: FontSizeDetails, callback?: (options: FontSizeDetails) => void): void;\n    /**\n     * Sets the minimum font size.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setMinimumFontSize(details: SetFontSizeDetails, callback?: Function): void;\n    /**\n     * Gets the default size for fixed width fonts.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function getDefaultFixedFontSize(details?: Object, callback?: (details: FontSizeDetails) => void): void;\n    /**\n     * Clears the default font size set by this extension, if any.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function clearDefaultFontSize(details?: Object, callback?: Function): void;\n    /**\n     * Sets the default size for fixed width fonts.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setDefaultFixedFontSize(details: SetFontSizeDetails, callback?: Function): void;\n    /**\n     * Clears the font set by this extension, if any.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function clearFont(details: FontDetails, callback?: Function): void;\n    /**\n     * Sets the font for a given script and generic font family.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(object details) {...};\n     */\n    export function setFont(details: SetFontDetails, callback?: Function): void;\n    /**\n     * Clears the minimum font size set by this extension, if any.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function clearMinimumFontSize(details?: Object, callback?: Function): void;\n    /**\n     * Gets a list of fonts on the system.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of FontName results) {...};\n     */\n    export function getFontList(callback: (results: FontName[]) => void): void;\n    /**\n     * Clears the default fixed font size set by this extension, if any.\n     * @param details This parameter is currently unused.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function clearDefaultFixedFontSize(details: Object, callback?: Function): void;\n\n    /** Fired when the default fixed font size setting changes. */\n    export var onDefaultFixedFontSizeChanged: DefaultFixedFontSizeChangedEvent;\n    /** Fired when the default font size setting changes. */\n    export var onDefaultFontSizeChanged: DefaultFontSizeChangedEvent;\n    /** Fired when the minimum font size setting changes. */\n    export var onMinimumFontSizeChanged: MinimumFontSizeChangedEvent;\n    /** Fired when a font setting changes. */\n    export var onFontChanged: FontChangedEvent;\n}\n\n////////////////////\n// Google Cloud Messaging\n////////////////////\n/**\n * Use chrome.gcm to enable apps and extensions to send and receive messages through the Google Cloud Messaging Service.\n * Availability: Since Chrome 35.\n * Permissions:  "gcm"\n */\ndeclare namespace chrome.gcm {\n    export interface OutgoingMessage {\n        /** The ID of the server to send the message to as assigned by Google API Console. */\n        destinationId: string;\n        /** The ID of the message. It must be unique for each message in scope of the applications. See the Cloud Messaging documentation for advice for picking and handling an ID. */\n        messageId: string;\n        /** Optional. Time-to-live of the message in seconds. If it is not possible to send the message within that time, an onSendError event will be raised. A time-to-live of 0 indicates that the message should be sent immediately or fail if it\'s not possible. The maximum and a default value of time-to-live is 86400 seconds (1 day). */\n        timeToLive?: number;\n        /** Message data to send to the server. Case-insensitive goog. and google, as well as case-sensitive collapse_key are disallowed as key prefixes. Sum of all key/value pairs should not exceed gcm.MAX_MESSAGE_SIZE. */\n        data: Object;\n    }\n\n    export interface IncomingMessage {\n        /** The message data. */\n        data: Object;\n        /**\n         * Optional.\n         * The sender who issued the message.\n         * @since Since Chrome 41.\n         */\n        from?: string;\n        /**\n         * Optional.\n         * The collapse key of a message. See Collapsible Messages section of Cloud Messaging documentation for details.\n         */\n        collapseKey?: string;\n    }\n\n    export interface GcmError {\n        /** The error message describing the problem. */\n        errorMessage: string;\n        /** Optional. The ID of the message with this error, if error is related to a specific message. */\n        messageId?: string;\n        /** Additional details related to the error, when available. */\n        detail: Object;\n    }\n\n    export interface MessageReceptionEvent extends chrome.events.Event<(message: IncomingMessage) => void> { }\n\n    export interface MessageDeletionEvent extends chrome.events.Event<() => void> { }\n\n    export interface GcmErrorEvent extends chrome.events.Event<(error: GcmError) => void> { }\n\n    /** The maximum size (in bytes) of all key/value pairs in a message. */\n    export var MAX_MESSAGE_SIZE: number;\n\n    /**\n     * Registers the application with GCM. The registration ID will be returned by the callback. If register is called again with the same list of senderIds, the same registration ID will be returned.\n     * @param senderIds A list of server IDs that are allowed to send messages to the application. It should contain at least one and no more than 100 sender IDs.\n     * @param callback Function called when registration completes. It should check runtime.lastError for error when registrationId is empty.\n     * The callback parameter should be a function that looks like this:\n     * function(string registrationId) {...};\n     * Parameter registrationId: A registration ID assigned to the application by the GCM.\n     */\n    export function register(senderIds: string[], callback: (registrationId: string) => void): void;\n    /**\n     * Unregisters the application from GCM.\n     * @param callback A function called after the unregistration completes. Unregistration was successful if runtime.lastError is not set.\n     * The callback parameter should be a function that looks like this:\n     * function() {...};\n     */\n    export function unregister(callback: () => void): void;\n    /**\n     * Sends a message according to its contents.\n     * @param message A message to send to the other party via GCM.\n     * @param callback A function called after the message is successfully queued for sending. runtime.lastError should be checked, to ensure a message was sent without problems.\n     * The callback parameter should be a function that looks like this:\n     * function(string messageId) {...};\n     * Parameter messageId: The ID of the message that the callback was issued for.\n     */\n    export function send(message: OutgoingMessage, callback: (messageId: string) => void): void;\n\n    /** Fired when a message is received through GCM. */\n    export var onMessage: MessageReceptionEvent;\n    /** Fired when a GCM server had to delete messages sent by an app server to the application. See Messages deleted event section of Cloud Messaging documentation for details on handling this event. */\n    export var onMessagesDeleted: MessageDeletionEvent;\n    /** Fired when it was not possible to send a message to the GCM server. */\n    export var onSendError: GcmErrorEvent;\n}\n\n////////////////////\n// History\n////////////////////\n/**\n * Use the chrome.history API to interact with the browser\'s record of visited pages. You can add, remove, and query for URLs in the browser\'s history. To override the history page with your own version, see Override Pages.\n * Availability: Since Chrome 5.\n * Permissions:  "history"\n */\ndeclare namespace chrome.history {\n    /** An object encapsulating one visit to a URL. */\n    export interface VisitItem {\n        /** The transition type for this visit from its referrer. */\n        transition: string;\n        /** Optional. When this visit occurred, represented in milliseconds since the epoch. */\n        visitTime?: number;\n        /** The unique identifier for this visit. */\n        visitId: string;\n        /** The visit ID of the referrer. */\n        referringVisitId: string;\n        /** The unique identifier for the item. */\n        id: string;\n    }\n\n    /** An object encapsulating one result of a history query. */\n    export interface HistoryItem {\n        /** Optional. The number of times the user has navigated to this page by typing in the address. */\n        typedCount?: number;\n        /** Optional. The title of the page when it was last loaded. */\n        title?: string;\n        /** Optional. The URL navigated to by a user. */\n        url?: string;\n        /** Optional. When this page was last loaded, represented in milliseconds since the epoch. */\n        lastVisitTime?: number;\n        /** Optional. The number of times the user has navigated to this page. */\n        visitCount?: number;\n        /** The unique identifier for the item. */\n        id: string;\n    }\n\n    export interface HistoryQuery {\n        /** A free-text query to the history service. Leave empty to retrieve all pages. */\n        text: string;\n        /** Optional. The maximum number of results to retrieve. Defaults to 100. */\n        maxResults?: number;\n        /** Optional. Limit results to those visited after this date, represented in milliseconds since the epoch. */\n        startTime?: number;\n        /** Optional. Limit results to those visited before this date, represented in milliseconds since the epoch. */\n        endTime?: number;\n    }\n\n    export interface Url {\n        /** The URL for the operation. It must be in the format as returned from a call to history.search. */\n        url: string;\n    }\n\n    export interface Range {\n        /** Items added to history before this date, represented in milliseconds since the epoch. */\n        endTime: number;\n        /** Items added to history after this date, represented in milliseconds since the epoch. */\n        startTime: number;\n    }\n\n    export interface RemovedResult {\n        /** True if all history was removed. If true, then urls will be empty. */\n        allHistory: boolean;\n        /** Optional. */\n        urls?: string[];\n    }\n\n    export interface HistoryVisitedEvent extends chrome.events.Event<(result: HistoryItem) => void> { }\n\n    export interface HistoryVisitRemovedEvent extends chrome.events.Event<(removed: RemovedResult) => void> { }\n\n    /**\n     * Searches the history for the last visit time of each page matching the query.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of HistoryItem results) {...};\n     */\n    export function search(query: HistoryQuery, callback: (results: HistoryItem[]) => void): void;\n    /**\n     * Adds a URL to the history at the current time with a transition type of "link".\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function addUrl(details: Url, callback?: () => void): void;\n    /**\n     * Removes all items within the specified date range from the history. Pages will not be removed from the history unless all visits fall within the range.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function() {...};\n     */\n    export function deleteRange(range: Range, callback: () => void): void;\n    /**\n     * Deletes all items from the history.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function() {...};\n     */\n    export function deleteAll(callback: () => void): void;\n    /**\n     * Retrieves information about visits to a URL.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of VisitItem results) {...};\n     */\n    export function getVisits(details: Url, callback: (results: VisitItem[]) => void): void;\n    /**\n     * Removes all occurrences of the given URL from the history.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function deleteUrl(details: Url, callback?: () => void): void;\n\n    /** Fired when a URL is visited, providing the HistoryItem data for that URL. This event fires before the page has loaded. */\n    export var onVisited: HistoryVisitedEvent;\n    /** Fired when one or more URLs are removed from the history service. When all visits have been removed the URL is purged from history. */\n    export var onVisitRemoved: HistoryVisitRemovedEvent;\n}\n\n////////////////////\n// i18n\n////////////////////\n/**\n * Use the chrome.i18n infrastructure to implement internationalization across your whole app or extension.\n * @since Chrome 5.\n */\ndeclare namespace chrome.i18n {\n    /** Holds detected ISO language code and its percentage in the input string */\n    export interface DetectedLanguage {\n        /** An ISO language code such as \'en\' or \'fr\'.\n         * For a complete list of languages supported by this method, see  [kLanguageInfoTable]{@link https://src.chromium.org/viewvc/chrome/trunk/src/third_party/cld/languages/internal/languages.cc}.\n         * For an unknown language, \'und\' will be returned, which means that [percentage] of the text is unknown to CLD */\n        language: string;\n\n        /** The percentage of the detected language */\n        percentage: number;\n    }\n\n    /** Holds detected language reliability and array of DetectedLanguage */\n    export interface LanguageDetectionResult {\n        /** CLD detected language reliability */\n        isReliable: boolean;\n\n        /** Array of detectedLanguage */\n        languages: DetectedLanguage[];\n    }\n\n    /**\n     * Gets the accept-languages of the browser. This is different from the locale used by the browser; to get the locale, use i18n.getUILanguage.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of string languages) {...};\n     * Parameter languages: Array of the accept languages of the browser, such as en-US,en,zh-CN\n     */\n    export function getAcceptLanguages(callback: (languages: string[]) => void): void;\n    /**\n     * Gets the localized string for the specified message. If the message is missing, this method returns an empty string (\'\'). If the format of the getMessage() call is wrong \u2014 for example, messageName is not a string or the substitutions array has more than 9 elements \u2014 this method returns undefined.\n     * @param messageName The name of the message, as specified in the messages.json file.\n     * @param substitutions Optional. Up to 9 substitution strings, if the message requires any.\n     */\n    export function getMessage(messageName: string, substitutions?: any): string;\n    /**\n     * Gets the browser UI language of the browser. This is different from i18n.getAcceptLanguages which returns the preferred user languages.\n     * @since Chrome 35.\n     */\n    export function getUILanguage(): string;\n\n    /** Detects the language of the provided text using CLD.\n     * @param text User input string to be translated.\n     * @param callback The callback parameter should be a function that looks like this: function(object result) {...};\n     */\n    export function detectLanguage(text: string, callback: (result: LanguageDetectionResult) => void): void;\n}\n\n////////////////////\n// Identity\n////////////////////\n/**\n * Use the chrome.identity API to get OAuth2 access tokens.\n * Permissions:  "identity"\n * @since Chrome 29.\n */\ndeclare namespace chrome.identity {\n    /** @since Chrome 32. */\n    export interface AccountInfo {\n        /** A unique identifier for the account. This ID will not change for the lifetime of the account. */\n        id: string;\n    }\n\n    export interface TokenDetails {\n        /**\n         * Optional.\n         * Fetching a token may require the user to sign-in to Chrome, or approve the application\'s requested scopes. If the interactive flag is true, getAuthToken will prompt the user as necessary. When the flag is false or omitted, getAuthToken will return failure any time a prompt would be required.\n         */\n        interactive?: boolean;\n        /**\n         * Optional.\n         * The account ID whose token should be returned. If not specified, the primary account for the profile will be used.\n         * account is only supported when the "enable-new-profile-management" flag is set.\n         * @since Chrome 37.\n         */\n        account?: AccountInfo;\n        /**\n         * Optional.\n         * A list of OAuth2 scopes to request.\n         * When the scopes field is present, it overrides the list of scopes specified in manifest.json.\n         * @since Chrome 37.\n         */\n        scopes?: string[];\n    }\n\n    export interface UserInfo {\n        /** An email address for the user account signed into the current profile. Empty if the user is not signed in or the identity.email manifest permission is not specified. */\n        email: string;\n        /** A unique identifier for the account. This ID will not change for the lifetime of the account. Empty if the user is not signed in or (in M41+) the identity.email manifest permission is not specified. */\n        id: string;\n    }\n\n    export interface TokenInformation {\n        /** The specific token that should be removed from the cache. */\n        token: string;\n    }\n\n    export interface WebAuthFlowOptions {\n        /** The URL that initiates the auth flow. */\n        url: string;\n        /**\n         * Optional.\n         * Whether to launch auth flow in interactive mode.\n         * Since some auth flows may immediately redirect to a result URL, launchWebAuthFlow hides its web view until the first navigation either redirects to the final URL, or finishes loading a page meant to be displayed.\n         * If the interactive flag is true, the window will be displayed when a page load completes. If the flag is false or omitted, launchWebAuthFlow will return with an error if the initial navigation does not complete the flow.\n         */\n        interactive?: boolean;\n    }\n\n    export interface SignInChangeEvent extends chrome.events.Event<(account: AccountInfo, signedIn: boolean) => void> { }\n\n    /**\n     * Retrieves a list of AccountInfo objects describing the accounts present on the profile.\n     * getAccounts is only supported on dev channel.\n     * Dev channel only.\n     */\n    export function getAccounts(callback: (accounts: AccountInfo[]) => void): void;\n    /**\n     * Gets an OAuth2 access token using the client ID and scopes specified in the oauth2 section of manifest.json.\n     * The Identity API caches access tokens in memory, so it\'s ok to call getAuthToken non-interactively any time a token is required. The token cache automatically handles expiration.\n     * For a good user experience it is important interactive token requests are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests, or Chrome sign in screens if they are not signed in, with with no context. In particular, do not use getAuthToken interactively when your app is first launched.\n     * @param details Token options.\n     * @param callback Called with an OAuth2 access token as specified by the manifest, or undefined if there was an error.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(string token) {...};\n     */\n    export function getAuthToken(details: TokenDetails, callback?: (token: string) => void): void;\n    /**\n     * Retrieves email address and obfuscated gaia id of the user signed into a profile.\n     * This API is different from identity.getAccounts in two ways. The information returned is available offline, and it only applies to the primary account for the profile.\n     * @since Chrome 37.\n     */\n    export function getProfileUserInfo(callback: (userInfo: UserInfo) => void): void;\n    /**\n     * Removes an OAuth2 access token from the Identity API\'s token cache.\n     * If an access token is discovered to be invalid, it should be passed to removeCachedAuthToken to remove it from the cache. The app may then retrieve a fresh token with getAuthToken.\n     * @param details Token information.\n     * @param callback Called when the token has been removed from the cache.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function removeCachedAuthToken(details: TokenInformation, callback?: () => void): void;\n    /**\n     * Starts an auth flow at the specified URL.\n     * This method enables auth flows with non-Google identity providers by launching a web view and navigating it to the first URL in the provider\'s auth flow. When the provider redirects to a URL matching the pattern https://<app-id>.chromiumapp.org/*, the window will close, and the final redirect URL will be passed to the callback function.\n     * For a good user experience it is important interactive auth flows are initiated by UI in your app explaining what the authorization is for. Failing to do this will cause your users to get authorization requests with no context. In particular, do not launch an interactive auth flow when your app is first launched.\n     * @param details WebAuth flow options.\n     * @param callback Called with the URL redirected back to your application.\n     * The callback parameter should be a function that looks like this:\n     * function(string responseUrl) {...};\n     */\n    export function launchWebAuthFlow(details: WebAuthFlowOptions, callback: (responseUrl?: string) => void): void;\n    /**\n     * Generates a redirect URL to be used in launchWebAuthFlow.\n     * The generated URLs match the pattern https://<app-id>.chromiumapp.org/*.\n     * @since Chrome 33.\n     * @param path Optional. The path appended to the end of the generated URL.\n     */\n    export function getRedirectURL(path?: string): string;\n\n    /**\n     * Fired when signin state changes for an account on the user\'s profile.\n     * @since Chrome 33.\n     */\n    export var onSignInChanged: SignInChangeEvent;\n}\n\n////////////////////\n// Idle\n////////////////////\n/**\n * Use the chrome.idle API to detect when the machine\'s idle state changes.\n * Permissions:  "idle"\n * @since Chrome 6.\n */\ndeclare namespace chrome.idle {\n    export interface IdleStateChangedEvent extends chrome.events.Event<(newState: string) => void> { }\n\n    /**\n     * Returns "locked" if the system is locked, "idle" if the user has not generated any input for a specified number of seconds, or "active" otherwise.\n     * @param detectionIntervalInSeconds The system is considered idle if detectionIntervalInSeconds seconds have elapsed since the last user input detected.\n     * Since Chrome 25.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( IdleState newState) {...};\n     */\n    export function queryState(detectionIntervalInSeconds: number, callback: (newState: string) => void): void;\n    /**\n     * Sets the interval, in seconds, used to determine when the system is in an idle state for onStateChanged events. The default interval is 60 seconds.\n     * @since Chrome 25.\n     * @param intervalInSeconds Threshold, in seconds, used to determine when the system is in an idle state.\n     */\n    export function setDetectionInterval(intervalInSeconds: number): void;\n\n    /** Fired when the system changes to an active, idle or locked state. The event fires with "locked" if the screen is locked or the screensaver activates, "idle" if the system is unlocked and the user has not generated any input for a specified number of seconds, and "active" when the user generates input on an idle system. */\n    export var onStateChanged: IdleStateChangedEvent;\n}\n\n////////////////////\n// Input - IME\n////////////////////\n/**\n * Use the chrome.input.ime API to implement a custom IME for Chrome OS. This allows your extension to handle keystrokes, set the composition, and manage the candidate window.\n * Permissions:  "input"\n * @since Chrome 21.\n */\ndeclare namespace chrome.input.ime {\n    /** See http://www.w3.org/TR/DOM-Level-3-Events/#events-KeyboardEvent */\n    export interface KeyboardEvent {\n        /**\n         * Optional.\n         * Whether or not the SHIFT key is pressed.\n         */\n        shiftKey?: boolean;\n        /**\n         * Optional.\n         * Whether or not the ALT key is pressed.\n         */\n        altKey?: boolean;\n        /** The ID of the request. */\n        requestId: string;\n        /** Value of the key being pressed */\n        key: string;\n        /**\n         * Optional.\n         * Whether or not the CTRL key is pressed.\n         */\n        ctrlKey?: boolean;\n        /** One of keyup or keydown. */\n        type: string;\n        /**\n         * Optional.\n         * The extension ID of the sender of this keyevent.\n         * @since Chrome 34.\n         */\n        extensionId?: string;\n        /**\n         * Optional.\n         * Value of the physical key being pressed. The value is not affected by current keyboard layout or modifier state.\n         * @since Chrome 26.\n         */\n        code: string;\n        /**\n         * Optional.\n         * The deprecated HTML keyCode, which is system- and implementation-dependent numerical code signifying the unmodified identifier associated with the key pressed.\n         * @since Chrome 37.\n         */\n        keyCode?: number;\n        /**\n         * Optional.\n         * Whether or not the CAPS_LOCK is enabled.\n         * @since Chrome 29.\n         */\n        capsLock?: boolean;\n    }\n\n    /** Describes an input Context */\n    export interface InputContext {\n        /** This is used to specify targets of text field operations. This ID becomes invalid as soon as onBlur is called. */\n        contextID: number;\n        /** Type of value this text field edits, (Text, Number, URL, etc) */\n        type: string;\n        /**\n         * Whether the text field wants auto-correct.\n         * @since Chrome 40.\n         */\n        autoCorrect: boolean;\n        /**\n         * Whether the text field wants auto-complete.\n         * @since Chrome 40.\n         */\n        autoComplete: boolean;\n        /**\n         * Whether the text field wants spell-check.\n         * @since Chrome 40.\n         */\n        spellCheck: boolean;\n    }\n\n    /**\n     * A menu item used by an input method to interact with the user from the language menu.\n     * @since Chrome 30.\n     */\n    export interface MenuItem {\n        /** String that will be passed to callbacks referencing this MenuItem. */\n        id: string;\n        /** Optional. Text displayed in the menu for this item. */\n        label?: string;\n        /** Optional. The type of menu item. */\n        style?: string;\n        /** Optional. Indicates this item is visible. */\n        visible?: boolean;\n        /** Indicates this item should be drawn with a check. */\n        checked?: boolean;\n        /** Indicates this item is enabled. */\n        enabled?: boolean;\n    }\n\n    export interface ImeParameters {\n        /** MenuItems to use. */\n        items: MenuItem[];\n        /** ID of the engine to use */\n        engineID: string;\n    }\n\n    export interface CommitTextParameters {\n        /** The text to commit */\n        text: string;\n        /** ID of the context where the text will be committed */\n        contextID: number;\n    }\n\n    export interface CandidateUsage {\n        /** The title string of details description. */\n        title: string;\n        /** The body string of detail description. */\n        body: string;\n    }\n\n    export interface CandidateTemplate {\n        /** The candidate */\n        candidate: string;\n        /** The candidate\'s id */\n        id: number;\n        /**\n         * Optional.\n         * The id to add these candidates under\n         */\n        parentId?: number;\n        /**\n         * Optional.\n         * Short string displayed to next to the candidate, often the shortcut key or index\n         */\n        label?: string;\n        /**\n         * Optional.\n         * Additional text describing the candidate\n         */\n        annotation?: string;\n        /**\n         * Optional.\n         * The usage or detail description of word.\n         */\n        usage?: CandidateUsage;\n    }\n\n    export interface CandidatesParameters {\n        /** ID of the context that owns the candidate window. */\n        contextID: number;\n        /** List of candidates to show in the candidate window */\n        candidates: CandidateTemplate[];\n    }\n\n    export interface CompositionParameterSegment {\n        /** Index of the character to start this segment at */\n        start: number;\n        /** Index of the character to end this segment after. */\n        end: number;\n        /** The type of the underline to modify this segment. */\n        style: string;\n    }\n\n    export interface CompositionParameters {\n        /** ID of the context where the composition text will be set */\n        contextID: number;\n        /** Text to set */\n        text: string;\n        /** Optional. List of segments and their associated types. */\n        segments: CompositionParameterSegment[];\n        /** Position in the text of the cursor. */\n        cursor: number;\n        /** Optional. Position in the text that the selection starts at. */\n        selectionStart?: number;\n        /** Optional. Position in the text that the selection ends at. */\n        selectionEnd?: number;\n    }\n\n    export interface MenuItemParameters {\n        items: Object[];\n        engineId: string;\n    }\n\n    export interface CandidateWindowParameterProperties {\n        /**\n         * Optional.\n         * True to show the cursor, false to hide it.\n         */\n        cursorVisible?: boolean;\n        /**\n         * Optional.\n         * True if the candidate window should be rendered vertical, false to make it horizontal.\n         */\n        vertical?: boolean;\n        /**\n         * Optional.\n         * The number of candidates to display per page.\n         */\n        pageSize?: number;\n        /**\n         * Optional.\n         * True to display the auxiliary text, false to hide it.\n         */\n        auxiliaryTextVisible?: boolean;\n        /**\n         * Optional.\n         * Text that is shown at the bottom of the candidate window.\n         */\n        auxiliaryText?: string;\n        /**\n         * Optional.\n         * True to show the Candidate window, false to hide it.\n         */\n        visible?: boolean;\n        /**\n         * Optional.\n         * Where to display the candidate window.\n         * @since Chrome 28.\n         */\n        windowPosition?: string;\n    }\n\n    export interface CandidateWindowParameter {\n        /** ID of the engine to set properties on. */\n        engineID: string;\n        properties: CandidateWindowParameterProperties;\n    }\n\n    export interface ClearCompositionParameters {\n        /** ID of the context where the composition will be cleared */\n        contextID: number;\n    }\n\n    export interface CursorPositionParameters {\n        /** ID of the candidate to select. */\n        candidateID: number;\n        /** ID of the context that owns the candidate window. */\n        contextID: number;\n    }\n\n    export interface SendKeyEventParameters {\n        /** ID of the context where the key events will be sent, or zero to send key events to non-input field. */\n        contextID: number;\n        /** Data on the key event. */\n        keyData: KeyboardEvent[];\n    }\n\n    export interface DeleteSurroundingTextParameters {\n        /** ID of the engine receiving the event. */\n        engineID: string;\n        /** ID of the context where the surrounding text will be deleted. */\n        contextID: number;\n        /** The offset from the caret position where deletion will start. This value can be negative. */\n        offset: number;\n        /** The number of characters to be deleted */\n        length: number;\n    }\n\n    export interface SurroundingTextInfo {\n        /** The text around cursor. */\n        text: string;\n        /** The ending position of the selection. This value indicates caret position if there is no selection. */\n        focus: number;\n        /** The beginning position of the selection. This value indicates caret position if is no selection. */\n        anchor: number;\n    }\n\n    export interface BlurEvent extends chrome.events.Event<(contextID: number) => void> { }\n\n    export interface CandidateClickedEvent extends chrome.events.Event<(engineID: string, candidateID: number, button: string) => void> { }\n\n    export interface KeyEventEvent extends chrome.events.Event<(engineID: string, keyData: KeyboardEvent) => void> { }\n\n    export interface DeactivatedEvent extends chrome.events.Event<(engineID: string) => void> { }\n\n    export interface InputContextUpdateEvent extends chrome.events.Event<(context: InputContext) => void> { }\n\n    export interface ActivateEvent extends chrome.events.Event<(engineID: string, screen: string) => void> { }\n\n    export interface FocusEvent extends chrome.events.Event<(context: InputContext) => void> { }\n\n    export interface MenuItemActivatedEvent extends chrome.events.Event<(engineID: string, name: string) => void> { }\n\n    export interface SurroundingTextChangedEvent extends chrome.events.Event<(engineID: string, surroundingInfo: SurroundingTextInfo) => void> { }\n\n    export interface InputResetEvent extends chrome.events.Event<(engineID: string) => void> { }\n\n    /**\n     * Adds the provided menu items to the language menu when this IME is active.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setMenuItems(parameters: ImeParameters, callback?: () => void): void;\n    /**\n     * Commits the provided text to the current input.\n     * @param callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function commitText(parameters: CommitTextParameters, callback?: (success: boolean) => void): void;\n    /**\n     * Sets the current candidate list. This fails if this extension doesn\'t own the active IME\n     * @param callback Called when the operation completes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function setCandidates(parameters: CandidatesParameters, callback?: (success: boolean) => void): void;\n    /**\n     * Set the current composition. If this extension does not own the active IME, this fails.\n     * @param callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function setComposition(parameters: CompositionParameters, callback?: (success: boolean) => void): void;\n    /**\n     * Updates the state of the MenuItems specified\n     * @param callback Called when the operation completes\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function updateMenuItems(parameters: MenuItemParameters, callback?: () => void): void;\n    /**\n     * Sets the properties of the candidate window. This fails if the extension doesn\'t own the active IME\n     * @param callback Called when the operation completes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function setCandidateWindowProperties(parameters: CandidateWindowParameter, callback?: (success: boolean) => void): void;\n    /**\n     * Clear the current composition. If this extension does not own the active IME, this fails.\n     * @param callback Called when the operation completes with a boolean indicating if the text was accepted or not. On failure, chrome.runtime.lastError is set.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function clearComposition(parameters: ClearCompositionParameters, callback?: (success: boolean) => void): void;\n    /**\n     * Set the position of the cursor in the candidate window. This is a no-op if this extension does not own the active IME.\n     * @param callback Called when the operation completes\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean success) {...};\n     */\n    export function setCursorPosition(parameters: CursorPositionParameters, callback?: (success: boolean) => void): void;\n    /**\n     * Sends the key events. This function is expected to be used by virtual keyboards. When key(s) on a virtual keyboard is pressed by a user, this function is used to propagate that event to the system.\n     * @since Chrome 33.\n     * @param callback Called when the operation completes.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function sendKeyEvents(parameters: SendKeyEventParameters, callback?: () => void): void;\n    /**\n     * Hides the input view window, which is popped up automatically by system. If the input view window is already hidden, this function will do nothing.\n     * @since Chrome 34.\n     */\n    export function hideInputView(): void;\n    /**\n     * Deletes the text around the caret.\n     * @since Chrome 27.\n     */\n    export function deleteSurroundingText(parameters: DeleteSurroundingTextParameters, callback?: () => void): void;\n    /**\n     * Indicates that the key event received by onKeyEvent is handled. This should only be called if the onKeyEvent listener is asynchronous.\n     * @since Chrome 25.\n     * @param requestId Request id of the event that was handled. This should come from keyEvent.requestId\n     * @param response True if the keystroke was handled, false if not\n     */\n    export function keyEventHandled(requestId: string, response: boolean): void;\n\n    /** This event is sent when focus leaves a text box. It is sent to all extensions that are listening to this event, and enabled by the user. */\n    export var onBlur: BlurEvent;\n    /** This event is sent if this extension owns the active IME. */\n    export var onCandidateClicked: CandidateClickedEvent;\n    /** This event is sent if this extension owns the active IME. */\n    export var onKeyEvent: KeyEventEvent;\n    /** This event is sent when an IME is deactivated. It signals that the IME will no longer be receiving onKeyPress events. */\n    export var onDeactivated: DeactivatedEvent;\n    /** This event is sent when the properties of the current InputContext change, such as the the type. It is sent to all extensions that are listening to this event, and enabled by the user. */\n    export var onInputContextUpdate: InputContextUpdateEvent;\n    /** This event is sent when an IME is activated. It signals that the IME will be receiving onKeyPress events. */\n    export var onActivate: ActivateEvent;\n    /** This event is sent when focus enters a text box. It is sent to all extensions that are listening to this event, and enabled by the user. */\n    export var onFocus: FocusEvent;\n    /** Called when the user selects a menu item */\n    export var onMenuItemActivated: MenuItemActivatedEvent;\n    /**\n     * Called when the editable string around caret is changed or when the caret position is moved. The text length is limited to 100 characters for each back and forth direction.\n     * @since Chrome 27.\n     */\n    export var onSurroundingTextChanged: SurroundingTextChangedEvent;\n    /**\n     * This event is sent when chrome terminates ongoing text input session.\n     * @since Chrome 29.\n     */\n    export var onReset: InputResetEvent;\n}\n\n////////////////////\n// Management\n////////////////////\n/**\n * The chrome.management API provides ways to manage the list of extensions/apps that are installed and running. It is particularly useful for extensions that override the built-in New Tab page.\n * Permissions:  "management"\n * @since Chrome 8.\n */\ndeclare namespace chrome.management {\n    /** Information about an installed extension, app, or theme. */\n    export interface ExtensionInfo {\n        /**\n         * Optional.\n         * A reason the item is disabled.\n         * @since Chrome 17.\n         */\n        disabledReason?: string;\n        /** Optional. The launch url (only present for apps). */\n        appLaunchUrl?: string;\n        /**\n         * The description of this extension, app, or theme.\n         * @since Chrome 9.\n         */\n        description: string;\n        /**\n         * Returns a list of API based permissions.\n         * @since Chrome 9.\n         */\n        permissions: string[];\n        /**\n         * Optional.\n         * A list of icon information. Note that this just reflects what was declared in the manifest, and the actual image at that url may be larger or smaller than what was declared, so you might consider using explicit width and height attributes on img tags referencing these images. See the manifest documentation on icons for more details.\n         */\n        icons?: IconInfo[];\n        /**\n         * Returns a list of host based permissions.\n         * @since Chrome 9.\n         */\n        hostPermissions: string[];\n        /** Whether it is currently enabled or disabled. */\n        enabled: boolean;\n        /**\n         * Optional.\n         * The URL of the homepage of this extension, app, or theme.\n         * @since Chrome 11.\n         */\n        homepageUrl?: string;\n        /**\n         * Whether this extension can be disabled or uninstalled by the user.\n         * @since Chrome 12.\n         */\n        mayDisable: boolean;\n        /**\n         * How the extension was installed.\n         * @since Chrome 22.\n         */\n        installType: string;\n        /** The version of this extension, app, or theme. */\n        version: string;\n        /** The extension\'s unique identifier. */\n        id: string;\n        /**\n         * Whether the extension, app, or theme declares that it supports offline.\n         * @since Chrome 15.\n         */\n        offlineEnabled: boolean;\n        /**\n         * Optional.\n         * The update URL of this extension, app, or theme.\n         * @since Chrome 16.\n         */\n        updateUrl?: string;\n        /**\n         * The type of this extension, app, or theme.\n         * @since Chrome 23.\n         */\n        type: string;\n        /** The url for the item\'s options page, if it has one. */\n        optionsUrl: string;\n        /** The name of this extension, app, or theme. */\n        name: string;\n        /**\n         * A short version of the name of this extension, app, or theme.\n         * @since Chrome 31.\n         */\n        shortName: string;\n        /**\n         * True if this is an app.\n         * @deprecated since Chrome 33. Please use management.ExtensionInfo.type.\n         */\n        isApp: boolean;\n        /**\n         * Optional.\n         * The app launch type (only present for apps).\n         * @since Chrome 37.\n         */\n        launchType?: string;\n        /**\n         * Optional.\n         * The currently available launch types (only present for apps).\n         * @since Chrome 37.\n         */\n        availableLaunchTypes?: string[];\n    }\n\n    /** Information about an icon belonging to an extension, app, or theme. */\n    export interface IconInfo {\n        /** The URL for this icon image. To display a grayscale version of the icon (to indicate that an extension is disabled, for example), append ?grayscale=true to the URL. */\n        url: string;\n        /** A number representing the width and height of the icon. Likely values include (but are not limited to) 128, 48, 24, and 16. */\n        size: number;\n    }\n\n    export interface UninstallOptions {\n        /**\n         * Optional.\n         * Whether or not a confirm-uninstall dialog should prompt the user. Defaults to false for self uninstalls. If an extension uninstalls another extension, this parameter is ignored and the dialog is always shown.\n         */\n        showConfirmDialog?: boolean;\n    }\n\n    export interface ManagementDisabledEvent extends chrome.events.Event<(info: ExtensionInfo) => void> { }\n\n    export interface ManagementUninstalledEvent extends chrome.events.Event<(id: string) => void> { }\n\n    export interface ManagementInstalledEvent extends chrome.events.Event<(info: ExtensionInfo) => void> { }\n\n    export interface ManagementEnabledEvent extends chrome.events.Event<(info: ExtensionInfo) => void> { }\n\n    /**\n     * Enables or disables an app or extension.\n     * @param id This should be the id from an item of management.ExtensionInfo.\n     * @param enabled Whether this item should be enabled or disabled.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setEnabled(id: string, enabled: boolean, callback?: () => void): void;\n    /**\n     * Returns a list of permission warnings for the given extension id.\n     * @since Chrome 15.\n     * @param id The ID of an already installed extension.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(array of string permissionWarnings) {...};\n     */\n    export function getPermissionWarningsById(id: string, callback?: (permissionWarnings: string[]) => void): void;\n    /**\n     * Returns information about the installed extension, app, or theme that has the given ID.\n     * @since Chrome 9.\n     * @param id The ID from an item of management.ExtensionInfo.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( ExtensionInfo result) {...};\n     */\n    export function get(id: string, callback?: (result: ExtensionInfo) => void): void;\n    /**\n     * Returns a list of information about installed extensions and apps.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(array of ExtensionInfo result) {...};\n     */\n    export function getAll(callback?: (result: ExtensionInfo[]) => void): void;\n    /**\n     * Returns a list of permission warnings for the given extension manifest string. Note: This function can be used without requesting the \'management\' permission in the manifest.\n     * @since Chrome 15.\n     * @param manifestStr Extension manifest JSON string.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(array of string permissionWarnings) {...};\n     */\n    export function getPermissionWarningsByManifest(manifestStr: string, callback?: (permissionwarnings: string[]) => void): void;\n    /**\n     * Launches an application.\n     * @param id The extension id of the application.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function launchApp(id: string, callback?: () => void): void;\n    /**\n     * Uninstalls a currently installed app or extension.\n     * @since Chrome 21.\n     * @param id This should be the id from an item of management.ExtensionInfo.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function uninstall(id: string, options?: UninstallOptions, callback?: () => void): void;\n    /**\n     * Uninstalls a currently installed app or extension.\n     * @deprecated since Chrome 21. The options parameter was added to this function.\n     * @param id This should be the id from an item of management.ExtensionInfo.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function uninstall(id: string, callback?: () => void): void;\n    /**\n     * Returns information about the calling extension, app, or theme. Note: This function can be used without requesting the \'management\' permission in the manifest.\n     * @since Chrome 39.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( ExtensionInfo result) {...};\n     */\n    export function getSelf(callback?: (result: ExtensionInfo) => void): void;\n    /**\n     * Uninstalls the calling extension.\n     * Note: This function can be used without requesting the \'management\' permission in the manifest.\n     * @since Chrome 26.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function uninstallSelf(options?: UninstallOptions, callback?: () => void): void;\n    /**\n     * Uninstalls the calling extension.\n     * Note: This function can be used without requesting the \'management\' permission in the manifest.\n     * @since Chrome 26.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function uninstallSelf(callback?: () => void): void;\n    /**\n     * Display options to create shortcuts for an app. On Mac, only packaged app shortcuts can be created.\n     * @since Chrome 37.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function createAppShortcut(id: string, callback?: () => void): void;\n    /**\n     * Set the launch type of an app.\n     * @since Chrome 37.\n     * @param id This should be the id from an app item of management.ExtensionInfo.\n     * @param launchType The target launch type. Always check and make sure this launch type is in ExtensionInfo.availableLaunchTypes, because the available launch types vary on different platforms and configurations.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setLaunchType(id: string, launchType: string, callback?: () => void): void;\n    /**\n     * Generate an app for a URL. Returns the generated bookmark app.\n     * @since Chrome 37.\n     * @param url The URL of a web page. The scheme of the URL can only be "http" or "https".\n     * @param title The title of the generated app.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function( ExtensionInfo result) {...};\n     */\n    export function generateAppForLink(url: string, title: string, callback?: (result: ExtensionInfo) => void): void;\n\n    /** Fired when an app or extension has been disabled. */\n    export var onDisabled: ManagementDisabledEvent;\n    /** Fired when an app or extension has been uninstalled. */\n    export var onUninstalled: ManagementUninstalledEvent;\n    /** Fired when an app or extension has been installed. */\n    export var onInstalled: ManagementInstalledEvent;\n    /** Fired when an app or extension has been enabled. */\n    export var onEnabled: ManagementEnabledEvent;\n}\n\n////////////////////\n// Notifications\n////////////////////\n/**\n * Use the networking.config API to authenticate to captive portals.\n * Permissions:  "networking.config"\n * Important: This API works only on Chrome OS.\n * @since Chrome 43.\n */\ndeclare namespace chrome.networking.config {\n    export interface NetworkInfo {\n        /** Currently only WiFi supported. */\n        Type: string;\n        /** Optional. A unique identifier of the network. */\n        GUID?: string;\n        /** Optional. A hex-encoded byte sequence. */\n        HexSSID?: string;\n        /** Optional. The decoded SSID of the network (default encoding is UTF-8). To filter for non-UTF-8 SSIDs, use HexSSID instead. */\n        SSID?: string;\n        /** Optional. The basic service set identification (BSSID) uniquely identifying the basic service set. BSSID is represented as a human readable, hex-encoded string with bytes separated by colons, e.g. 45:67:89:ab:cd:ef. */\n        BSSID?: string;\n        /** Optional. Identifier indicating the security type of the network. Valid values are None, WEP-PSK, WPA-PSK and WPA-EAP. */\n        Security?: string;\n    }\n\n    export interface CaptivePorttalDetectedEvent extends chrome.events.Event<(networkInfo: NetworkInfo) => void> { }\n\n    /**\n     * Allows an extension to define network filters for the networks it can handle. A call to this function will remove all filters previously installed by the extension before setting the new list.\n     * @param networks Network filters to set. Every NetworkInfo must either have the SSID or HexSSID set. Other fields will be ignored.\n     * @param callback Called back when this operation is finished.\n     * The callback parameter should be a function that looks like this:\n     * function() {...};\n     */\n    export function setNetworkFilter(networks: NetworkInfo[], callback: () => void): void;\n    /**\n     * Called by the extension to notify the network config API that it finished a captive portal authentication attempt and hand over the result of the attempt. This function must only be called with the GUID of the latest onCaptivePortalDetected event.\n     * @param GUID Unique network identifier obtained from onCaptivePortalDetected.\n     * @param result The result of the authentication attempt.\n     * unhandled: The extension does not handle this network or captive portal (e.g. server end-point not found or not compatible).\n     * succeeded: The extension handled this network and authenticated successfully.\n     * rejected: The extension handled this network, tried to authenticate, however was rejected by the server.\n     * failed: The extension handled this network, tried to authenticate, however failed due to an unspecified error.\n     * @param callback Called back when this operation is finished.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function finishAuthentication(GUID: string, result: string, callback?: () => void): void;\n\n    /** This event fires everytime a captive portal is detected on a network matching any of the currently registered network filters and the user consents to use the extension for authentication. Network filters may be set using the setNetworkFilter. Upon receiving this event the extension should start its authentication attempt with the captive portal. When the extension finishes its attempt, it must call finishAuthentication with the GUID received with this event and the appropriate authentication result. */\n    export var onCaptivePortalDetected: CaptivePorttalDetectedEvent;\n}\n\n////////////////////\n// Notifications\n// https://developer.chrome.com/extensions/notifications\n////////////////////\n/**\n * Use the chrome.notifications API to create rich notifications using templates and show these notifications to users in the system tray.\n * Permissions:  "notifications"\n * @since Chrome 28.\n */\ndeclare namespace chrome.notifications {\n    export interface ButtonOptions {\n        title: string;\n        iconUrl?: string;\n    }\n\n    export interface ItemOptions {\n        /** Title of one item of a list notification. */\n        title: string;\n        /** Additional details about this item. */\n        message: string;\n    }\n\n    export interface NotificationOptions {\n        /** Optional. Which type of notification to display. Required for notifications.create method. */\n        type?: string;\n        /**\n         * Optional.\n         * A URL to the sender\'s avatar, app icon, or a thumbnail for image notifications.\n         * URLs can be a data URL, a blob URL, or a URL relative to a resource within this extension\'s .crx file Required for notifications.create method.\n         */\n        iconUrl?: string;\n        /** Optional. Title of the notification (e.g. sender name for email). Required for notifications.create method. */\n        title?: string;\n        /** Optional. Main notification content. Required for notifications.create method. */\n        message?: string;\n        /**\n         * Optional.\n         * Alternate notification content with a lower-weight font.\n         * @since Chrome 31.\n         */\n        contextMessage?: string;\n        /** Optional. Priority ranges from -2 to 2. -2 is lowest priority. 2 is highest. Zero is default. */\n        priority?: number;\n        /** Optional. A timestamp associated with the notification, in milliseconds past the epoch (e.g. Date.now() + n). */\n        eventTime?: number;\n        /** Optional. Text and icons for up to two notification action buttons. */\n        buttons?: ButtonOptions[];\n        /** Optional. Items for multi-item notifications. */\n        items?: ItemOptions[];\n        /**\n         * Optional.\n         * Current progress ranges from 0 to 100.\n         * @since Chrome 30.\n         */\n        progress?: number;\n        /**\n         * Optional.\n         * Whether to show UI indicating that the app will visibly respond to clicks on the body of a notification.\n         * @since Chrome 32.\n         */\n        isClickable?: boolean;\n        /**\n         * Optional.\n         * A URL to the app icon mask. URLs have the same restrictions as iconUrl. The app icon mask should be in alpha channel, as only the alpha channel of the image will be considered.\n         * @since Chrome 38.\n         */\n        appIconMaskUrl?: string;\n        /** Optional. A URL to the image thumbnail for image-type notifications. URLs have the same restrictions as iconUrl. */\n        imageUrl?: string;\n        /**\n         * Indicates that the notification should remain visible on screen until the user activates or dismisses the notification.\n         * This defaults to false.\n         * @since Chrome 50\n         */\n        requireInteraction?: boolean;\n    }\n\n    export interface NotificationClosedEvent extends chrome.events.Event<(notificationId: string, byUser: boolean) => void> { }\n\n    export interface NotificationClickedEvent extends chrome.events.Event<(notificationId: string) => void> { }\n\n    export interface NotificationButtonClickedEvent extends chrome.events.Event<(notificationId: string, buttonIndex: number) => void> { }\n\n    export interface NotificationPermissionLevelChangedEvent extends chrome.events.Event<(level: string) => void> { }\n\n    export interface NotificationShowSettingsEvent extends chrome.events.Event<() => void> { }\n\n    /** The notification closed, either by the system or by user action. */\n    export var onClosed: NotificationClosedEvent;\n    /** The user clicked in a non-button area of the notification. */\n    export var onClicked: NotificationClickedEvent;\n    /** The user pressed a button in the notification. */\n    export var onButtonClicked: NotificationButtonClickedEvent;\n    /**\n     * The user changes the permission level.\n     * @since Chrome 32.\n     */\n    export var onPermissionLevelChanged: NotificationPermissionLevelChangedEvent;\n    /**\n     * The user clicked on a link for the app\'s notification settings.\n     * @since Chrome 32.\n     */\n    export var onShowSettings: NotificationShowSettingsEvent;\n\n    /**\n     * Creates and displays a notification.\n     * @param notificationId Identifier of the notification. If not set or empty, an ID will automatically be generated. If it matches an existing notification, this method first clears that notification before proceeding with the create operation.\n     * The notificationId parameter is required before Chrome 42.\n     * @param options Contents of the notification.\n     * @param callback Returns the notification id (either supplied or generated) that represents the created notification.\n     * The callback is required before Chrome 42.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(string notificationId) {...};\n     */\n    export function create(notificationId: string, options: NotificationOptions, callback?: (notificationId: string) => void): void;\n    /**\n     * Creates and displays a notification.\n     * @param notificationId Identifier of the notification. If not set or empty, an ID will automatically be generated. If it matches an existing notification, this method first clears that notification before proceeding with the create operation.\n     * The notificationId parameter is required before Chrome 42.\n     * @param options Contents of the notification.\n     * @param callback Returns the notification id (either supplied or generated) that represents the created notification.\n     * The callback is required before Chrome 42.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(string notificationId) {...};\n     */\n    export function create(options: NotificationOptions, callback?: (notificationId: string) => void): void;\n    /**\n     * Updates an existing notification.\n     * @param notificationId The id of the notification to be updated. This is returned by notifications.create method.\n     * @param options Contents of the notification to update to.\n     * @param callback Called to indicate whether a matching notification existed.\n     * The callback is required before Chrome 42.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean wasUpdated) {...};\n     */\n    export function update(notificationId: string, options: NotificationOptions, callback?: (wasUpdated: boolean) => void): void;\n    /**\n     * Clears the specified notification.\n     * @param notificationId The id of the notification to be cleared. This is returned by notifications.create method.\n     * @param callback Called to indicate whether a matching notification existed.\n     * The callback is required before Chrome 42.\n     * If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean wasCleared) {...};\n     */\n    export function clear(notificationId: string, callback?: (wasCleared: boolean) => void): void;\n    /**\n     * Retrieves all the notifications.\n     * @since Chrome 29.\n     * @param callback Returns the set of notification_ids currently in the system.\n     * The callback parameter should be a function that looks like this:\n     * function(object notifications) {...};\n     */\n    export function getAll(callback: (notifications: Object) => void): void;\n    /**\n     * Retrieves whether the user has enabled notifications from this app or extension.\n     * @since Chrome 32.\n     * @param callback Returns the current permission level.\n     * The callback parameter should be a function that looks like this:\n     * function( PermissionLevel level) {...};\n     */\n    export function getPermissionLevel(callback: (level: string) => void): void;\n}\n\n////////////////////\n// Omnibox\n////////////////////\n/**\n * The omnibox API allows you to register a keyword with Google Chrome\'s address bar, which is also known as the omnibox.\n * Manifest:  "omnibox": {...}\n * @since Chrome 9.\n */\ndeclare namespace chrome.omnibox {\n    /** A suggest result. */\n    export interface SuggestResult {\n        /** The text that is put into the URL bar, and that is sent to the extension when the user chooses this entry. */\n        content: string;\n        /** The text that is displayed in the URL dropdown. Can contain XML-style markup for styling. The supported tags are \'url\' (for a literal URL), \'match\' (for highlighting text that matched what the user\'s query), and \'dim\' (for dim helper text). The styles can be nested, eg. dimmed match. You must escape the five predefined entities to display them as text: stackoverflow.com/a/1091953/89484 */\n        description: string;\n    }\n\n    export interface Suggestion {\n        /** The text that is displayed in the URL dropdown. Can contain XML-style markup for styling. The supported tags are \'url\' (for a literal URL), \'match\' (for highlighting text that matched what the user\'s query), and \'dim\' (for dim helper text). The styles can be nested, eg. dimmed match. */\n        description: string;\n    }\n\n    export interface OmniboxInputEnteredEvent extends chrome.events.Event<(text: string) => void> { }\n\n    export interface OmniboxInputChangedEvent extends chrome.events.Event<(text: string, suggest: (suggestResults: SuggestResult[]) => void) => void> { }\n\n    export interface OmniboxInputStartedEvent extends chrome.events.Event<() => void> { }\n\n    export interface OmniboxInputCancelledEvent extends chrome.events.Event<() => void> { }\n\n    /**\n     * Sets the description and styling for the default suggestion. The default suggestion is the text that is displayed in the first suggestion row underneath the URL bar.\n     * @param suggestion A partial SuggestResult object, without the \'content\' parameter.\n     */\n    export function setDefaultSuggestion(suggestion: Suggestion): void;\n\n    /** User has accepted what is typed into the omnibox. */\n    export var onInputEntered: OmniboxInputEnteredEvent;\n    /** User has changed what is typed into the omnibox. */\n    export var onInputChanged: OmniboxInputChangedEvent;\n    /** User has started a keyword input session by typing the extension\'s keyword. This is guaranteed to be sent exactly once per input session, and before any onInputChanged events. */\n    export var onInputStarted: OmniboxInputStartedEvent;\n    /** User has ended the keyword input session without accepting the input. */\n    export var onInputCancelled: OmniboxInputCancelledEvent;\n}\n\n////////////////////\n// Page Action\n////////////////////\n/**\n * Use the chrome.pageAction API to put icons inside the address bar. Page actions represent actions that can be taken on the current page, but that aren\'t applicable to all pages.\n * Manifest:  "page_action": {...}\n * @since Chrome 5.\n */\ndeclare namespace chrome.pageAction {\n    export interface PageActionClickedEvent extends chrome.events.Event<(tab: chrome.tabs.Tab) => void> { }\n\n    export interface TitleDetails {\n        /** The id of the tab for which you want to modify the page action. */\n        tabId: number;\n        /** The tooltip string. */\n        title: string;\n    }\n\n    export interface GetDetails {\n        /** Specify the tab to get the title from. */\n        tabId: number;\n    }\n\n    export interface PopupDetails {\n        /** The id of the tab for which you want to modify the page action. */\n        tabId: number;\n        /** The html file to show in a popup. If set to the empty string (\'\'), no popup is shown. */\n        popup: string;\n    }\n\n    export interface IconDetails {\n        /** The id of the tab for which you want to modify the page action. */\n        tabId: number;\n        /**\n         * Optional.\n         * @deprecated This argument is ignored.\n         */\n        iconIndex?: number;\n        /**\n         * Optional.\n         * Either an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen\'s pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * 19 will be selected. Initially only scales 1 and 2 will be supported. At least one image must be specified. Note that \'details.imageData = foo\' is equivalent to \'details.imageData = {\'19\': foo}\'\n         */\n        imageData?: ImageData | { [index: number]: ImageData };\n        /**\n         * Optional.\n         * Either a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen\'s pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * 19 will be selected. Initially only scales 1 and 2 will be supported. At least one image must be specified. Note that \'details.path = foo\' is equivalent to \'details.imageData = {\'19\': foo}\'\n         */\n        path?: any;\n    }\n\n    /**\n     * Shows the page action. The page action is shown whenever the tab is selected.\n     * @param tabId The id of the tab for which you want to modify the page action.\n     */\n    export function hide(tabId: number, callback?: () => void): void;\n    /**\n     * Shows the page action. The page action is shown whenever the tab is selected.\n     * @param tabId The id of the tab for which you want to modify the page action.\n     */\n    export function show(tabId: number, callback?: () => void): void;\n    /** Sets the title of the page action. This is displayed in a tooltip over the page action. */\n    export function setTitle(details: TitleDetails): void;\n    /** Sets the html document to be opened as a popup when the user clicks on the page action\'s icon. */\n    export function setPopup(details: PopupDetails): void;\n    /**\n     * Gets the title of the page action.\n     * @since Chrome 19.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string result) {...};\n     */\n    export function getTitle(details: GetDetails, callback: (result: string) => void): void;\n    /**\n     * Gets the html document set as the popup for this page action.\n     * @since Chrome 19.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(string result) {...};\n     */\n    export function getPopup(details: GetDetails, callback: (result: string) => void): void;\n    /**\n     * Sets the icon for the page action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function() {...};\n     */\n    export function setIcon(details: IconDetails, callback?: () => void): void;\n\n    /** Fired when a page action icon is clicked. This event will not fire if the page action has a popup. */\n    export var onClicked: PageActionClickedEvent;\n}\n\n////////////////////\n// Page Capture\n////////////////////\n/**\n * Use the chrome.pageCapture API to save a tab as MHTML.\n * Permissions:  "pageCapture"\n * @since Chrome 18.\n */\ndeclare namespace chrome.pageCapture {\n    export interface SaveDetails {\n        /** The id of the tab to save as MHTML. */\n        tabId: number;\n    }\n\n    /**\n     * Saves the content of the tab with given id as MHTML.\n     * @param callback Called when the MHTML has been generated.\n     * The callback parameter should be a function that looks like this:\n     * function(binary mhtmlData) {...};\n     * Parameter mhtmlData: The MHTML data as a Blob.\n     */\n    export function saveAsMHTML(details: SaveDetails, callback: (mhtmlData: any) => void): void;\n}\n\n////////////////////\n// Permissions\n////////////////////\n/**\n * Use the chrome.permissions API to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary.\n * @since Chrome 16.\n */\ndeclare namespace chrome.permissions {\n    export interface Permissions {\n        /**\n         * Optional.\n         * List of named permissions (does not include hosts or origins). Anything listed here must appear in the optional_permissions list in the manifest.\n         */\n        origins?: string[];\n        /**\n         * Optional.\n         * List of origin permissions. Anything listed here must be a subset of a host that appears in the optional_permissions list in the manifest. For example, if http://*.example.com/ or http://* appears in optional_permissions, you can request an origin of http://help.example.com/. Any path is ignored.\n         */\n        permissions?: string[];\n    }\n\n    export interface PermissionsRemovedEvent {\n        /**\n         * @param callback The callback parameter should be a function that looks like this:\n         * function( Permissions permissions) {...};\n         * Parameter permissions: The permissions that have been removed.\n         */\n        addListener(callback: (permissions: Permissions) => void): void;\n    }\n\n    export interface PermissionsAddedEvent {\n        /**\n         * @param callback The callback parameter should be a function that looks like this:\n         * function( Permissions permissions) {...};\n         * Parameter permissions: The newly acquired permissions.\n         */\n        addListener(callback: (permissions: Permissions) => void): void;\n    }\n\n    /**\n     * Checks if the extension has the specified permissions.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(boolean result) {...};\n     * Parameter result: True if the extension has the specified permissions.\n     */\n    export function contains(permissions: Permissions, callback: (result: boolean) => void): void;\n    /**\n     * Gets the extension\'s current set of permissions.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function( Permissions permissions) {...};\n     * Parameter permissions: The extension\'s active permissions.\n     */\n    export function getAll(callback: (permissions: Permissions) => void): void;\n    /**\n     * Requests access to the specified permissions. These permissions must be defined in the optional_permissions field of the manifest. If there are any problems requesting the permissions, runtime.lastError will be set.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean granted) {...};\n     * Parameter granted: True if the user granted the specified permissions.\n     */\n    export function request(permissions: Permissions, callback?: (granted: boolean) => void): void;\n    /**\n     * Removes access to the specified permissions. If there are any problems removing the permissions, runtime.lastError will be set.\n     * @param callback If you specify the callback parameter, it should be a function that looks like this:\n     * function(boolean removed) {...};\n     * Parameter removed: True if the permissions were removed.\n     */\n    export function remove(permissions: Permissions, callback?: (removed: boolean) => void): void;\n\n    /** Fired when access to permissions has been removed from the extension. */\n    export var onRemoved: PermissionsRemovedEvent;\n    /** Fired when the extension acquires new permissions. */\n    export var onAdded: PermissionsAddedEvent;\n}\n\n////////////////////\n// Platform Keys\n////////////////////\n/**\n * Use the chrome.platformKeys API to access client certificates managed by the platform. If the user or policy grants the permission, an extension can use such a certficate in its custom authentication protocol. E.g. this allows usage of platform managed certificates in third party VPNs (see chrome.vpnProvider).\n * Permissions:  "platformKeys"\n * Important: This API works only on Chrome OS.\n * @since Chrome 45.\n */\ndeclare namespace chrome.platformKeys {\n    export interface Match {\n        /** The DER encoding of a X.509 certificate. */\n        certificate: ArrayBuffer;\n        /** The  KeyAlgorithm of the certified key. This contains algorithm parameters that are inherent to the key of the certificate (e.g. the key length). Other parameters like the hash function used by the sign function are not included. */\n        keyAlgorithm: KeyAlgorithm;\n    }\n\n    export interface ClientCertificateSelectRequestDetails {\n        /** This field is a list of the types of certificates requested, sorted in order of the server\'s preference. Only certificates of a type contained in this list will be retrieved. If certificateTypes is the empty list, however, certificates of any type will be returned. */\n        certificateTypes: string[];\n        /** List of distinguished names of certificate authorities allowed by the server. Each entry must be a DER-encoded X.509 DistinguishedName. */\n        certificateAuthorities: ArrayBuffer[];\n    }\n\n    export interface ClientCertificateSelectDetails {\n        /** Only certificates that match this request will be returned. */\n        request: ClientCertificateSelectRequestDetails;\n        /**\n         * Optional.\n         * If given, the selectClientCertificates operates on this list. Otherwise, obtains the list of all certificates from the platform\'s certificate stores that are available to this extensions. Entries that the extension doesn\'t have permission for or which doesn\'t match the request, are removed.\n         */\n        clientCerts?: ArrayBuffer[];\n        /** If true, the filtered list is presented to the user to manually select a certificate and thereby granting the extension access to the certificate(s) and key(s). Only the selected certificate(s) will be returned. If is false, the list is reduced to all certificates that the extension has been granted access to (automatically or manually). */\n        interactive: boolean;\n    }\n\n    export interface ServerCertificateVerificationDetails {\n        /** Each chain entry must be the DER encoding of a X.509 certificate, the first entry must be the server certificate and each entry must certify the entry preceding it. */\n        serverCertificateChain: ArrayBuffer[];\n        /** The hostname of the server to verify the certificate for, e.g. the server that presented the serverCertificateChain. */\n        hostname: string;\n    }\n\n    export interface ServerCertificateVerificationResult {\n        /** The result of the trust verification: true if trust for the given verification details could be established and false if trust is rejected for any reason. */\n        trusted: boolean;\n        /**\n         * If the trust verification failed, this array contains the errors reported by the underlying network layer. Otherwise, this array is empty.\n         * Note: This list is meant for debugging only and may not contain all relevant errors. The errors returned may change in future revisions of this API, and are not guaranteed to be forwards or backwards compatible.\n         */\n        debug_errors: string[];\n    }\n\n    /**\n     * This function filters from a list of client certificates the ones that are known to the platform, match request and for which the extension has permission to access the certificate and its private key. If interactive is true, the user is presented a dialog where he can select from matching certificates and grant the extension access to the certificate. The selected/filtered client certificates will be passed to callback.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(array of Match matches) {...};\n     * Parameter matches: The list of certificates that match the request, that the extension has permission for and, if interactive is true, that were selected by the user.\n     */\n    export function selectClientCertificates(details: ClientCertificateSelectDetails, callback: (matches: Match[]) => void): void;\n    /**\n     * Passes the key pair of certificate for usage with platformKeys.subtleCrypto to callback.\n     * @param certificate The certificate of a Match returned by selectClientCertificates.\n     * @param parameters Determines signature/hash algorithm parameters additionally to the parameters fixed by the key itself. The same parameters are   accepted as by WebCrypto\'s importKey function, e.g. RsaHashedImportParams for a RSASSA-PKCS1-v1_5 key. For RSASSA-PKCS1-v1_5 keys, additionally the parameters { \'hash\': { \'name\': \'none\' } } are supported. The sign function will then apply PKCS#1 v1.5 padding and but not hash the given data.\n     * @param callback The public and private CryptoKey of a certificate which can only be used with platformKeys.subtleCrypto.\n     * The callback parameter should be a function that looks like this:\n     * function(object publicKey, object privateKey) {...};\n     * Optional parameter privateKey: Might be null if this extension does not have access to it.\n     */\n    export function getKeyPair(certificate: ArrayBuffer, parameters: Object, callback: (publicKey: CryptoKey, privateKey: CryptoKey | null) => void): void;\n    /** An implementation of WebCrypto\'s  SubtleCrypto that allows crypto operations on keys of client certificates that are available to this extension. */\n    export function subtleCrypto(): SubtleCrypto;\n    /**\n     * Checks whether details.serverCertificateChain can be trusted for details.hostname according to the trust settings of the platform. Note: The actual behavior of the trust verification is not fully specified and might change in the future. The API implementation verifies certificate expiration, validates the certification path and checks trust by a known CA. The implementation is supposed to respect the EKU serverAuth and to support subject alternative names.\n     * @param callback The callback parameter should be a function that looks like this:\n     * function(object result) {...};\n     */\n    export function verifyTLSServerCertificate(details: ServerCertificateVerificationDetails, callback: (result: ServerCertificateVerificationResult) => void): void;\n}\n\n////////////////////\n// Power\n////////////////////\n/**\n * Use the chrome.power API to override the system\'s power management features.\n * Permissions:  "power"\n * @since Chrome 27.\n */\ndeclare namespace chrome.power {\n    /** Requests that power management be temporarily disabled. |level| describes the degree to which power management should be disabled. If a request previously made by the same app is still active, it will be replaced by the new request. */\n    export function requestKeepAwake(level: string): void;\n    /** Releases a request previously made via requestKeepAwake(). */\n    export function releaseKeepAwake(): void;\n}\n\n////////////////////\n// Printer Provider\n////////////////////\n/**\n * The chrome.printerProvider API exposes events used by print manager to query printers controlled by extensions, to query their capabilities and to submit print jobs to these printers.\n * Permissions:  "printerProvider"\n * @since Chrome 44.\n */\ndeclare namespace chrome.printerProvider {\n    export interface PrinterInfo {\n        /** Unique printer ID. */\n        id: string;\n        /** Printer\'s human readable name. */\n        name: string;\n        /** Optional. Printer\'s human readable description. */\n        description?: string;\n    }\n\n    export interface PrinterCapabilities {\n        /** Device capabilities in CDD format. */\n        capabilities: any;\n    }\n\n    export interface PrintJob {\n        /** ID of the printer which should handle the job. */\n        printerId: string;\n        /** The print job title. */\n        title: string;\n        /** Print ticket in  CJT format. */\n        ticket: Object;\n        /** The document content type. Supported formats are "application/pdf" and "image/pwg-raster". */\n        contentType: string;\n        /** Blob containing the document data to print. Format must match |contentType|. */\n        document: Blob;\n    }\n\n    export interface PrinterRequestedEvent extends chrome.events.Event<(resultCallback: (printerInfo: PrinterInfo[]) => void) => void> { }\n\n    export interface PrinterInfoRequestedEvent extends chrome.events.Event<(device: any, resultCallback: (printerInfo?: PrinterInfo) => void) => void> { }\n\n    export interface CapabilityRequestedEvent extends chrome.events.Event<(printerId: string, resultCallback: (capabilities: PrinterCapabilities) => void) => void> { }\n\n    export interface PrintRequestedEvent extends chrome.events.Event<(printJob: PrintJob, resultCallback: (result: string) => void) => void> { }\n\n    /** Event fired when print manager requests printers provided by extensions. */\n    export var onGetPrintersRequested: PrinterRequestedEvent;\n    /**\n     * Event fired when print manager requests information about a USB device that may be a printer.\n     * Note: An application should not rely on this event being fired more than once per device. If a connected device is supported it should be returned in the onGetPrintersRequested event.\n     * @since Chrome 45.\n     */\n    export var onGetUsbPrinterInfoRequested: PrinterInfoRequestedEvent;\n    /** Event fired when print manager requests printer capabilities. */\n    export var onGetCapabilityRequested: CapabilityRequestedEvent;\n    /** Event fired when print manager requests printing. */\n    export var onPrintRequested: PrintRequestedEvent;\n}\n\n////////////////////\n// Privacy\n////////////////////\n/**\n * Use the chrome.privacy API to control usage of the features in Chrome that can affect a user\'s privacy. This API relies on the ChromeSetting prototype of the type API for getting and setting Chrome\'s configuration.\n * Permissions:  "privacy"\n * The Chrome Privacy Whitepaper gives background detail regarding the features which this API can control.\n * @since Chrome 18.\n */\ndeclare namespace chrome.privacy {\n    export interface Services {\n        /** since Chrome 20. */\n        spellingServiceEnabled: chrome.types.ChromeSetting;\n        searchSuggestEnabled: chrome.types.ChromeSetting;\n        instantEnabled: chrome.types.ChromeSetting;\n        alternateErrorPagesEnabled: chrome.types.ChromeSetting;\n        safeBrowsingEnabled: chrome.types.ChromeSetting;\n        autofillEnabled: chrome.types.ChromeSetting;\n        translationServiceEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 38. */\n        passwordSavingEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 42. */\n        hotwordSearchEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 42. */\n        safeBrowsingExtendedReportingEnabled: chrome.types.ChromeSetting;\n    }\n\n    export interface Network {\n        networkPredictionEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 42. */\n        webRTCMultipleRoutesEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 47. Warning: this is the current Dev channel. */\n        webRTCNonProxiedUdpEnabled: chrome.types.ChromeSetting;\n    }\n\n    export interface Websites {\n        thirdPartyCookiesAllowed: chrome.types.ChromeSetting;\n        referrersEnabled: chrome.types.ChromeSetting;\n        hyperlinkAuditingEnabled: chrome.types.ChromeSetting;\n        /** @since Chrome 21. */\n        protectedContentEnabled: chrome.types.ChromeSetting;\n    }\n\n    /** Settings that enable or disable features that require third-party network services provided by Google and your default search provider. */\n    export var services: Services;\n    /** Settings that influence Chrome\'s handling of network connections in general. */\n    export var network: Network;\n    /** Settings that determine what information Chrome makes available to websites. */\n    export var websites: Websites;\n}\n\n////////////////////\n// Proxy\n////////////////////\n/**\n * Use the chrome.proxy API to manage Chrome\'s proxy settings. This API relies on the ChromeSetting prototype of the type API for getting and setting the proxy configuration.\n * Permissions:  "proxy"\n * @since Chrome 13.\n */\ndeclare namespace chrome.proxy {\n    /** An object holding proxy auto-config information. Exactly one of the fields should be non-empty. */\n    export interface PacScript {\n        /** Optional. URL of the PAC file to be used. */\n        url?: string;\n        /** Optional. If true, an invalid PAC script will prevent the network stack from falling back to direct connections. Defaults to false. */\n        mandatory?: boolean;\n        /** Optional. A PAC script. */\n        data?: string;\n    }\n\n    /** An object encapsulating a complete proxy configuration. */\n    export interface ProxyConfig {\n        /** Optional. The proxy rules describing this configuration. Use this for \'fixed_servers\' mode. */\n        rules?: ProxyRules;\n        /** Optional. The proxy auto-config (PAC) script for this configuration. Use this for \'pac_script\' mode. */\n        pacScript?: PacScript;\n        /**\n         * \'direct\' = Never use a proxy\n         * \'auto_detect\' = Auto detect proxy settings\n         * \'pac_script\' = Use specified PAC script\n         * \'fixed_servers\' = Manually specify proxy servers\n         * \'system\' = Use system proxy settings\n         */\n        mode: string;\n    }\n\n    /** An object encapsulating a single proxy server\'s specification. */\n    export interface ProxyServer {\n        /** The URI of the proxy server. This must be an ASCII hostname (in Punycode format). IDNA is not supported, yet. */\n        host: string;\n        /** Optional. The scheme (protocol) of the proxy server itself. Defaults to \'http\'. */\n        scheme?: string;\n        /** Optional. The port of the proxy server. Defaults to a port that depends on the scheme. */\n        port?: number;\n    }\n\n    /** An object encapsulating the set of proxy rules for all protocols. Use either \'singleProxy\' or (a subset of) \'proxyForHttp\', \'proxyForHttps\', \'proxyForFtp\' and \'fallbackProxy\'. */\n    export interface ProxyRules {\n        /** Optional. The proxy server to be used for FTP requests. */\n        proxyForFtp?: ProxyServer;\n        /** Optional. The proxy server to be used for HTTP requests. */\n        proxyForHttp?: ProxyServer;\n        /** Optional. The proxy server to be used for everthing else or if any of the specific proxyFor... is not specified. */\n        fallbackProxy?: ProxyServer;\n        /** Optional. The proxy server to be used for all per-URL requests (that is http, https, and ftp). */\n        singleProxy?: ProxyServer;\n        /** Optional. The proxy server to be used for HTTPS requests. */\n        proxyForHttps?: ProxyServer;\n        /** Optional. List of servers to connect to without a proxy server. */\n        bypassList?: string[];\n    }\n\n    export interface ErrorDetails {\n        /** Additional details about the error such as a JavaScript runtime error. */\n        details: string;\n        /** The error description. */\n        error: string;\n        /** If true, the error was fatal and the network transaction was aborted. Otherwise, a direct connection is used instead. */\n        fatal: boolean;\n    }\n\n    export interface ProxyErrorEvent extends chrome.events.Event<(details: ErrorDetails) => void> { }\n\n    export var settings: chrome.types.ChromeSetting;\n    /** Notifies about proxy errors. */\n    export var onProxyError: ProxyErrorEvent;\n}\n\n////////////////////\n// Runtime\n////////////////////\n/**\n * Use the chrome.runtime API to retrieve the background page, return details about the manifest, and listen for and respond to events in the app or extension lifecycle. You can also use this API to convert the relative path of URLs to fully-qualified URLs.\n * @since Chrome 22\n */\ndeclare namespace chrome.runtime {\n    /** This will be defined during an API method callback if there was an error */\n    export var lastError: LastError | undefined;\n    /** The ID of the extension/app. */\n    export var id: string;\n\n    export interface LastError {\n        /** Optional. Details about the error which occurred.  */\n        message?: string;\n    }\n\n    export interface ConnectInfo {\n        name?: string;\n        includeTlsChannelId?: boolean;\n    }\n\n    export interface InstalledDetails {\n        /**\n         * The reason that this event is being dispatched.\n         * One of: "install", "update", "chrome_update", or "shared_module_update"\n         */\n        reason: string;\n        /**\n         * Optional.\n         * Indicates the previous version of the extension, which has just been updated. This is present only if \'reason\' is \'update\'.\n         */\n        previousVersion?: string;\n        /**\n         * Optional.\n         * Indicates the ID of the imported shared module extension which updated. This is present only if \'reason\' is \'shared_module_update\'.\n         * @since Chrome 29.\n         */\n        id?: string;\n    }\n\n    export interface MessageOptions {\n        /** Whether the TLS channel ID will be passed into onMessageExternal for processes that are listening for the connection event. */\n        includeTlsChannelId?: boolean;\n    }\n\n    /**\n     * An object containing information about the script context that sent a message or request.\n     * @since Chrome 26.\n     */\n    export interface MessageSender {\n        /** The ID of the extension or app that opened the connection, if any. */\n        id?: string;\n        /** The tabs.Tab which opened the connection, if any. This property will only be present when the connection was opened from a tab (including content scripts), and only if the receiver is an extension, not an app. */\n        tab?: chrome.tabs.Tab;\n        /**\n         * The frame that opened the connection. 0 for top-level frames, positive for child frames. This will only be set when tab is set.\n         * @since Chrome 41.\n         */\n        frameId?: number;\n        /**\n         * The URL of the page or frame that opened the connection. If the sender is in an iframe, it will be iframe\'s URL not the URL of the page which hosts it.\n         * @since Chrome 28.\n         */\n        url?: string;\n        /**\n         * The TLS channel ID of the page or frame that opened the connection, if requested by the extension or app, and if available.\n         * @since Chrome 32.\n         */\n        tlsChannelId?: string;\n    }\n\n    /**\n     * An object containing information about the current platform.\n     * @since Chrome 36.\n     */\n    export interface PlatformInfo {\n        /**\n         * The operating system chrome is running on.\n         * One of: "mac", "win", "android", "cros", "linux", or "openbsd"\n         */\n        os: string;\n        /**\n         * The machine\'s processor architecture.\n         * One of: "arm", "x86-32", or "x86-64"\n         */\n        arch: string;\n        /**\n         * The native client architecture. This may be different from arch on some platforms.\n         * One of: "arm", "x86-32", or "x86-64"\n         */\n        nacl_arch: string;\n    }\n\n    /**\n     * An object which allows two way communication with other pages.\n     * @since Chrome 26.\n     */\n    export interface Port {\n        postMessage: (message: Object) => void;\n        disconnect: () => void;\n        /**\n         * Optional.\n         * This property will only be present on ports passed to onConnect/onConnectExternal listeners.\n         */\n        sender?: MessageSender;\n        /** An object which allows the addition and removal of listeners for a Chrome event. */\n        onDisconnect: PortDisconnectEvent;\n        /** An object which allows the addition and removal of listeners for a Chrome event. */\n        onMessage: PortMessageEvent;\n        name: string;\n    }\n\n    export interface UpdateAvailableDetails {\n        /** The version number of the available update. */\n        version: string;\n    }\n\n    export interface UpdateCheckDetails {\n        /** The version of the available update. */\n        version: string;\n    }\n\n    export interface PortDisconnectEvent extends chrome.events.Event<(port: Port) => void> { }\n\n    export interface PortMessageEvent extends chrome.events.Event<(message: any, port: Port) => void> { }\n\n    export interface ExtensionMessageEvent extends chrome.events.Event<(message: any, sender: MessageSender, sendResponse: (response: any) => void) => void> { }\n\n    export interface ExtensionConnectEvent extends chrome.events.Event<(port: Port) => void> { }\n\n    export interface RuntimeInstalledEvent extends chrome.events.Event<(details: InstalledDetails) => void> { }\n\n    export interface RuntimeEvent extends chrome.events.Event<() => void> { }\n\n    export interface RuntimeRestartRequiredEvent extends chrome.events.Event<(reason: string) => void> { }\n\n    export interface RuntimeUpdateAvailableEvent extends chrome.events.Event<(details: UpdateAvailableDetails) => void> { }\n\n    export interface ManifestIcons {\n        [size: number]: string;\n    }\n\n    export interface ManifestAction {\n        default_icon?: ManifestIcons;\n        default_title?: string;\n        default_popup?: string;\n    }\n\n    export interface SearchProvider {\n        name?: string;\n        keyword?: string;\n        favicon_url?: string;\n        search_url: string;\n        encoding?: string;\n        suggest_url?: string;\n        instant_url?: string;\n        image_url?: string;\n        search_url_post_params?: string;\n        suggest_url_post_params?: string;\n        instant_url_post_params?: string;\n        image_url_post_params?: string;\n        alternate_urls?: string[];\n        prepopulated_id?: number;\n        is_default?: boolean;\n    }\n\n    export interface Manifest {\n        // Required\n        manifest_version: number;\n        name: string;\n        version: string;\n\n        // Recommended\n        default_locale?: string;\n        description?: string;\n        icons?: ManifestIcons;\n\n        // Pick one (or none)\n        browser_action?: ManifestAction;\n        page_action?: ManifestAction;\n\n        // Optional\n        author?: any;\n        automation?: any;\n        background?: {\n            scripts?: string[];\n            page?: string;\n            persistent?: boolean;\n        };\n        background_page?: string;\n        chrome_settings_overrides?: {\n            homepage?: string;\n            search_provider?: SearchProvider;\n            startup_pages?: string[];\n        };\n        chrome_ui_overrides?: {\n            bookmarks_ui?: {\n                remove_bookmark_shortcut?: boolean;\n                remove_button?: boolean;\n            }\n        };\n        chrome_url_overrides?: {\n            bookmarks?: string;\n            history?: string;\n            newtab?: string;\n        };\n        commands?: {\n            [name: string]: {\n                suggested_key?: {\n                    default?: string;\n                    windows?: string;\n                    mac?: string;\n                    chromeos?: string;\n                    linux?: string;\n                };\n                description?: string;\n                global?: boolean\n            }\n        };\n        content_capabilities?: {\n            matches?: string[];\n            permissions?: string[];\n        };\n        content_scripts?: {\n            matches?: string[];\n            exclude_matches?: string[];\n            css?: string[];\n            js?: string[];\n            run_at?: string;\n            all_frames?: boolean;\n            include_globs?: string[];\n            exclude_globs?: string[];\n        }[];\n        content_security_policy?: string;\n        converted_from_user_script?: boolean;\n        copresence?: any;\n        current_locale?: string;\n        devtools_page?: string;\n        event_rules?: {\n            event?: string;\n            actions?: {\n                type: string;\n            }[];\n            conditions?: chrome.declarativeContent.PageStateMatcherProperties[]\n        }[];\n        externally_connectable?: {\n            ids?: string[];\n            matches?: string[];\n            accepts_tls_channel_id?: boolean;\n        };\n        file_browser_handlers?: {\n            id?: string;\n            default_title?: string;\n            file_filters?: string[];\n        }[];\n        file_system_provider_capabilities?: {\n            configurable?: boolean;\n            watchable?: boolean;\n            multiple_mounts?: boolean;\n            source?: string;\n        };\n        homepage_url?: string;\n        import?: {\n            id: string;\n            minimum_version?: string\n        }[];\n        export?: {\n            whitelist?: string[]\n        };\n        incognito?: string;\n        input_components?: {\n            name?: string;\n            type?: string;\n            id?: string;\n            description?: string;\n            language?: string;\n            layouts?: any[];\n        }[];\n        key?: string;\n        minimum_chrome_version?: string;\n        nacl_modules?: {\n            path: string;\n            mime_type: string;\n        }[];\n        oauth2?: {\n            client_id: string;\n            scopes?: string[];\n        };\n        offline_enabled?: boolean;\n        omnibox?: {\n            keyword: string;\n        };\n        optional_permissions?: string[];\n        options_page?: string;\n        options_ui?: {\n            page?: string;\n            chrome_style?: boolean;\n            open_in_tab?: boolean;\n        };\n        permissions?: string[];\n        platforms?: {\n            nacl_arch?: string;\n            sub_package_path: string;\n        }[];\n        plugins?: {\n            path: string;\n        }[];\n        requirements?: {\n            \'3D\'?: {\n                features?: string[]\n            };\n            plugins?: {\n                npapi?: boolean;\n            }\n        };\n        sandbox?: {\n            pages: string[];\n            content_security_policy?: string;\n        };\n        short_name?: string;\n        signature?: any;\n        spellcheck?: {\n            dictionary_language?: string;\n            dictionary_locale?: string;\n            dictionary_format?: string;\n            dictionary_path?: string;\n        };\n        storage?: {\n            managed_schema: string\n        };\n        system_indicator?: any;\n        tts_engine?: {\n            voices: {\n                voice_name: string;\n                lang?: string;\n                gender?: string;\n                event_types?: string[];\n            }[]\n        };\n        update_url?: string;\n        version_name?: string;\n        web_accessible_resources?: string[];\n        [key: string]: any;\n    }\n\n    /**\n     * Attempts to connect to connect listeners within an extension/app (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect.\n     * @since Chrome 26.\n     */\n    export function connect(connectInfo?: ConnectInfo): Port;\n    /**\n     * Attempts to connect to connect listeners within an extension/app (such as the background page), or other extensions/apps. This is useful for content scripts connecting to their extension processes, inter-app/extension communication, and web messaging. Note that this does not connect to any listeners in a content script. Extensions may connect to content scripts embedded in tabs via tabs.connect.\n     * @since Chrome 26.\n     * @param extensionId Optional.\n     * The ID of the extension or app to connect to. If omitted, a connection will be attempted with your own extension. Required if sending messages from a web page for web messaging.\n     */\n    export function connect(extensionId: string, connectInfo?: ConnectInfo): Port;\n    /**\n     * Connects to a native application in the host machine.\n     * @since Chrome 28.\n     * @param application The name of the registered application to connect to.\n     */\n    export function connectNative(application: string): Port;\n    /** Retrieves the JavaScript \'window\' object for the background page running inside the current extension/app. If the background page is an event page, the system will ensure it is loaded before calling the callback. If there is no background page, an error is set. */\n    export function getBackgroundPage(callback: (backgroundPage?: Window) => void): void;\n    /**\n     * Returns details about the app or extension from the manifest. The object returned is a serialization of the full manifest file.\n     * @returns The manifest details.\n     */\n    export function getManifest(): Manifest;\n    /**\n     * Returns a DirectoryEntry for the package directory.\n     * @since Chrome 29.\n     */\n    export function getPackageDirectoryEntry(callback: (directoryEntry: DirectoryEntry) => void): void;\n    /**\n     * Returns information about the current platform.\n     * @since Chrome 29.\n     * @param callback Called with results\n     */\n    export function getPlatformInfo(callback: (platformInfo: PlatformInfo) => void): void;\n    /**\n     * Converts a relative path within an app/extension install directory to a fully-qualified URL.\n     * @param path A path to a resource within an app/extension expressed relative to its install directory.\n     */\n    export function getURL(path: string): string;\n    /**\n     * Reloads the app or extension.\n     * @since Chrome 25.\n     */\n    export function reload(): void;\n    /**\n     * Requests an update check for this app/extension.\n     * @since Chrome 25.\n     * @param callback\n     * Parameter status: Result of the update check. One of: "throttled", "no_update", or "update_available"\n     * Optional parameter details: If an update is available, this contains more information about the available update.\n     */\n    export function requestUpdateCheck(callback: (status: string, details?: UpdateCheckDetails) => void): void;\n    /**\n     * Restart the ChromeOS device when the app runs in kiosk mode. Otherwise, it\'s no-op.\n     * @since Chrome 32.\n     */\n    export function restart(): void;\n    /**\n     * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.\n     * @since Chrome 26.\n     * @param responseCallback Optional\n     * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendMessage(message: any, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.\n     * @since Chrome 32.\n     * @param responseCallback Optional\n     * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendMessage(message: any, options: MessageOptions, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.\n     * @since Chrome 26.\n     * @param extensionId The ID of the extension/app to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n     * @param responseCallback Optional\n     * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendMessage(extensionId: string, message: any, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single message to event listeners within your extension/app or a different extension/app. Similar to runtime.connect but only sends a single message, with an optional response. If sending to your extension, the runtime.onMessage event will be fired in each page, or runtime.onMessageExternal, if a different extension. Note that extensions cannot send messages to content scripts using this method. To send messages to content scripts, use tabs.sendMessage.\n     * @since Chrome 32.\n     * @param extensionId The ID of the extension/app to send the message to. If omitted, the message will be sent to your own extension/app. Required if sending messages from a web page for web messaging.\n     * @param responseCallback Optional\n     * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the extension, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendMessage(extensionId: string, message: any, options: MessageOptions, responseCallback?: (response: any) => void): void;\n    /**\n     * Send a single message to a native application.\n     * @since Chrome 28.\n     * @param application The of the native messaging host.\n     * @param message The message that will be passed to the native messaging host.\n     * @param responseCallback Optional.\n     * Parameter response: The response message sent by the native messaging host. If an error occurs while connecting to the native messaging host, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendNativeMessage(application: string, message: Object, responseCallback?: (response: any) => void): void;\n    /**\n     * Sets the URL to be visited upon uninstallation. This may be used to clean up server-side data, do analytics, and implement surveys. Maximum 255 characters.\n     * @since Chrome 41.\n     * @param url Since Chrome 34.\n     * URL to be opened after the extension is uninstalled. This URL must have an http: or https: scheme. Set an empty string to not open a new tab upon uninstallation.\n     * @param callback Called when the uninstall URL is set. If the given URL is invalid, runtime.lastError will be set.\n     */\n    export function setUninstallURL(url: string, callback?: () => void): void;\n    /**\n     * Open your Extension\'s options page, if possible.\n     * The precise behavior may depend on your manifest\'s options_ui or options_page key, or what Chrome happens to support at the time. For example, the page may be opened in a new tab, within chrome://extensions, within an App, or it may just focus an open options page. It will never cause the caller page to reload.\n     * If your Extension does not declare an options page, or Chrome failed to create one for some other reason, the callback will set lastError.\n     * @since Chrome 42.\n     */\n    export function openOptionsPage(callback?: () => void): void;\n\n    /**\n     * Fired when a connection is made from either an extension process or a content script.\n     * @since Chrome 26.\n     */\n    export var onConnect: ExtensionConnectEvent;\n    /**\n     * Fired when a connection is made from another extension.\n     * @since Chrome 26.\n     */\n    export var onConnectExternal: ExtensionConnectEvent;\n    /** Sent to the event page just before it is unloaded. This gives the extension opportunity to do some clean up. Note that since the page is unloading, any asynchronous operations started while handling this event are not guaranteed to complete. If more activity for the event page occurs before it gets unloaded the onSuspendCanceled event will be sent and the page won\'t be unloaded. */\n    export var onSuspend: RuntimeEvent;\n    /**\n     * Fired when a profile that has this extension installed first starts up. This event is not fired when an incognito profile is started, even if this extension is operating in \'split\' incognito mode.\n     * @since Chrome 23.\n     */\n    export var onStartup: RuntimeEvent;\n    /** Fired when the extension is first installed, when the extension is updated to a new version, and when Chrome is updated to a new version. */\n    export var onInstalled: RuntimeInstalledEvent;\n    /** Sent after onSuspend to indicate that the app won\'t be unloaded after all. */\n    export var onSuspendCanceled: RuntimeEvent;\n    /**\n     * Fired when a message is sent from either an extension process or a content script.\n     * @since Chrome 26.\n     */\n    export var onMessage: ExtensionMessageEvent;\n    /**\n     * Fired when a message is sent from another extension/app. Cannot be used in a content script.\n     * @since Chrome 26.\n     */\n    export var onMessageExternal: ExtensionMessageEvent;\n    /**\n     * Fired when an app or the device that it runs on needs to be restarted. The app should close all its windows at its earliest convenient time to let the restart to happen. If the app does nothing, a restart will be enforced after a 24-hour grace period has passed. Currently, this event is only fired for Chrome OS kiosk apps.\n     * @since Chrome 29.\n     */\n    export var onRestartRequired: RuntimeRestartRequiredEvent;\n    /**\n     * Fired when an update is available, but isn\'t installed immediately because the app is currently running. If you do nothing, the update will be installed the next time the background page gets unloaded, if you want it to be installed sooner you can explicitly call chrome.runtime.reload(). If your extension is using a persistent background page, the background page of course never gets unloaded, so unless you call chrome.runtime.reload() manually in response to this event the update will not get installed until the next time chrome itself restarts. If no handlers are listening for this event, and your extension has a persistent background page, it behaves as if chrome.runtime.reload() is called in response to this event.\n     * @since Chrome 25.\n     */\n    export var onUpdateAvailable: RuntimeUpdateAvailableEvent;\n    /**\n     * @deprecated since Chrome 33. Please use chrome.runtime.onRestartRequired.\n     * Fired when a Chrome update is available, but isn\'t installed immediately because a browser restart is required.\n     */\n    export var onBrowserUpdateAvailable: RuntimeEvent;\n}\n\n////////////////////\n// Script Badge\n////////////////////\ndeclare namespace chrome.scriptBadge {\n    export interface GetPopupDetails {\n        tabId: number;\n    }\n\n    export interface AttentionDetails {\n        tabId: number;\n    }\n\n    export interface SetPopupDetails {\n        tabId: number;\n        popup: string;\n    }\n\n    export interface ScriptBadgeClickedEvent extends chrome.events.Event<(tab: chrome.tabs.Tab) => void> { }\n\n    export function getPopup(details: GetPopupDetails, callback: Function): void;\n    export function getAttention(details: AttentionDetails): void;\n    export function setPopup(details: SetPopupDetails): void;\n\n    export var onClicked: ScriptBadgeClickedEvent;\n}\n\n////////////////////\n// Sessions\n////////////////////\n/**\n * Use the chrome.sessions API to query and restore tabs and windows from a browsing session.\n * Permissions:  "sessions"\n * @since Chrome 37.\n */\ndeclare namespace chrome.sessions {\n    export interface Filter {\n        /**\n         * Optional.\n         * The maximum number of entries to be fetched in the requested list. Omit this parameter to fetch the maximum number of entries (sessions.MAX_SESSION_RESULTS).\n         */\n        maxResults?: number;\n    }\n\n    export interface Session {\n        /** The time when the window or tab was closed or modified, represented in milliseconds since the epoch. */\n        lastModified: number;\n        /**\n         * Optional.\n         * The tabs.Tab, if this entry describes a tab. Either this or sessions.Session.window will be set.\n         */\n        tab?: tabs.Tab;\n        /**\n         * Optional.\n         * The windows.Window, if this entry describes a window. Either this or sessions.Session.tab will be set.\n         */\n        window?: windows.Window;\n    }\n\n    export interface Device {\n        /** The name of the foreign device. */\n        deviceName: string;\n        /** A list of open window sessions for the foreign device, sorted from most recently to least recently modified session. */\n        sessions: Session[];\n    }\n\n    export interface SessionChangedEvent extends chrome.events.Event<() => void> { }\n\n    /** The maximum number of sessions.Session that will be included in a requested list. */\n    export var MAX_SESSION_RESULTS: number;\n\n    /**\n     * Gets the list of recently closed tabs and/or windows.\n     * @param callback\n     * Parameter sessions: The list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index 0). The entries may contain either tabs or windows.\n     */\n    export function getRecentlyClosed(filter: Filter, callback: (sessions: Session[]) => void): void;\n    /**\n     * Gets the list of recently closed tabs and/or windows.\n     * @param callback\n     * Parameter sessions: The list of closed entries in reverse order that they were closed (the most recently closed tab or window will be at index 0). The entries may contain either tabs or windows.\n     */\n    export function getRecentlyClosed(callback: (sessions: Session[]) => void): void;\n    /**\n     * Retrieves all devices with synced sessions.\n     * @param callback\n     * Parameter devices: The list of sessions.Device objects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session. tabs.Tab objects are sorted by recency in the windows.Window of the sessions.Session objects.\n     */\n    export function getDevices(filter: Filter, callback: (devices: Device[]) => void): void;\n    /**\n     * Retrieves all devices with synced sessions.\n     * @param callback\n     * Parameter devices: The list of sessions.Device objects for each synced session, sorted in order from device with most recently modified session to device with least recently modified session. tabs.Tab objects are sorted by recency in the windows.Window of the sessions.Session objects.\n     */\n    export function getDevices(callback: (devices: Device[]) => void): void;\n    /**\n     * Reopens a windows.Window or tabs.Tab, with an optional callback to run when the entry has been restored.\n     * @param sessionId Optional.\n     * The windows.Window.sessionId, or tabs.Tab.sessionId to restore. If this parameter is not specified, the most recently closed session is restored.\n     * @param callback Optional.\n     * Parameter restoredSession: A sessions.Session containing the restored windows.Window or tabs.Tab object.\n     */\n    export function restore(sessionId?: string, callback?: (restoredSession: Session) => void): void;\n\n    /** Fired when recently closed tabs and/or windows are changed. This event does not monitor synced sessions changes. */\n    export var onChanged: SessionChangedEvent;\n}\n\n////////////////////\n// Storage\n////////////////////\n/**\n * Use the chrome.storage API to store, retrieve, and track changes to user data.\n * Permissions:  "storage"\n * @since Chrome 20.\n */\ndeclare namespace chrome.storage {\n    export interface StorageArea {\n        /**\n         * Gets the amount of space (in bytes) being used by one or more items.\n         * @param callback Callback with the amount of space being used by storage, or on failure (in which case runtime.lastError will be set).\n         * Parameter bytesInUse: Amount of space being used in storage, in bytes.\n         */\n        getBytesInUse(callback: (bytesInUse: number) => void): void;\n        /**\n         * Gets the amount of space (in bytes) being used by one or more items.\n         * @param keys A single key or list of keys to get the total usage for. An empty list will return 0. Pass in null to get the total usage of all of storage.\n         * @param callback Callback with the amount of space being used by storage, or on failure (in which case runtime.lastError will be set).\n         * Parameter bytesInUse: Amount of space being used in storage, in bytes.\n         */\n        getBytesInUse(keys: string | string[] | null, callback: (bytesInUse: number) => void): void;\n        /**\n         * Removes all items from storage.\n         * @param callback Optional.\n         * Callback on success, or on failure (in which case runtime.lastError will be set).\n         */\n        clear(callback?: () => void): void;\n        /**\n         * Sets multiple items.\n         * @param items An object which gives each key/value pair to update storage with. Any other key/value pairs in storage will not be affected.\n         * Primitive values such as numbers will serialize as expected. Values with a typeof "object" and "function" will typically serialize to {}, with the exception of Array (serializes as expected), Date, and Regex (serialize using their String representation).\n         * @param callback Optional.\n         * Callback on success, or on failure (in which case runtime.lastError will be set).\n         */\n        set(items: Object, callback?: () => void): void;\n        /**\n         * Removes one or more items from storage.\n         * @param A single key or a list of keys for items to remove.\n         * @param callback Optional.\n         * Callback on success, or on failure (in which case runtime.lastError will be set).\n         */\n        remove(keys: string | string[], callback?: () => void): void;\n        /**\n         * Gets one or more items from storage.\n         * @param callback Callback with storage items, or on failure (in which case runtime.lastError will be set).\n         * Parameter items: Object with items in their key-value mappings.\n         */\n        get(callback: (items: { [key: string]: any }) => void): void;\n        /**\n         * Gets one or more items from storage.\n         * @param keys A single key to get, list of keys to get, or a dictionary specifying default values.\n         * An empty list or object will return an empty result object. Pass in null to get the entire contents of storage.\n         * @param callback Callback with storage items, or on failure (in which case runtime.lastError will be set).\n         * Parameter items: Object with items in their key-value mappings.\n         */\n        get(keys: string | string[] | Object | null, callback: (items: { [key: string]: any }) => void): void;\n    }\n\n    export interface StorageChange {\n        /** Optional. The new value of the item, if there is a new value. */\n        newValue?: any;\n        /** Optional. The old value of the item, if there was an old value. */\n        oldValue?: any;\n    }\n\n    export interface LocalStorageArea extends StorageArea {\n        /** The maximum amount (in bytes) of data that can be stored in local storage, as measured by the JSON stringification of every value plus every key\'s length. This value will be ignored if the extension has the unlimitedStorage permission. Updates that would cause this limit to be exceeded fail immediately and set runtime.lastError. */\n        QUOTA_BYTES: number;\n    }\n\n    export interface SyncStorageArea extends StorageArea {\n        /** @deprecated since Chrome 40. The storage.sync API no longer has a sustained write operation quota. */\n        MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE: number;\n        /** The maximum total amount (in bytes) of data that can be stored in sync storage, as measured by the JSON stringification of every value plus every key\'s length. Updates that would cause this limit to be exceeded fail immediately and set runtime.lastError. */\n        QUOTA_BYTES: number;\n        /** The maximum size (in bytes) of each individual item in sync storage, as measured by the JSON stringification of its value plus its key length. Updates containing items larger than this limit will fail immediately and set runtime.lastError. */\n        QUOTA_BYTES_PER_ITEM: number;\n        /** The maximum number of items that can be stored in sync storage. Updates that would cause this limit to be exceeded will fail immediately and set runtime.lastError. */\n        MAX_ITEMS: number;\n        /**\n         * The maximum number of set, remove, or clear operations that can be performed each hour. This is 1 every 2 seconds, a lower ceiling than the short term higher writes-per-minute limit.\n         * Updates that would cause this limit to be exceeded fail immediately and set runtime.lastError.\n         */\n        MAX_WRITE_OPERATIONS_PER_HOUR: number;\n        /**\n         * The maximum number of set, remove, or clear operations that can be performed each minute. This is 2 per second, providing higher throughput than writes-per-hour over a shorter period of time.\n         * Updates that would cause this limit to be exceeded fail immediately and set runtime.lastError.\n         * @since Chrome 40.\n         */\n        MAX_WRITE_OPERATIONS_PER_MINUTE: number;\n    }\n\n    export interface StorageChangedEvent extends chrome.events.Event<(changes: { [key: string]: StorageChange }, areaName: string) => void> { }\n\n    /** Items in the local storage area are local to each machine. */\n    export var local: LocalStorageArea;\n    /** Items in the sync storage area are synced using Chrome Sync. */\n    export var sync: SyncStorageArea;\n\n    /**\n     * Items in the managed storage area are set by the domain administrator, and are read-only for the extension; trying to modify this namespace results in an error.\n     * @since Chrome 33.\n     */\n    export var managed: StorageArea;\n\n    /** Fired when one or more items change. */\n    export var onChanged: StorageChangedEvent;\n}\n\n////////////////////\n// Socket\n////////////////////\ndeclare namespace chrome.socket {\n    export interface CreateInfo {\n        socketId: number;\n    }\n\n    export interface AcceptInfo {\n        resultCode: number;\n        socketId?: number;\n    }\n\n    export interface ReadInfo {\n        resultCode: number;\n        data: ArrayBuffer;\n    }\n\n    export interface WriteInfo {\n        bytesWritten: number;\n    }\n\n    export interface RecvFromInfo {\n        resultCode: number;\n        data: ArrayBuffer;\n        port: number;\n        address: string;\n    }\n\n    export interface SocketInfo {\n        socketType: string;\n        localPort?: number;\n        peerAddress?: string;\n        peerPort?: number;\n        localAddress?: string;\n        connected: boolean;\n    }\n\n    export interface NetworkInterface {\n        name: string;\n        address: string;\n    }\n\n    export function create(type: string, options?: Object, callback?: (createInfo: CreateInfo) => void): void;\n    export function destroy(socketId: number): void;\n    export function connect(socketId: number, hostname: string, port: number, callback: (result: number) => void): void;\n    export function bind(socketId: number, address: string, port: number, callback: (result: number) => void): void;\n    export function disconnect(socketId: number): void;\n    export function read(socketId: number, bufferSize?: number, callback?: (readInfo: ReadInfo) => void): void;\n    export function write(socketId: number, data: ArrayBuffer, callback?: (writeInfo: WriteInfo) => void): void;\n    export function recvFrom(socketId: number, bufferSize?: number, callback?: (recvFromInfo: RecvFromInfo) => void): void;\n    export function sendTo(socketId: number, data: ArrayBuffer, address: string, port: number, callback?: (writeInfo: WriteInfo) => void): void;\n    export function listen(socketId: number, address: string, port: number, backlog?: number, callback?: (result: number) => void): void;\n    export function accept(socketId: number, callback?: (acceptInfo: AcceptInfo) => void): void;\n    export function setKeepAlive(socketId: number, enable: boolean, delay?: number, callback?: (result: boolean) => void): void;\n    export function setNoDelay(socketId: number, noDelay: boolean, callback?: (result: boolean) => void): void;\n    export function getInfo(socketId: number, callback: (result: SocketInfo) => void): void;\n    export function getNetworkList(callback: (result: NetworkInterface[]) => void): void;\n}\n\n////////////////////\n// System CPU\n////////////////////\n/**\n * Use the system.cpu API to query CPU metadata.\n * Permissions: "system.cpu"\n * @since Chrome 32.\n */\ndeclare namespace chrome.system.cpu {\n    export interface ProcessorUsage {\n        /** The cumulative time used by userspace programs on this processor. */\n        user: number;\n        /** The cumulative time used by kernel programs on this processor. */\n        kernel: number;\n        /** The cumulative time spent idle by this processor. */\n        idle: number;\n        /** The total cumulative time for this processor. This value is equal to user + kernel + idle. */\n        total: number;\n    }\n\n    export interface ProcessorInfo {\n        /** Cumulative usage info for this logical processor. */\n        usage: ProcessorUsage;\n    }\n\n    export interface CpuInfo {\n        /** The number of logical processors. */\n        numOfProcessors: number;\n        /** The architecture name of the processors. */\n        archName: string;\n        /** The model name of the processors. */\n        modelName: string;\n        /**\n         * A set of feature codes indicating some of the processor\'s capabilities.\n         * The currently supported codes are "mmx", "sse", "sse2", "sse3", "ssse3", "sse4_1", "sse4_2", and "avx".\n         */\n        features: string[];\n        /** Information about each logical processor. */\n        processors: ProcessorInfo[];\n    }\n\n    /** Queries basic CPU information of the system. */\n    export function getInfo(callback: (info: CpuInfo) => void): void;\n}\n\n////////////////////\n// System Memory\n////////////////////\n/**\n * The chrome.system.memory API.\n * Permissions:  "system.memory"\n * @since Chrome 32.\n */\ndeclare namespace chrome.system.memory {\n    export interface MemoryInfo {\n        /** The total amount of physical memory capacity, in bytes. */\n        capacity: number;\n        /** The amount of available capacity, in bytes. */\n        availableCapacity: number;\n    }\n\n    /** Get physical memory information. */\n    export function getInfo(callback: (info: MemoryInfo) => void): void;\n}\n\n////////////////////\n// System Storage\n////////////////////\n/**\n * Use the chrome.system.storage API to query storage device information and be notified when a removable storage device is attached and detached.\n * Permissions:  "system.storage"\n * @since Chrome 30.\n */\ndeclare namespace chrome.system.storage {\n    export interface StorageUnitInfo {\n        /** The transient ID that uniquely identifies the storage device. This ID will be persistent within the same run of a single application. It will not be a persistent identifier between different runs of an application, or between different applications. */\n        id: string;\n        /** The name of the storage unit. */\n        name: string;\n        /**\n         * The media type of the storage unit.\n         * fixed: The storage has fixed media, e.g. hard disk or SSD.\n         * removable: The storage is removable, e.g. USB flash drive.\n         * unknown: The storage type is unknown.\n         */\n        type: string;\n        /** The total amount of the storage space, in bytes. */\n        capacity: number;\n    }\n\n    export interface StorageCapacityInfo {\n        /** A copied |id| of getAvailableCapacity function parameter |id|. */\n        id: string;\n        /** The available capacity of the storage device, in bytes. */\n        availableCapacity: number;\n    }\n\n    export interface SystemStorageAttachedEvent extends chrome.events.Event<(info: StorageUnitInfo) => void> { }\n\n    export interface SystemStorageDetachedEvent extends chrome.events.Event<(id: string) => void> { }\n\n    /** Get the storage information from the system. The argument passed to the callback is an array of StorageUnitInfo objects. */\n    export function getInfo(callback: (info: StorageUnitInfo[]) => void): void;\n    /**\n     * Ejects a removable storage device.\n     * @param callback\n     * Parameter result: success: The ejection command is successful -- the application can prompt the user to remove the device; in_use: The device is in use by another application. The ejection did not succeed; the user should not remove the device until the other application is done with the device; no_such_device: There is no such device known. failure: The ejection command failed.\n     */\n    export function ejectDevice(id: string, callback: (result: string) => void): void;\n    /**\n     * Get the available capacity of a specified |id| storage device. The |id| is the transient device ID from StorageUnitInfo.\n     * @since Dev channel only.\n     */\n    export function getAvailableCapacity(id: string, callback: (info: StorageCapacityInfo) => void): void;\n\n    /** Fired when a new removable storage is attached to the system. */\n    export var onAttached: SystemStorageAttachedEvent;\n    /** Fired when a removable storage is detached from the system. */\n    export var onDetached: SystemStorageDetachedEvent;\n}\n\n////////////////////\n// TabCapture\n////////////////////\n/**\n * Use the chrome.tabCapture API to interact with tab media streams.\n * Permissions:  "tabCapture"\n * @since Chrome 31.\n */\ndeclare namespace chrome.tabCapture {\n    export interface CaptureInfo {\n        /** The id of the tab whose status changed. */\n        tabId: number;\n        /**\n         * The new capture status of the tab.\n         * One of: "pending", "active", "stopped", or "error"\n         */\n        status: string;\n        /** Whether an element in the tab being captured is in fullscreen mode. */\n        fullscreen: boolean;\n    }\n\n    export interface CaptureOptions {\n        /** Optional. */\n        audio?: boolean;\n        /** Optional. */\n        video?: boolean;\n        /** Optional. */\n        audioConstraints?: MediaStreamConstraints;\n        /** Optional. */\n        videoConstraints?: MediaStreamConstraints;\n    }\n\n    export interface CaptureStatusChangedEvent extends chrome.events.Event<(info: CaptureInfo) => void> { }\n\n    /**\n     * Captures the visible area of the currently active tab. Capture can only be started on the currently active tab after the extension has been invoked. Capture is maintained across page navigations within the tab, and stops when the tab is closed, or the media stream is closed by the extension.\n     * @param options Configures the returned media stream.\n     * @param callback Callback with either the tab capture stream or null.\n     */\n    export function capture(options: CaptureOptions, callback: (stream: MediaStream | null) => void): void;\n    /**\n     * Returns a list of tabs that have requested capture or are being captured, i.e. status != stopped and status != error. This allows extensions to inform the user that there is an existing tab capture that would prevent a new tab capture from succeeding (or to prevent redundant requests for the same tab).\n     * @param callback Callback invoked with CaptureInfo[] for captured tabs.\n     */\n    export function getCapturedTabs(callback: (result: CaptureInfo[]) => void): void;\n\n    /** Event fired when the capture status of a tab changes. This allows extension authors to keep track of the capture status of tabs to keep UI elements like page actions in sync. */\n    export var onStatusChanged: CaptureStatusChangedEvent;\n}\n\n////////////////////\n// Tabs\n////////////////////\n/**\n * Use the chrome.tabs API to interact with the browser\'s tab system. You can use this API to create, modify, and rearrange tabs in the browser.\n * Permissions: The majority of the chrome.tabs API can be used without declaring any permission. However, the "tabs" permission is required in order to populate the url, title, and favIconUrl properties of Tab.\n * @since Chrome 5.\n */\ndeclare namespace chrome.tabs {\n    /**\n     * Tab muted state and the reason for the last state change.\n     * @since Chrome 46. Warning: this is the current Beta channel.\n     */\n    export interface MutedInfo {\n        /** Whether the tab is prevented from playing sound (but hasn\'t necessarily recently produced sound). Equivalent to whether the muted audio indicator is showing. */\n        muted: boolean;\n        /**\n         * Optional.\n         * The reason the tab was muted or unmuted. Not set if the tab\'s mute state has never been changed.\n         * "user": A user input action has set/overridden the muted state.\n         * "capture": Tab capture started, forcing a muted state change.\n         * "extension": An extension, identified by the extensionId field, set the muted state.\n         */\n        reason?: string;\n        /**\n         * Optional.\n         * The ID of the extension that changed the muted state. Not set if an extension was not the reason the muted state last changed.\n         */\n        extensionId?: string;\n    }\n\n    export interface Tab {\n        /**\n         * Optional.\n         * Either loading or complete.\n         */\n        status?: string;\n        /** The zero-based index of the tab within its window. */\n        index: number;\n        /**\n         * Optional.\n         * The ID of the tab that opened this tab, if any. This property is only present if the opener tab still exists.\n         * @since Chrome 18.\n         */\n        openerTabId?: number;\n        /**\n         * Optional.\n         * The title of the tab. This property is only present if the extension\'s manifest includes the "tabs" permission.\n         */\n        title?: string;\n        /**\n         * Optional.\n         * The URL the tab is displaying. This property is only present if the extension\'s manifest includes the "tabs" permission.\n         */\n        url?: string;\n        /**\n         * Whether the tab is pinned.\n         * @since Chrome 9.\n         */\n        pinned: boolean;\n        /**\n         * Whether the tab is highlighted.\n         * @since Chrome 16.\n         */\n        highlighted: boolean;\n        /** The ID of the window the tab is contained within. */\n        windowId: number;\n        /**\n         * Whether the tab is active in its window. (Does not necessarily mean the window is focused.)\n         * @since Chrome 16.\n         */\n        active: boolean;\n        /**\n         * Optional.\n         * The URL of the tab\'s favicon. This property is only present if the extension\'s manifest includes the "tabs" permission. It may also be an empty string if the tab is loading.\n         */\n        favIconUrl?: string;\n        /**\n         * Optional.\n         * The ID of the tab. Tab IDs are unique within a browser session. Under some circumstances a Tab may not be assigned an ID, for example when querying foreign tabs using the sessions API, in which case a session ID may be present. Tab ID can also be set to chrome.tabs.TAB_ID_NONE for apps and devtools windows.\n         */\n        id?: number;\n        /** Whether the tab is in an incognito window. */\n        incognito: boolean;\n        /**\n         * Whether the tab is selected.\n         * @deprecated since Chrome 33. Please use tabs.Tab.highlighted.\n         */\n        selected: boolean;\n        /**\n         * Optional.\n         * Whether the tab has produced sound over the past couple of seconds (but it might not be heard if also muted). Equivalent to whether the speaker audio indicator is showing.\n         * @since Chrome 45.\n         */\n        audible?: boolean;\n        /**\n         * Whether the tab is discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content gets reloaded the next time it\'s activated.\n         * @since Chrome 54.\n         */\n        discarded: boolean;\n        /**\n         * Whether the tab can be discarded automatically by the browser when resources are low.\n         * @since Chrome 54.\n         */\n        autoDiscardable: boolean;\n        /**\n         * Optional.\n         * Current tab muted state and the reason for the last state change.\n         * @since Chrome 46. Warning: this is the current Beta channel.\n         */\n        mutedInfo?: MutedInfo;\n        /**\n         * Optional. The width of the tab in pixels.\n         * @since Chrome 31.\n         */\n        width?: number;\n        /**\n         * Optional. The height of the tab in pixels.\n         * @since Chrome 31.\n         */\n        height?: number;\n        /**\n         * Optional. The session ID used to uniquely identify a Tab obtained from the sessions API.\n         * @since Chrome 31.\n         */\n        sessionId?: string;\n    }\n\n    /**\n     * Defines how zoom changes in a tab are handled and at what scope.\n     * @since Chrome 38.\n     */\n    export interface ZoomSettings {\n        /**\n         * Optional.\n         * Defines how zoom changes are handled, i.e. which entity is responsible for the actual scaling of the page; defaults to "automatic".\n         * "automatic": Zoom changes are handled automatically by the browser.\n         * "manual": Overrides the automatic handling of zoom changes. The onZoomChange event will still be dispatched, and it is the responsibility of the extension to listen for this event and manually scale the page. This mode does not support per-origin zooming, and will thus ignore the scope zoom setting and assume per-tab.\n         * "disabled": Disables all zooming in the tab. The tab will revert to the default zoom level, and all attempted zoom changes will be ignored.\n         */\n        mode?: string;\n        /**\n         * Optional.\n         * Defines whether zoom changes will persist for the page\'s origin, or only take effect in this tab; defaults to per-origin when in automatic mode, and per-tab otherwise.\n         * "per-origin": Zoom changes will persist in the zoomed page\'s origin, i.e. all other tabs navigated to that same origin will be zoomed as well. Moreover, per-origin zoom changes are saved with the origin, meaning that when navigating to other pages in the same origin, they will all be zoomed to the same zoom factor. The per-origin scope is only available in the automatic mode.\n         * "per-tab": Zoom changes only take effect in this tab, and zoom changes in other tabs will not affect the zooming of this tab. Also, per-tab zoom changes are reset on navigation; navigating a tab will always load pages with their per-origin zoom factors.\n         */\n        scope?: string;\n        /**\n         * Optional.\n         * Used to return the default zoom level for the current tab in calls to tabs.getZoomSettings.\n         * @since Chrome 43.\n         */\n        defaultZoomFactor?: number;\n    }\n\n    export interface InjectDetails {\n        /**\n         * Optional.\n         * If allFrames is true, implies that the JavaScript or CSS should be injected into all frames of current page. By default, it\'s false and is only injected into the top frame.\n         */\n        allFrames?: boolean;\n        /**\n         * Optional. JavaScript or CSS code to inject.\n         * Warning: Be careful using the code parameter. Incorrect use of it may open your extension to cross site scripting attacks.\n         */\n        code?: string;\n        /**\n         * Optional. The soonest that the JavaScript or CSS will be injected into the tab.\n         * One of: "document_start", "document_end", or "document_idle"\n         * @since Chrome 20.\n         */\n        runAt?: string;\n        /** Optional. JavaScript or CSS file to inject. */\n        file?: string;\n        /**\n         * Optional.\n         * The frame where the script or CSS should be injected. Defaults to 0 (the top-level frame).\n         * @since Chrome 39.\n         */\n        frameId?: number;\n        /**\n         * Optional.\n         * If matchAboutBlank is true, then the code is also injected in about:blank and about:srcdoc frames if your extension has access to its parent document. Code cannot be inserted in top-level about:-frames. By default it is false.\n         * @since Chrome 39.\n         */\n        matchAboutBlank?: boolean;\n        /**\n         * Optional. The origin of the CSS to inject. This may only be specified for CSS, not JavaScript. Defaults to "author".\n         * One of: "author", or "user"\n         * @since Chrome 66.\n         */\n        cssOrigin?: string;\n    }\n\n    export interface CreateProperties {\n        /** Optional. The position the tab should take in the window. The provided value will be clamped to between zero and the number of tabs in the window. */\n        index?: number;\n        /**\n         * Optional.\n         * The ID of the tab that opened this tab. If specified, the opener tab must be in the same window as the newly created tab.\n         * @since Chrome 18.\n         */\n        openerTabId?: number;\n        /**\n         * Optional.\n         * The URL to navigate the tab to initially. Fully-qualified URLs must include a scheme (i.e. \'http://www.google.com\', not \'www.google.com\'). Relative URLs will be relative to the current page within the extension. Defaults to the New Tab Page.\n         */\n        url?: string;\n        /**\n         * Optional. Whether the tab should be pinned. Defaults to false\n         * @since Chrome 9.\n         */\n        pinned?: boolean;\n        /** Optional. The window to create the new tab in. Defaults to the current window. */\n        windowId?: number;\n        /**\n         * Optional.\n         * Whether the tab should become the active tab in the window. Does not affect whether the window is focused (see windows.update). Defaults to true.\n         * @since Chrome 16.\n         */\n        active?: boolean;\n        /**\n         * Optional. Whether the tab should become the selected tab in the window. Defaults to true\n         * @deprecated since Chrome 33. Please use active.\n         */\n        selected?: boolean;\n    }\n\n    export interface MoveProperties {\n        /** The position to move the window to. -1 will place the tab at the end of the window. */\n        index: number;\n        /** Optional. Defaults to the window the tab is currently in. */\n        windowId?: number;\n    }\n\n    export interface UpdateProperties {\n        /**\n         * Optional. Whether the tab should be pinned.\n         * @since Chrome 9.\n         */\n        pinned?: boolean;\n        /**\n         * Optional. The ID of the tab that opened this tab. If specified, the opener tab must be in the same window as this tab.\n         * @since Chrome 18.\n         */\n        openerTabId?: number;\n        /** Optional. A URL to navigate the tab to. */\n        url?: string;\n        /**\n         * Optional. Adds or removes the tab from the current selection.\n         * @since Chrome 16.\n         */\n        highlighted?: boolean;\n        /**\n         * Optional. Whether the tab should be active. Does not affect whether the window is focused (see windows.update).\n         * @since Chrome 16.\n         */\n        active?: boolean;\n        /**\n         * Optional. Whether the tab should be selected.\n         * @deprecated since Chrome 33. Please use highlighted.\n         */\n        selected?: boolean;\n        /**\n         * Optional. Whether the tab should be muted.\n         * @since Chrome 45.\n         */\n        muted?: boolean;\n        /**\n         * Optional. Whether the tab should be discarded automatically by the browser when resources are low.\n         * @since Chrome 54.\n         */\n        autoDiscardable?: boolean;\n    }\n\n    export interface CaptureVisibleTabOptions {\n        /**\n         * Optional.\n         * When format is "jpeg", controls the quality of the resulting image. This value is ignored for PNG images. As quality is decreased, the resulting image will have more visual artifacts, and the number of bytes needed to store it will decrease.\n         */\n        quality?: number;\n        /**\n         * Optional. The format of an image.\n         * One of: "jpeg", or "png"\n         */\n        format?: string;\n    }\n\n    export interface ReloadProperties {\n        /** Optional. Whether using any local cache. Default is false. */\n        bypassCache?: boolean;\n    }\n\n    export interface ConnectInfo {\n        /** Optional. Will be passed into onConnect for content scripts that are listening for the connection event. */\n        name?: string;\n        /**\n         * Open a port to a specific frame identified by frameId instead of all frames in the tab.\n         * @since Chrome 41.\n         */\n        frameId?: number;\n    }\n\n    export interface MessageSendOptions {\n        /** Optional. Send a message to a specific frame identified by frameId instead of all frames in the tab. */\n        frameId?: number;\n    }\n\n    export interface HighlightInfo {\n        /** One or more tab indices to highlight. */\n        tabs: number | number[];\n        /** Optional. The window that contains the tabs. */\n        windowId?: number;\n    }\n\n    export interface QueryInfo {\n        /**\n         * Optional. Whether the tabs have completed loading.\n         * One of: "loading", or "complete"\n         */\n        status?: \'loading\' | \'complete\';\n        /**\n         * Optional. Whether the tabs are in the last focused window.\n         * @since Chrome 19.\n         */\n        lastFocusedWindow?: boolean;\n        /** Optional. The ID of the parent window, or windows.WINDOW_ID_CURRENT for the current window. */\n        windowId?: number;\n        /**\n         * Optional. The type of window the tabs are in.\n         * One of: "normal", "popup", "panel", "app", or "devtools"\n         */\n        windowType?: \'normal\' | \'popup\' | \'panel\' | \'app\' | \'devtools\';\n        /** Optional. Whether the tabs are active in their windows. */\n        active?: boolean;\n        /**\n         * Optional. The position of the tabs within their windows.\n         * @since Chrome 18.\n         */\n        index?: number;\n        /** Optional. Match page titles against a pattern. */\n        title?: string;\n        /** Optional. Match tabs against one or more URL patterns. Note that fragment identifiers are not matched. */\n        url?: string | string[];\n        /**\n         * Optional. Whether the tabs are in the current window.\n         * @since Chrome 19.\n         */\n        currentWindow?: boolean;\n        /** Optional. Whether the tabs are highlighted. */\n        highlighted?: boolean;\n        /**\n         * Optional.\n         * Whether the tabs are discarded. A discarded tab is one whose content has been unloaded from memory, but is still visible in the tab strip. Its content gets reloaded the next time it\'s activated.\n         * @since Chrome 54.\n         */\n        discarded?: boolean;\n        /**\n         * Optional.\n         * Whether the tabs can be discarded automatically by the browser when resources are low.\n         * @since Chrome 54.\n         */\n        autoDiscardable?: boolean;\n        /** Optional. Whether the tabs are pinned. */\n        pinned?: boolean;\n        /**\n         * Optional. Whether the tabs are audible.\n         * @since Chrome 45.\n         */\n        audible?: boolean;\n        /**\n         * Optional. Whether the tabs are muted.\n         * @since Chrome 45.\n         */\n        muted?: boolean;\n    }\n\n    export interface TabHighlightInfo {\n        windowId: number;\n        tabIds: number[];\n    }\n\n    export interface TabRemoveInfo {\n        /**\n         * The window whose tab is closed.\n         * @since Chrome 25.\n         */\n        windowId: number;\n        /** True when the tab is being closed because its window is being closed. */\n        isWindowClosing: boolean;\n    }\n\n    export interface TabAttachInfo {\n        newPosition: number;\n        newWindowId: number;\n    }\n\n    export interface TabChangeInfo {\n        /** Optional. The status of the tab. Can be either loading or complete. */\n        status?: string;\n        /**\n         * The tab\'s new pinned state.\n         * @since Chrome 9.\n         */\n        pinned?: boolean;\n        /** Optional. The tab\'s URL if it has changed. */\n        url?: string;\n        /**\n         * The tab\'s new audible state.\n         * @since Chrome 45.\n         */\n        audible?: boolean;\n        /**\n         * The tab\'s new discarded state.\n         * @since Chrome 54.\n         */\n        discarded?: boolean;\n        /**\n         * The tab\'s new auto-discardable\n         * @since Chrome 54.\n         */\n        autoDiscardable?: boolean;\n        /**\n         * The tab\'s new muted state and the reason for the change.\n         * @since Chrome 46. Warning: this is the current Beta channel.\n         */\n        mutedInfo?: MutedInfo;\n        /**\n         * The tab\'s new favicon URL.\n         * @since Chrome 27.\n         */\n        favIconUrl?: string;\n        /**\n         * The tab\'s new title.\n         * @since Chrome 48.\n         */\n        title?: string;\n    }\n\n    export interface TabMoveInfo {\n        toIndex: number;\n        windowId: number;\n        fromIndex: number;\n    }\n\n    export interface TabDetachInfo {\n        oldWindowId: number;\n        oldPosition: number;\n    }\n\n    export interface TabActiveInfo {\n        /** The ID of the tab that has become active. */\n        tabId: number;\n        /** The ID of the window the active tab changed inside of. */\n        windowId: number;\n    }\n\n    export interface TabWindowInfo {\n        /** The ID of the window of where the tab is located. */\n        windowId: number;\n    }\n\n    export interface ZoomChangeInfo {\n        tabId: number;\n        oldZoomFactor: number;\n        newZoomFactor: number;\n        zoomSettings: ZoomSettings;\n    }\n\n    export interface TabHighlightedEvent extends chrome.events.Event<(highlightInfo: HighlightInfo) => void> { }\n\n    export interface TabRemovedEvent extends chrome.events.Event<(tabId: number, removeInfo: TabRemoveInfo) => void> { }\n\n    export interface TabUpdatedEvent extends chrome.events.Event<(tabId: number, changeInfo: TabChangeInfo, tab: Tab) => void> { }\n\n    export interface TabAttachedEvent extends chrome.events.Event<(tabId: number, attachInfo: TabAttachInfo) => void> { }\n\n    export interface TabMovedEvent extends chrome.events.Event<(tabId: number, moveInfo: TabMoveInfo) => void> { }\n\n    export interface TabDetachedEvent extends chrome.events.Event<(tabId: number, detachInfo: TabDetachInfo) => void> { }\n\n    export interface TabCreatedEvent extends chrome.events.Event<(tab: Tab) => void> { }\n\n    export interface TabActivatedEvent extends chrome.events.Event<(activeInfo: TabActiveInfo) => void> { }\n\n    export interface TabReplacedEvent extends chrome.events.Event<(addedTabId: number, removedTabId: number) => void> { }\n\n    export interface TabSelectedEvent extends chrome.events.Event<(tabId: number, selectInfo: TabWindowInfo) => void> { }\n\n    export interface TabZoomChangeEvent extends chrome.events.Event<(ZoomChangeInfo: ZoomChangeInfo) => void> { }\n\n    /**\n     * Injects JavaScript code into a page. For details, see the programmatic injection section of the content scripts doc.\n     * @param details Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\n     * @param callback Optional. Called after all the JavaScript has been executed.\n     * Parameter result: The result of the script in every injected frame.\n     */\n    export function executeScript(details: InjectDetails, callback?: (result: any[]) => void): void;\n    /**\n     * Injects JavaScript code into a page. For details, see the programmatic injection section of the content scripts doc.\n     * @param tabId Optional. The ID of the tab in which to run the script; defaults to the active tab of the current window.\n     * @param details Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\n     * @param callback Optional. Called after all the JavaScript has been executed.\n     * Parameter result: The result of the script in every injected frame.\n     */\n    export function executeScript(tabId: number, details: InjectDetails, callback?: (result: any[]) => void): void;\n    /** Retrieves details about the specified tab. */\n    export function get(tabId: number, callback: (tab: Tab) => void): void;\n    /**\n     * Gets details about all tabs in the specified window.\n     * @deprecated since Chrome 33. Please use tabs.query {windowId: windowId}.\n     */\n    export function getAllInWindow(callback: (tab: Tab) => void): void;\n    /**\n     * Gets details about all tabs in the specified window.\n     * @deprecated since Chrome 33. Please use tabs.query {windowId: windowId}.\n     * @param windowId Optional. Defaults to the current window.\n     */\n    export function getAllInWindow(windowId: number, callback: (tab: Tab) => void): void;\n    /** Gets the tab that this script call is being made from. May be undefined if called from a non-tab context (for example: a background page or popup view). */\n    export function getCurrent(callback: (tab?: Tab) => void): void;\n    /**\n     * Gets the tab that is selected in the specified window.\n     * @deprecated since Chrome 33. Please use tabs.query {active: true}.\n     */\n    export function getSelected(callback: (tab: Tab) => void): void;\n    /**\n     * Gets the tab that is selected in the specified window.\n     * @deprecated since Chrome 33. Please use tabs.query {active: true}.\n     * @param windowId Optional. Defaults to the current window.\n     */\n    export function getSelected(windowId: number, callback: (tab: Tab) => void): void;\n    /**\n     * Creates a new tab.\n     * @param callback Optional.\n     * Parameter tab: Details about the created tab. Will contain the ID of the new tab.\n     */\n    export function create(createProperties: CreateProperties, callback?: (tab: Tab) => void): void;\n    /**\n     * Moves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === "normal") windows.\n     * @param tabId The tab to move.\n     * @param callback Optional.\n     * Parameter tab: Details about the moved tab.\n     */\n    export function move(tabId: number, moveProperties: MoveProperties, callback?: (tab: Tab) => void): void;\n    /**\n     * Moves one or more tabs to a new position within its window, or to a new window. Note that tabs can only be moved to and from normal (window.type === "normal") windows.\n     * @param tabIds The tabs to move.\n     * @param callback Optional.\n     * Parameter tabs: Details about the moved tabs.\n     */\n    export function move(tabIds: number[], moveProperties: MoveProperties, callback?: (tabs: Tab[]) => void): void;\n    /**\n     * Modifies the properties of a tab. Properties that are not specified in updateProperties are not modified.\n     * @param callback Optional.\n     * Optional parameter tab: Details about the updated tab. The tabs.Tab object doesn\'t contain url, title and favIconUrl if the "tabs" permission has not been requested.\n     */\n    export function update(updateProperties: UpdateProperties, callback?: (tab?: Tab) => void): void;\n    /**\n     * Modifies the properties of a tab. Properties that are not specified in updateProperties are not modified.\n     * @param tabId Defaults to the selected tab of the current window.\n     * @param callback Optional.\n     * Optional parameter tab: Details about the updated tab. The tabs.Tab object doesn\'t contain url, title and favIconUrl if the "tabs" permission has not been requested.\n     */\n    export function update(tabId: number, updateProperties: UpdateProperties, callback?: (tab?: Tab) => void): void;\n    /**\n     * Closes a tab.\n     * @param tabId The tab to close.\n     */\n    export function remove(tabId: number, callback?: Function): void;\n    /**\n     * Closes several tabs.\n     * @param tabIds The list of tabs to close.\n     */\n    export function remove(tabIds: number[], callback?: Function): void;\n    /**\n     * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.\n     * @param callback\n     * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the \'src\' property of an HTML Image element for display.\n     */\n    export function captureVisibleTab(callback: (dataUrl: string) => void): void;\n    /**\n     * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.\n     * @param windowId Optional. The target window. Defaults to the current window.\n     * @param callback\n     * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the \'src\' property of an HTML Image element for display.\n     */\n    export function captureVisibleTab(windowId: number, callback: (dataUrl: string) => void): void;\n    /**\n     * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.\n     * @param options Optional. Details about the format and quality of an image.\n     * @param callback\n     * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the \'src\' property of an HTML Image element for display.\n     */\n    export function captureVisibleTab(options: CaptureVisibleTabOptions, callback: (dataUrl: string) => void): void;\n    /**\n     * Captures the visible area of the currently active tab in the specified window. You must have <all_urls> permission to use this method.\n     * @param windowId Optional. The target window. Defaults to the current window.\n     * @param options Optional. Details about the format and quality of an image.\n     * @param callback\n     * Parameter dataUrl: A data URL which encodes an image of the visible area of the captured tab. May be assigned to the \'src\' property of an HTML Image element for display.\n     */\n    export function captureVisibleTab(windowId: number, options: CaptureVisibleTabOptions, callback: (dataUrl: string) => void): void;\n    /**\n     * Reload a tab.\n     * @since Chrome 16.\n     * @param tabId The ID of the tab to reload; defaults to the selected tab of the current window.\n     */\n    export function reload(tabId: number, reloadProperties?: ReloadProperties, callback?: () => void): void;\n    /**\n     * Reload the selected tab of the current window.\n     * @since Chrome 16.\n     */\n    export function reload(reloadProperties: ReloadProperties, callback?: () => void): void;\n    /**\n     * Reload the selected tab of the current window.\n      * @since Chrome 16.\n     */\n    export function reload(callback?: () => void): void;\n    /**\n     * Duplicates a tab.\n     * @since Chrome 23.\n     * @param tabId The ID of the tab which is to be duplicated.\n     * @param callback Optional.\n     * Optional parameter tab: Details about the duplicated tab. The tabs.Tab object doesn\'t contain url, title and favIconUrl if the "tabs" permission has not been requested.\n     */\n    export function duplicate(tabId: number, callback?: (tab?: Tab) => void): void;\n    /**\n     * Sends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage event is fired in each content script running in the specified tab for the current extension.\n     * @since Chrome 20.\n     */\n    export function sendMessage(tabId: number, message: any, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single message to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The runtime.onMessage event is fired in each content script running in the specified tab for the current extension.\n     * @since Chrome 41.\n     * @param responseCallback Optional.\n     * Parameter response: The JSON response object sent by the handler of the message. If an error occurs while connecting to the specified tab, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendMessage(tabId: number, message: any, options: MessageSendOptions, responseCallback?: (response: any) => void): void;\n    /**\n     * Sends a single request to the content script(s) in the specified tab, with an optional callback to run when a response is sent back. The extension.onRequest event is fired in each content script running in the specified tab for the current extension.\n     * @deprecated since Chrome 33. Please use runtime.sendMessage.\n     * @param responseCallback Optional.\n     * Parameter response: The JSON response object sent by the handler of the request. If an error occurs while connecting to the specified tab, the callback will be called with no arguments and runtime.lastError will be set to the error message.\n     */\n    export function sendRequest(tabId: number, request: any, responseCallback?: (response: any) => void): void;\n    /** Connects to the content script(s) in the specified tab. The runtime.onConnect event is fired in each content script running in the specified tab for the current extension. */\n    export function connect(tabId: number, connectInfo?: ConnectInfo): runtime.Port;\n    /**\n     * Injects CSS into a page. For details, see the programmatic injection section of the content scripts doc.\n     * @param details Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\n     * @param callback Optional. Called when all the CSS has been inserted.\n     */\n    export function insertCSS(details: InjectDetails, callback?: Function): void;\n    /**\n     * Injects CSS into a page. For details, see the programmatic injection section of the content scripts doc.\n     * @param tabId Optional. The ID of the tab in which to insert the CSS; defaults to the active tab of the current window.\n     * @param details Details of the script or CSS to inject. Either the code or the file property must be set, but both may not be set at the same time.\n     * @param callback Optional. Called when all the CSS has been inserted.\n     */\n    export function insertCSS(tabId: number, details: InjectDetails, callback?: Function): void;\n    /**\n     * Highlights the given tabs.\n     * @since Chrome 16.\n     * @param callback Optional.\n     * Parameter window: Contains details about the window whose tabs were highlighted.\n     */\n    export function highlight(highlightInfo: HighlightInfo, callback?: (window: chrome.windows.Window) => void): void;\n    /**\n     * Gets all tabs that have the specified properties, or all tabs if no properties are specified.\n     * @since Chrome 16.\n     */\n    export function query(queryInfo: QueryInfo, callback: (result: Tab[]) => void): void;\n    /**\n     * Detects the primary language of the content in a tab.\n     * @param callback\n     * Parameter language: An ISO language code such as en or fr. For a complete list of languages supported by this method, see kLanguageInfoTable. The 2nd to 4th columns will be checked and the first non-NULL value will be returned except for Simplified Chinese for which zh-CN will be returned. For an unknown language, und will be returned.\n     */\n    export function detectLanguage(callback: (language: string) => void): void;\n    /**\n     * Detects the primary language of the content in a tab.\n     * @param tabId Optional. Defaults to the active tab of the current window.\n     * @param callback\n     * Parameter language: An ISO language code such as en or fr. For a complete list of languages supported by this method, see kLanguageInfoTable. The 2nd to 4th columns will be checked and the first non-NULL value will be returned except for Simplified Chinese for which zh-CN will be returned. For an unknown language, und will be returned.\n     */\n    export function detectLanguage(tabId: number, callback: (language: string) => void): void;\n    /**\n     * Zooms a specified tab.\n     * @since Chrome 42.\n     * @param zoomFactor The new zoom factor. Use a value of 0 here to set the tab to its current default zoom factor. Values greater than zero specify a (possibly non-default) zoom factor for the tab.\n     * @param callback Optional. Called after the zoom factor has been changed.\n     */\n    export function setZoom(zoomFactor: number, callback?: () => void): void;\n    /**\n     * Zooms a specified tab.\n     * @since Chrome 42.\n     * @param tabId Optional. The ID of the tab to zoom; defaults to the active tab of the current window.\n     * @param zoomFactor The new zoom factor. Use a value of 0 here to set the tab to its current default zoom factor. Values greater than zero specify a (possibly non-default) zoom factor for the tab.\n     * @param callback Optional. Called after the zoom factor has been changed.\n     */\n    export function setZoom(tabId: number, zoomFactor: number, callback?: () => void): void;\n    /**\n     * Gets the current zoom factor of a specified tab.\n     * @since Chrome 42.\n     * @param callback Called with the tab\'s current zoom factor after it has been fetched.\n     * Parameter zoomFactor: The tab\'s current zoom factor.\n     */\n    export function getZoom(callback: (zoomFactor: number) => void): void;\n    /**\n     * Gets the current zoom factor of a specified tab.\n     * @since Chrome 42.\n     * @param tabId Optional. The ID of the tab to get the current zoom factor from; defaults to the active tab of the current window.\n     * @param callback Called with the tab\'s current zoom factor after it has been fetched.\n     * Parameter zoomFactor: The tab\'s current zoom factor.\n     */\n    export function getZoom(tabId: number, callback: (zoomFactor: number) => void): void;\n    /**\n     * Sets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.\n     * @since Chrome 42.\n     * @param zoomSettings Defines how zoom changes are handled and at what scope.\n     * @param callback Optional. Called after the zoom settings have been changed.\n     */\n    export function setZoomSettings(zoomSettings: ZoomSettings, callback?: () => void): void;\n    /**\n     * Sets the zoom settings for a specified tab, which define how zoom changes are handled. These settings are reset to defaults upon navigating the tab.\n     * @since Chrome 42.\n     * @param tabId Optional. The ID of the tab to change the zoom settings for; defaults to the active tab of the current window.\n     * @param zoomSettings Defines how zoom changes are handled and at what scope.\n     * @param callback Optional. Called after the zoom settings have been changed.\n     */\n    export function setZoomSettings(tabId: number, zoomSettings: ZoomSettings, callback?: () => void): void;\n    /**\n     * Gets the current zoom settings of a specified tab.\n     * @since Chrome 42.\n     * @param callback Called with the tab\'s current zoom settings.\n     * Paramater zoomSettings: The tab\'s current zoom settings.\n     */\n    export function getZoomSettings(callback: (zoomSettings: ZoomSettings) => void): void;\n    /**\n     * Gets the current zoom settings of a specified tab.\n     * @since Chrome 42.\n     * @param tabId Optional. The ID of the tab to get the current zoom settings from; defaults to the active tab of the current window.\n     * @param callback Called with the tab\'s current zoom settings.\n     * Paramater zoomSettings: The tab\'s current zoom settings.\n     */\n    export function getZoomSettings(tabId: number, callback: (zoomSettings: ZoomSettings) => void): void;\n    /**\n     * Discards a tab from memory. Discarded tabs are still visible on the tab strip and are reloaded when activated.\n     * @since Chrome 54.\n     * @param tabId Optional. The ID of the tab to be discarded. If specified, the tab will be discarded unless it\'s active or already discarded. If omitted, the browser will discard the least important tab. This can fail if no discardable tabs exist.\n     * @param callback Called after the operation is completed.\n     */\n    export function discard(tabId: number, callback: (tab: Tab) => void): void;\n\n    /**\n     * Fired when the highlighted or selected tabs in a window changes.\n     * @since Chrome 18.\n     */\n    export var onHighlighted: TabHighlightedEvent;\n    /** Fired when a tab is closed. */\n    export var onRemoved: TabRemovedEvent;\n    /** Fired when a tab is updated. */\n    export var onUpdated: TabUpdatedEvent;\n    /** Fired when a tab is attached to a window, for example because it was moved between windows. */\n    export var onAttached: TabAttachedEvent;\n    /**\n     * Fired when a tab is moved within a window. Only one move event is fired, representing the tab the user directly moved. Move events are not fired for the other tabs that must move in response. This event is not fired when a tab is moved between windows. For that, see tabs.onDetached.\n     */\n    export var onMoved: TabMovedEvent;\n    /** Fired when a tab is detached from a window, for example because it is being moved between windows. */\n    export var onDetached: TabDetachedEvent;\n    /** Fired when a tab is created. Note that the tab\'s URL may not be set at the time this event fired, but you can listen to onUpdated events to be notified when a URL is set. */\n    export var onCreated: TabCreatedEvent;\n    /**\n     * Fires when the active tab in a window changes. Note that the tab\'s URL may not be set at the time this event fired, but you can listen to onUpdated events to be notified when a URL is set.\n     * @since Chrome 18.\n     */\n    export var onActivated: TabActivatedEvent;\n    /**\n     * Fired when a tab is replaced with another tab due to prerendering or instant.\n     * @since Chrome 26.\n     */\n    export var onReplaced: TabReplacedEvent;\n    /**\n     * @deprecated since Chrome 33. Please use tabs.onActivated.\n     * Fires when the selected tab in a window changes.\n     */\n    export var onSelectionChanged: TabSelectedEvent;\n    /**\n     * @deprecated since Chrome 33. Please use tabs.onActivated.\n     * Fires when the selected tab in a window changes. Note that the tab\'s URL may not be set at the time this event fired, but you can listen to tabs.onUpdated events to be notified when a URL is set.\n     */\n    export var onActiveChanged: TabSelectedEvent;\n    /**\n     * @deprecated since Chrome 33. Please use tabs.onHighlighted.\n     * Fired when the highlighted or selected tabs in a window changes.\n     */\n    export var onHighlightChanged: TabHighlightedEvent;\n    /**\n     * Fired when a tab is zoomed.\n     * @since Chrome 38.\n     */\n    export var onZoomChange: TabZoomChangeEvent;\n\n    /**\n     * An ID which represents the absence of a browser tab.\n     * @since Chrome 46.\n     */\n    export var TAB_ID_NONE: -1;\n}\n\n////////////////////\n// Top Sites\n////////////////////\n/**\n * Use the chrome.topSites API to access the top sites that are displayed on the new tab page.\n * Permissions:  "topSites"\n * @since Chrome 19.\n */\ndeclare namespace chrome.topSites {\n    /** An object encapsulating a most visited URL, such as the URLs on the new tab page. */\n    export interface MostVisitedURL {\n        /** The most visited URL. */\n        url: string;\n        /** The title of the page */\n        title: string;\n    }\n\n    /** Gets a list of top sites. */\n    export function get(callback: (data: MostVisitedURL[]) => void): void;\n}\n\n////////////////////\n// Text to Speech\n////////////////////\n/**\n * Use the chrome.tts API to play synthesized text-to-speech (TTS). See also the related ttsEngine API, which allows an extension to implement a speech engine.\n * Permissions:  "tts"\n * @since Chrome 14.\n */\ndeclare namespace chrome.tts {\n    /** An event from the TTS engine to communicate the status of an utterance. */\n    export interface TtsEvent {\n        /** Optional. The index of the current character in the utterance. */\n        charIndex?: number;\n        /** Optional. The error description, if the event type is \'error\'. */\n        errorMessage?: string;\n        /**\n         * The type can be \'start\' as soon as speech has started, \'word\' when a word boundary is reached, \'sentence\' when a sentence boundary is reached, \'marker\' when an SSML mark element is reached, \'end\' when the end of the utterance is reached, \'interrupted\' when the utterance is stopped or interrupted before reaching the end, \'cancelled\' when it\'s removed from the queue before ever being synthesized, or \'error\' when any other error occurs. When pausing speech, a \'pause\' event is fired if a particular utterance is paused in the middle, and \'resume\' if an utterance resumes speech. Note that pause and resume events may not fire if speech is paused in-between utterances.\n         * One of: "start", "end", "word", "sentence", "marker", "interrupted", "cancelled", "error", "pause", or "resume"\n         */\n        type: string;\n    }\n\n    /** A description of a voice available for speech synthesis. */\n    export interface TtsVoice {\n        /** Optional. The language that this voice supports, in the form language-region. Examples: \'en\', \'en-US\', \'en-GB\', \'zh-CN\'. */\n        lang?: string;\n        /**\n         * Optional. This voice\'s gender.\n         * One of: "male", or "female"\n         */\n        gender?: string;\n        /** Optional. The name of the voice. */\n        voiceName?: string;\n        /** The ID of the extension providing this voice. */\n        extensionsId?: string;\n        /** All of the callback event types that this voice is capable of sending. */\n        eventTypes?: string[];\n        /**\n         * If true, the synthesis engine is a remote network resource. It may be higher latency and may incur bandwidth costs.\n         * @since Chrome 33.\n         */\n        remote?: boolean;\n    }\n\n    export interface SpeakOptions {\n        /** Optional. Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0. */\n        volume?: number;\n        /**\n         * Optional.\n         * If true, enqueues this utterance if TTS is already in progress. If false (the default), interrupts any current speech and flushes the speech queue before speaking this new utterance.\n         */\n        enqueue?: boolean;\n        /**\n         * Optional.\n         * Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. Values below 0.1 or above 10.0 are strictly disallowed, but many voices will constrain the minimum and maximum rates further\u2014for example a particular voice may not actually speak faster than 3 times normal even if you specify a value larger than 3.0.\n         */\n        rate?: number;\n        /**\n         * Optional. This function is called with events that occur in the process of speaking the utterance.\n         * @param event The update event from the text-to-speech engine indicating the status of this utterance.\n         */\n        onEvent?: (event: TtsEvent) => void;\n        /**\n         * Optional.\n         * Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to a voice\'s default pitch.\n         */\n        pitch?: number;\n        /** Optional. The language to be used for synthesis, in the form language-region. Examples: \'en\', \'en-US\', \'en-GB\', \'zh-CN\'. */\n        lang?: string;\n        /** Optional. The name of the voice to use for synthesis. If empty, uses any available voice. */\n        voiceName?: string;\n        /** Optional. The extension ID of the speech engine to use, if known. */\n        extensionId?: string;\n        /**\n         * Optional. Gender of voice for synthesized speech.\n         * One of: "male", or "female"\n         */\n        gender?: string;\n        /** Optional. The TTS event types the voice must support. */\n        requiredEventTypes?: string[];\n        /** Optional. The TTS event types that you are interested in listening to. If missing, all event types may be sent. */\n        desiredEventTypes?: string[];\n    }\n\n    /** Checks whether the engine is currently speaking. On Mac OS X, the result is true whenever the system speech engine is speaking, even if the speech wasn\'t initiated by Chrome. */\n    export function isSpeaking(callback?: (speaking: boolean) => void): void;\n    /** Stops any current speech and flushes the queue of any pending utterances. In addition, if speech was paused, it will now be un-paused for the next call to speak. */\n    export function stop(): void;\n    /** Gets an array of all available voices. */\n    export function getVoices(callback?: (voices: TtsVoice[]) => void): void;\n    /**\n     * Speaks text using a text-to-speech engine.\n     * @param utterance The text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.\n     * @param callback Optional. Called right away, before speech finishes. Check chrome.runtime.lastError to make sure there were no errors. Use options.onEvent to get more detailed feedback.\n     */\n    export function speak(utterance: string, callback?: Function): void;\n    /**\n     * Speaks text using a text-to-speech engine.\n     * @param utterance The text to speak, either plain text or a complete, well-formed SSML document. Speech engines that do not support SSML will strip away the tags and speak the text. The maximum length of the text is 32,768 characters.\n     * @param options Optional. The speech options.\n     * @param callback Optional. Called right away, before speech finishes. Check chrome.runtime.lastError to make sure there were no errors. Use options.onEvent to get more detailed feedback.\n     */\n    export function speak(utterance: string, options: SpeakOptions, callback?: Function): void;\n    /**\n     * Pauses speech synthesis, potentially in the middle of an utterance. A call to resume or stop will un-pause speech.\n     * @since Chrome 29.\n     */\n    export function pause(): void;\n    /**\n     * If speech was paused, resumes speaking where it left off.\n     * @since Chrome 29.\n     */\n    export function resume(): void;\n}\n\n////////////////////\n// Text to Speech Engine\n////////////////////\n/**\n * Use the chrome.ttsEngine API to implement a text-to-speech(TTS) engine using an extension. If your extension registers using this API, it will receive events containing an utterance to be spoken and other parameters when any extension or Chrome App uses the tts API to generate speech. Your extension can then use any available web technology to synthesize and output the speech, and send events back to the calling function to report the status.\n * Permissions:  "ttsEngine"\n * @since Chrome 14.\n */\ndeclare namespace chrome.ttsEngine {\n    export interface SpeakOptions {\n        /** Optional. The language to be used for synthesis, in the form language-region. Examples: \'en\', \'en-US\', \'en-GB\', \'zh-CN\'. */\n        lang?: string;\n        /** Optional. The name of the voice to use for synthesis. */\n        voiceName?: string;\n        /**\n         * Optional. Gender of voice for synthesized speech.\n         * One of: "male", or "female"\n         */\n        gender?: string;\n        /** Optional. Speaking volume between 0 and 1 inclusive, with 0 being lowest and 1 being highest, with a default of 1.0. */\n        volume?: number;\n        /**\n         * Optional.\n         * Speaking rate relative to the default rate for this voice. 1.0 is the default rate, normally around 180 to 220 words per minute. 2.0 is twice as fast, and 0.5 is half as fast. This value is guaranteed to be between 0.1 and 10.0, inclusive. When a voice does not support this full range of rates, don\'t return an error. Instead, clip the rate to the range the voice supports.\n         */\n        rate?: number;\n        /** Optional. Speaking pitch between 0 and 2 inclusive, with 0 being lowest and 2 being highest. 1.0 corresponds to this voice\'s default pitch. */\n        pitch?: number;\n    }\n\n    export interface TtsEngineSpeakEvent extends chrome.events.Event<(utterance: string, options: SpeakOptions, sendTtsEvent: (event: chrome.tts.TtsEvent) => void) => void> { }\n\n    /** Called when the user makes a call to tts.speak() and one of the voices from this extension\'s manifest is the first to match the options object. */\n    export var onSpeak: TtsEngineSpeakEvent;\n    /** Fired when a call is made to tts.stop and this extension may be in the middle of speaking. If an extension receives a call to onStop and speech is already stopped, it should do nothing (not raise an error). If speech is in the paused state, this should cancel the paused state. */\n    export var onStop: chrome.events.Event<() => void>;\n    /**\n     * Optional: if an engine supports the pause event, it should pause the current utterance being spoken, if any, until it receives a resume event or stop event. Note that a stop event should also clear the paused state.\n     * @since Chrome 29.\n     */\n    export var onPause: chrome.events.Event<() => void>;\n    /**\n     * Optional: if an engine supports the pause event, it should also support the resume event, to continue speaking the current utterance, if any. Note that a stop event should also clear the paused state.\n     * @since Chrome 29.\n     */\n    export var onResume: chrome.events.Event<() => void>;\n}\n\n////////////////////\n// Types\n////////////////////\n/**\n * The chrome.types API contains type declarations for Chrome.\n * @since Chrome 13.\n */\ndeclare namespace chrome.types {\n    export interface ChromeSettingClearDetails {\n        /**\n         * Optional.\n         * The scope of the ChromeSetting. One of\n         * \u2022 regular: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n         * \u2022 regular_only: setting for the regular profile only (not inherited by the incognito profile),\n         * \u2022 incognito_persistent: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n         * \u2022 incognito_session_only: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n         */\n        scope?: string;\n    }\n\n    export interface ChromeSettingSetDetails extends ChromeSettingClearDetails {\n        /**\n         * The value of the setting.\n         * Note that every setting has a specific value type, which is described together with the setting. An extension should not set a value of a different type.\n         */\n        value: any;\n        /**\n         * Optional.\n         * The scope of the ChromeSetting. One of\n         * \u2022 regular: setting for the regular profile (which is inherited by the incognito profile if not overridden elsewhere),\n         * \u2022 regular_only: setting for the regular profile only (not inherited by the incognito profile),\n         * \u2022 incognito_persistent: setting for the incognito profile that survives browser restarts (overrides regular preferences),\n         * \u2022 incognito_session_only: setting for the incognito profile that can only be set during an incognito session and is deleted when the incognito session ends (overrides regular and incognito_persistent preferences).\n         */\n        scope?: string;\n    }\n\n    export interface ChromeSettingGetDetails {\n        /** Optional. Whether to return the value that applies to the incognito session (default false). */\n        incognito?: boolean;\n    }\n\n    /**\n     * @param details Details of the currently effective value.\n     */\n    export type DetailsCallback = (details: ChromeSettingGetResultDetails) => void;\n\n    export interface ChromeSettingGetResultDetails {\n        /**\n         * One of\n         * \u2022 not_controllable: cannot be controlled by any extension\n         * \u2022 controlled_by_other_extensions: controlled by extensions with higher precedence\n         * \u2022 controllable_by_this_extension: can be controlled by this extension\n         * \u2022 controlled_by_this_extension: controlled by this extension\n         */\n        levelOfControl: string;\n        /** The value of the setting. */\n        value: any;\n        /**\n         * Optional.\n         * Whether the effective value is specific to the incognito session.\n         * This property will only be present if the incognito property in the details parameter of get() was true.\n         */\n        incognitoSpecific?: boolean;\n    }\n\n    export interface ChromeSettingChangedEvent extends chrome.events.Event<DetailsCallback> { }\n\n    /** An interface that allows access to a Chrome browser setting. See accessibilityFeatures for an example. */\n    export interface ChromeSetting {\n        /**\n         * Sets the value of a setting.\n         * @param details Which setting to change.\n         * @param callback Optional. Called at the completion of the set operation.\n         */\n        set(details: ChromeSettingSetDetails, callback?: Function): void;\n        /**\n         * Gets the value of a setting.\n         * @param details Which setting to consider.\n         */\n        get(details: ChromeSettingGetDetails, callback?: DetailsCallback): void;\n        /**\n         * Clears the setting, restoring any default value.\n         * @param details Which setting to clear.\n         * @param callback Optional. Called at the completion of the clear operation.\n         */\n        clear(details: ChromeSettingClearDetails, callback?: Function): void;\n        /** Fired after the setting changes. */\n        onChange: ChromeSettingChangedEvent;\n    }\n}\n\n////////////////////\n// VPN Provider\n////////////////////\n/**\n * Use the chrome.vpnProvider API to implement a VPN client.\n * Permissions:  "vpnProvider"\n * Important: This API works only on Chrome OS.\n * @since Chrome 43.\n */\ndeclare namespace chrome.vpnProvider {\n    export interface VpnSessionParameters {\n        /** IP address for the VPN interface in CIDR notation. IPv4 is currently the only supported mode. */\n        address: string;\n        /** Optional. Broadcast address for the VPN interface. (default: deduced from IP address and mask) */\n        broadcastAddress?: string;\n        /** Optional. MTU setting for the VPN interface. (default: 1500 bytes) */\n        mtu?: string;\n        /**\n         * Exclude network traffic to the list of IP blocks in CIDR notation from the tunnel. This can be used to bypass traffic to and from the VPN server. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n         */\n        exclusionList: string[];\n        /**\n         * Include network traffic to the list of IP blocks in CIDR notation to the tunnel. This parameter can be used to set up a split tunnel. By default no traffic is directed to the tunnel. Adding the entry "0.0.0.0/0" to this list gets all the user traffic redirected to the tunnel. When many rules match a destination, the rule with the longest matching prefix wins. Entries that correspond to the same CIDR block are treated as duplicates. Such duplicates in the collated (exclusionList + inclusionList) list are eliminated and the exact duplicate entry that will be eliminated is undefined.\n         */\n        inclusionList: string[];\n        /** Optional. A list of search domains. (default: no search domain) */\n        domainSearch?: string[];\n        /** A list of IPs for the DNS servers. */\n        dnsServer: string[];\n    }\n\n    export interface VpnPlatformMessageEvent extends chrome.events.Event<(id: string, message: string, error: string) => void> { }\n\n    export interface VpnPacketReceptionEvent extends chrome.events.Event<(data: ArrayBuffer) => void> { }\n\n    export interface VpnConfigRemovalEvent extends chrome.events.Event<(id: string) => void> { }\n\n    export interface VpnConfigCreationEvent extends chrome.events.Event<(id: string, name: string, data: Object) => void> { }\n\n    export interface VpnUiEvent extends chrome.events.Event<(event: string, id?: string) => void> { }\n\n    /**\n     * Creates a new VPN configuration that persists across multiple login sessions of the user.\n     * @param name The name of the VPN configuration.\n     * @param callback Called when the configuration is created or if there is an error.\n     * Parameter id: A unique ID for the created configuration, empty string on failure.\n     */\n    export function createConfig(name: string, callback: (id: string) => void): void;\n    /**\n     * Destroys a VPN configuration created by the extension.\n     * @param id ID of the VPN configuration to destroy.\n     * @param callback Optional. Called when the configuration is destroyed or if there is an error.\n     */\n    export function destroyConfig(id: string, callback?: Function): void;\n    /**\n     * Sets the parameters for the VPN session. This should be called immediately after "connected" is received from the platform. This will succeed only when the VPN session is owned by the extension.\n     * @param parameters The parameters for the VPN session.\n     * @param callback Called when the parameters are set or if there is an error.\n     */\n    export function setParameters(parameters: VpnSessionParameters, callback: Function): void;\n    /**\n     * Sends an IP packet through the tunnel created for the VPN session. This will succeed only when the VPN session is owned by the extension.\n     * @param data The IP packet to be sent to the platform.\n     * @param callback Optional. Called when the packet is sent or if there is an error.\n     */\n    export function sendPacket(data: ArrayBuffer, callback?: Function): void;\n    /**\n     * Notifies the VPN session state to the platform. This will succeed only when the VPN session is owned by the extension.\n     * @param state The VPN session state of the VPN client.\n     * connected: VPN connection was successful.\n     * failure: VPN connection failed.\n     * @param callback Optional. Called when the notification is complete or if there is an error.\n     */\n    export function notifyConnectionStateChanged(state: string, callback?: Function): void;\n\n    /** Triggered when a message is received from the platform for a VPN configuration owned by the extension. */\n    export var onPlatformMessage: VpnPlatformMessageEvent;\n    /** Triggered when an IP packet is received via the tunnel for the VPN session owned by the extension. */\n    export var onPacketReceived: VpnPacketReceptionEvent;\n    /** Triggered when a configuration created by the extension is removed by the platform. */\n    export var onConfigRemoved: VpnConfigRemovalEvent;\n    /** Triggered when a configuration is created by the platform for the extension. */\n    export var onConfigCreated: VpnConfigCreationEvent;\n    /** Triggered when there is a UI event for the extension. UI events are signals from the platform that indicate to the app that a UI dialog needs to be shown to the user. */\n    export var onUIEvent: VpnUiEvent;\n}\n\n////////////////////\n// Wallpaper\n////////////////////\n/**\n * Use the chrome.wallpaper API to change the ChromeOS wallpaper.\n * Permissions:  "wallpaper"\n * Important: This API works only on Chrome OS.\n * @since Chrome 43.\n */\ndeclare namespace chrome.wallpaper {\n    export interface WallpaperDetails {\n        /** Optional. The jpeg or png encoded wallpaper image. */\n        data?: any;\n        /** Optional. The URL of the wallpaper to be set. */\n        url?: string;\n        /**\n         * The supported wallpaper layouts.\n         * One of: "STRETCH", "CENTER", or "CENTER_CROPPED"\n         */\n        layout: string;\n        /** The file name of the saved wallpaper. */\n        filename: string;\n        /** Optional. True if a 128x60 thumbnail should be generated. */\n        thumbnail?: boolean;\n    }\n\n    /**\n     * Sets wallpaper to the image at url or wallpaperData with the specified layout\n     * @param callback\n     * Optional parameter thumbnail: The jpeg encoded wallpaper thumbnail. It is generated by resizing the wallpaper to 128x60.\n     */\n    export function setWallpaper(details: WallpaperDetails, callback: (thumbnail: any) => void): void;\n}\n\n////////////////////\n// Web Navigation\n////////////////////\n/**\n * Use the chrome.webNavigation API to receive notifications about the status of navigation requests in-flight.\n * Permissions:  "webNavigation"\n * @since Chrome 16.\n */\ndeclare namespace chrome.webNavigation {\n    export interface GetFrameDetails {\n        /**\n         * The ID of the process runs the renderer for this tab.\n         * @since Chrome 22.\n         * @deprecated since Chrome 49. Frames are now uniquely identified by their tab ID and frame ID; the process ID is no longer needed and therefore ignored.\n         */\n        processId?: number;\n        /** The ID of the tab in which the frame is. */\n        tabId: number;\n        /** The ID of the frame in the given tab. */\n        frameId: number;\n    }\n\n    export interface GetFrameResultDetails {\n        /** The URL currently associated with this frame, if the frame identified by the frameId existed at one point in the given tab. The fact that an URL is associated with a given frameId does not imply that the corresponding frame still exists. */\n        url: string;\n        /** True if the last navigation in this frame was interrupted by an error, i.e. the onErrorOccurred event fired. */\n        errorOccurred: boolean;\n        /** ID of frame that wraps the frame. Set to -1 of no parent frame exists. */\n        parentFrameId: number;\n    }\n\n    export interface GetAllFrameDetails {\n        /** The ID of the tab. */\n        tabId: number;\n    }\n\n    export interface GetAllFrameResultDetails extends GetFrameResultDetails {\n        /** The ID of the process runs the renderer for this tab. */\n        processId: number;\n        /** The ID of the frame. 0 indicates that this is the main frame; a positive value indicates the ID of a subframe. */\n        frameId: number;\n    }\n\n    export interface WebNavigationCallbackDetails {\n        /** The ID of the tab in which the navigation is about to occur. */\n        tabId: number;\n        /** The time when the browser was about to start the navigation, in milliseconds since the epoch. */\n        timeStamp: number;\n    }\n\n    export interface WebNavigationUrlCallbackDetails extends WebNavigationCallbackDetails {\n        url: string;\n    }\n\n    export interface WebNavigationReplacementCallbackDetails extends WebNavigationCallbackDetails {\n        /** The ID of the tab that was replaced. */\n        replacedTabId: number;\n    }\n\n    export interface WebNavigationFramedCallbackDetails extends WebNavigationUrlCallbackDetails {\n        /** 0 indicates the navigation happens in the tab content window; a positive value indicates navigation in a subframe. Frame IDs are unique for a given tab and process. */\n        frameId: number;\n        /**\n         * The ID of the process runs the renderer for this tab.\n         * @since Chrome 22.\n         */\n        processId: number;\n    }\n\n    export interface WebNavigationFramedErrorCallbackDetails extends WebNavigationFramedCallbackDetails {\n        /** The error description. */\n        error: string;\n    }\n\n    export interface WebNavigationSourceCallbackDetails extends WebNavigationUrlCallbackDetails {\n        /** The ID of the tab in which the navigation is triggered. */\n        sourceTabId: number;\n        /**\n         * The ID of the process runs the renderer for the source tab.\n         * @since Chrome 22.\n         */\n        sourceProcessId: number;\n        /** The ID of the frame with sourceTabId in which the navigation is triggered. 0 indicates the main frame. */\n        sourceFrameId: number;\n    }\n\n    export interface WebNavigationParentedCallbackDetails extends WebNavigationFramedCallbackDetails {\n        /**\n         * ID of frame that wraps the frame. Set to -1 of no parent frame exists.\n         * @since Chrome 24.\n         */\n        parentFrameId: number;\n    }\n\n    export interface WebNavigationTransitionCallbackDetails extends WebNavigationFramedCallbackDetails {\n        /**\n         * Cause of the navigation.\n         * One of: "link", "typed", "auto_bookmark", "auto_subframe", "manual_subframe", "generated", "start_page", "form_submit", "reload", "keyword", or "keyword_generated"\n         */\n        transitionType: string;\n        /**\n         * A list of transition qualifiers.\n         * Each element one of: "client_redirect", "server_redirect", "forward_back", or "from_address_bar"\n         */\n        transitionQualifiers: string[];\n    }\n\n    export interface WebNavigationEventFilter {\n        /** Conditions that the URL being navigated to must satisfy. The \'schemes\' and \'ports\' fields of UrlFilter are ignored for this event. */\n        url: chrome.events.UrlFilter[];\n    }\n\n    export interface WebNavigationEvent<T extends WebNavigationCallbackDetails> extends chrome.events.Event<(details: T) => void> {\n        addListener(callback: (details: T) => void, filters?: WebNavigationEventFilter): void;\n    }\n\n    export interface WebNavigationFramedEvent extends WebNavigationEvent<WebNavigationFramedCallbackDetails> { }\n\n    export interface WebNavigationFramedErrorEvent extends WebNavigationEvent<WebNavigationFramedErrorCallbackDetails> { }\n\n    export interface WebNavigationSourceEvent extends WebNavigationEvent<WebNavigationSourceCallbackDetails> { }\n\n    export interface WebNavigationParentedEvent extends WebNavigationEvent<WebNavigationParentedCallbackDetails> { }\n\n    export interface WebNavigationTransitionalEvent extends WebNavigationEvent<WebNavigationTransitionCallbackDetails> { }\n\n    export interface WebNavigationReplacementEvent extends WebNavigationEvent<WebNavigationReplacementCallbackDetails> { }\n\n    /**\n     * Retrieves information about the given frame. A frame refers to an <iframe> or a <frame> of a web page and is identified by a tab ID and a frame ID.\n     * @param details Information about the frame to retrieve information about.\n     * @param callback\n     * Optional parameter details: Information about the requested frame, null if the specified frame ID and/or tab ID are invalid.\n     */\n    export function getFrame(details: GetFrameDetails, callback: (details: GetFrameResultDetails | null) => void): void;\n    /**\n     * Retrieves information about all frames of a given tab.\n     * @param details Information about the tab to retrieve all frames from.\n     * @param callback\n     * Optional parameter details: A list of frames in the given tab, null if the specified tab ID is invalid.\n     */\n    export function getAllFrames(details: GetAllFrameDetails, callback: (details: GetAllFrameResultDetails[] | null) => void): void;\n\n    /** Fired when the reference fragment of a frame was updated. All future events for that frame will use the updated URL. */\n    export var onReferenceFragmentUpdated: WebNavigationTransitionalEvent;\n    /** Fired when a document, including the resources it refers to, is completely loaded and initialized. */\n    export var onCompleted: WebNavigationFramedEvent;\n    /**\n     * Fired when the frame\'s history was updated to a new URL. All future events for that frame will use the updated URL.\n     * @since Chrome 22.\n     */\n    export var onHistoryStateUpdated: WebNavigationTransitionalEvent;\n    /** Fired when a new window, or a new tab in an existing window, is created to host a navigation. */\n    export var onCreatedNavigationTarget: WebNavigationSourceEvent;\n    /**\n     * Fired when the contents of the tab is replaced by a different (usually previously pre-rendered) tab.\n     * @since Chrome 22.\n     */\n    export var onTabReplaced: WebNavigationReplacementEvent;\n    /** Fired when a navigation is about to occur. */\n    export var onBeforeNavigate: WebNavigationParentedEvent;\n    /** Fired when a navigation is committed. The document (and the resources it refers to, such as images and subframes) might still be downloading, but at least part of the document has been received from the server and the browser has decided to switch to the new document. */\n    export var onCommitted: WebNavigationTransitionalEvent;\n    /** Fired when the page\'s DOM is fully constructed, but the referenced resources may not finish loading. */\n    export var onDOMContentLoaded: WebNavigationFramedEvent;\n    /** Fired when an error occurs and the navigation is aborted. This can happen if either a network error occurred, or the user aborted the navigation. */\n    export var onErrorOccurred: WebNavigationFramedErrorEvent;\n}\n\n////////////////////\n// Web Request\n////////////////////\n/**\n * Use the chrome.webRequest API to observe and analyze traffic and to intercept, block, or modify requests in-flight.\n * Permissions:  "webRequest", host permissions\n * @since Chrome 17.\n */\ndeclare namespace chrome.webRequest {\n    /** How the requested resource will be used. */\n    export type ResourceType = "main_frame" | "sub_frame" | "stylesheet" | "script" | "image" | "font" | "object" | "xmlhttprequest" | "ping" | "csp_report" | "media" | "websocket" | "other";\n\n    export interface AuthCredentials {\n        username: string;\n        password: string;\n    }\n\n    /** An HTTP Header, represented as an object containing a key and either a value or a binaryValue. */\n    export interface HttpHeader {\n        name: string;\n        value?: string;\n        binaryValue?: ArrayBuffer;\n    }\n\n    /** Returns value for event handlers that have the \'blocking\' extraInfoSpec applied. Allows the event handler to modify network requests. */\n    export interface BlockingResponse {\n        /** Optional. If true, the request is cancelled. Used in onBeforeRequest, this prevents the request from being sent. */\n        cancel?: boolean;\n        /**\n         * Optional.\n         * Only used as a response to the onBeforeRequest and onHeadersReceived events. If set, the original request is prevented from being sent/completed and is instead redirected to the given URL. Redirections to non-HTTP schemes such as data: are allowed. Redirects initiated by a redirect action use the original request method for the redirect, with one exception: If the redirect is initiated at the onHeadersReceived stage, then the redirect will be issued using the GET method.\n         */\n        redirectUrl?: string;\n        /**\n         * Optional.\n         * Only used as a response to the onHeadersReceived event. If set, the server is assumed to have responded with these response headers instead. Only return responseHeaders if you really want to modify the headers in order to limit the number of conflicts (only one extension may modify responseHeaders for each request).\n         */\n        responseHeaders?: HttpHeader[];\n        /** Optional. Only used as a response to the onAuthRequired event. If set, the request is made using the supplied credentials. */\n        authCredentials?: AuthCredentials;\n        /**\n         * Optional.\n         * Only used as a response to the onBeforeSendHeaders event. If set, the request is made with these request headers instead.\n         */\n        requestHeaders?: HttpHeader[];\n    }\n\n    /** An object describing filters to apply to webRequest events. */\n    export interface RequestFilter {\n        /** Optional. */\n        tabId?: number;\n        /**\n         * A list of request types. Requests that cannot match any of the types will be filtered out.\n         */\n        types?: ResourceType[];\n        /** A list of URLs or URL patterns. Requests that cannot match any of the URLs will be filtered out. */\n        urls: string[];\n\n        /** Optional. */\n        windowId?: number;\n    }\n\n    /**\n     * Contains data uploaded in a URL request.\n     * @since Chrome 23.\n     */\n    export interface UploadData {\n        /** Optional. An ArrayBuffer with a copy of the data. */\n        bytes?: ArrayBuffer;\n        /** Optional. A string with the file\'s path and name. */\n        file?: string;\n    }\n\n    export interface WebRequestBody {\n        /** Optional. Errors when obtaining request body data. */\n        error?: string;\n        /**\n         * Optional.\n         * If the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {\'key\': [\'value1\', \'value2\']}.\n         */\n        formData?: { [key: string]: string[] };\n        /**\n         * Optional.\n         * If the request method is PUT or POST, and the body is not already parsed in formData, then the unparsed request body elements are contained in this array.\n         */\n        raw?: UploadData[];\n    }\n\n    export interface WebAuthChallenger {\n        host: string;\n        port: number;\n    }\n\n    export interface ResourceRequest {\n        url: string;\n        /** The ID of the request. Request IDs are unique within a browser session. As a result, they could be used to relate different events of the same request. */\n        requestId: string;\n        /** The value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (type is main_frame or sub_frame), frameId indicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab. */\n        frameId: number;\n        /** ID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists. */\n        parentFrameId: number;\n        /** The ID of the tab in which the request takes place. Set to -1 if the request isn\'t related to a tab. */\n        tabId: number;\n        /**\n         * How the requested resource will be used.\n         */\n        type: ResourceType;\n        /** The time when this signal is triggered, in milliseconds since the epoch. */\n        timeStamp: number;\n        /** The origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string \'null\' will be used.\n         * @since Since Chrome 63.\n        */\n        initiator?: string;\n    }\n\n    export interface WebRequestDetails extends ResourceRequest {\n        /** Standard HTTP method. */\n        method: string;\n    }\n\n    export interface WebRequestHeadersDetails extends WebRequestDetails {\n        /** Optional. The HTTP request headers that are going to be sent out with this request. */\n        requestHeaders?: HttpHeader[];\n    }\n\n    export interface WebRequestBodyDetails extends WebRequestDetails {\n        /**\n         * Contains the HTTP request body data. Only provided if extraInfoSpec contains \'requestBody\'.\n         * @since Chrome 23.\n         */\n        requestBody: WebRequestBody;\n    }\n\n    export interface WebRequestFullDetails extends WebRequestHeadersDetails, WebRequestBodyDetails {\n    }\n\n    export interface WebResponseDetails extends ResourceRequest {\n        /** HTTP status line of the response or the \'HTTP/0.9 200 OK\' string for HTTP/0.9 responses (i.e., responses that lack a status line). */\n        statusLine: string;\n        /**\n         * Standard HTTP status code returned by the server.\n         * @since Chrome 43.\n         */\n        statusCode: number;\n    }\n\n    export interface WebResponseHeadersDetails extends WebResponseDetails {\n        /** Optional. The HTTP response headers that have been received with this response. */\n        responseHeaders?: HttpHeader[];\n        method: string; /** standard HTTP method i.e. GET, POST, PUT, etc. */\n    }\n\n    export interface WebResponseCacheDetails extends WebResponseHeadersDetails {\n        /**\n         * Optional.\n         * The server IP address that the request was actually sent to. Note that it may be a literal IPv6 address.\n         */\n        ip?: string;\n        /** Indicates if this response was fetched from disk cache. */\n        fromCache: boolean;\n    }\n\n    export interface WebRedirectionResponseDetails extends WebResponseCacheDetails {\n        /** The new URL. */\n        redirectUrl: string;\n    }\n\n    export interface WebAuthenticationChallengeDetails extends WebResponseHeadersDetails {\n        /** The authentication scheme, e.g. Basic or Digest. */\n        scheme: string;\n        /** The authentication realm provided by the server, if there is one. */\n        realm?: string;\n        /** The server requesting authentication. */\n        challenger: WebAuthChallenger;\n        /** True for Proxy-Authenticate, false for WWW-Authenticate. */\n        isProxy: boolean;\n    }\n\n    export interface WebResponseErrorDetails extends WebResponseCacheDetails {\n        /** The error description. This string is not guaranteed to remain backwards compatible between releases. You must not parse and act based upon its content. */\n        error: string;\n    }\n\n    export interface WebRequestBodyEvent extends chrome.events.Event<(details: WebRequestBodyDetails) => void> {\n        addListener(callback: (details: WebRequestBodyDetails) => void, filter?: RequestFilter, opt_extraInfoSpec?: string[]): void;\n    }\n\n    export interface WebRequestHeadersEvent extends chrome.events.Event<(details: WebRequestHeadersDetails) => void> {\n        addListener(callback: (details: WebRequestHeadersDetails) => void, filter?: RequestFilter, opt_extraInfoSpec?: string[]): void;\n    }\n\n    export interface _WebResponseHeadersEvent<T extends WebResponseHeadersDetails> extends chrome.events.Event<(details: T) => void> {\n        addListener(callback: (details: T) => void, filter?: RequestFilter, opt_extraInfoSpec?: string[]): void;\n    }\n\n    export interface WebResponseHeadersEvent extends _WebResponseHeadersEvent<WebResponseHeadersDetails> { }\n\n    export interface WebResponseCacheEvent extends _WebResponseHeadersEvent<WebResponseCacheDetails> { }\n\n    export interface WebRedirectionResponseEvent extends _WebResponseHeadersEvent<WebRedirectionResponseDetails> { }\n\n    export interface WebAuthenticationChallengeEvent extends chrome.events.Event<(details: WebAuthenticationChallengeDetails, callback?: (response: BlockingResponse) => void) => void> {\n        addListener(callback: (details: WebAuthenticationChallengeDetails, callback?: (response: BlockingResponse) => void) => void, filter?: RequestFilter, opt_extraInfoSpec?: string[]): void;\n    }\n\n    export interface WebResponseErrorEvent extends _WebResponseHeadersEvent<WebResponseErrorDetails> { }\n\n    /**\n     * The maximum number of times that handlerBehaviorChanged can be called per 10 minute sustained interval. handlerBehaviorChanged is an expensive function call that shouldn\'t be called often.\n     * @since Chrome 23.\n     */\n    export var MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES: number;\n\n    /** Needs to be called when the behavior of the webRequest handlers has changed to prevent incorrect handling due to caching. This function call is expensive. Don\'t call it often. */\n    export function handlerBehaviorChanged(callback?: Function): void;\n\n    /** Fired when a request is about to occur. */\n    export var onBeforeRequest: WebRequestBodyEvent;\n    /** Fired before sending an HTTP request, once the request headers are available. This may occur after a TCP connection is made to the server, but before any HTTP data is sent. */\n    export var onBeforeSendHeaders: WebRequestHeadersEvent;\n    /** Fired just before a request is going to be sent to the server (modifications of previous onBeforeSendHeaders callbacks are visible by the time onSendHeaders is fired). */\n    export var onSendHeaders: WebRequestHeadersEvent;\n    /** Fired when HTTP response headers of a request have been received. */\n    export var onHeadersReceived: WebResponseHeadersEvent;\n    /** Fired when an authentication failure is received. The listener has three options: it can provide authentication credentials, it can cancel the request and display the error page, or it can take no action on the challenge. If bad user credentials are provided, this may be called multiple times for the same request. */\n    export var onAuthRequired: WebAuthenticationChallengeEvent;\n    /** Fired when the first byte of the response body is received. For HTTP requests, this means that the status line and response headers are available. */\n    export var onResponseStarted: WebResponseCacheEvent;\n    /** Fired when a server-initiated redirect is about to occur. */\n    export var onBeforeRedirect: WebRedirectionResponseEvent;\n    /** Fired when a request is completed. */\n    export var onCompleted: WebResponseCacheEvent;\n    /** Fired when an error occurs. */\n    export var onErrorOccurred: WebResponseErrorEvent;\n}\n\n////////////////////\n// Web Store\n////////////////////\n/**\n * Use the chrome.webstore API to initiate app and extension installations "inline" from your site.\n * @since Chrome 15.\n */\ndeclare namespace chrome.webstore {\n    /**\n     * @param url Optional. If you have more than one <link> tag on your page with the chrome-webstore-item relation, you can choose which item you\'d like to install by passing in its URL here. If it is omitted, then the first (or only) link will be used. An exception will be thrown if the passed in URL does not exist on the page.\n     * @param successCallback Optional. This function is invoked when inline installation successfully completes (after the dialog is shown and the user agrees to add the item to Chrome). You may wish to use this to hide the user interface element that prompted the user to install the app or extension.\n     * @param failureCallback Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.\n     * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.\n     * Optional parameter errorCode: The error code from the stable set of possible errors.\n     * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.\n     * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.\n     * * * "aborted": The operation was aborted as the requestor is no longer alive.\n     * * * "installInProgress": An installation of the same extension is in progress.\n     * * * "notPermitted": The installation is not permitted.\n     * * * "invalidId": Invalid Chrome Web Store item ID.\n     * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.\n     * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.\n     * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.\n     * * * "iconError": Failed to retrieve the extension\'s icon from the Web Store, or the icon was invalid.\n     * * * "userCanceled": The user canceled the operation.\n     * * * "blacklisted": The extension is blacklisted.\n     * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.\n     * * * "requirementViolations": Unsatisfied requirements, such as webgl.\n     * * * "blockedByPolicy": The extension is blocked by management policies.\n     * * * "launchFeatureDisabled": The launch feature is not available.\n     * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.\n     * * * "launchInProgress": A launch of the same extension is in progress.\n     */\n    export function install(url: string, successCallback?: Function, failureCallback?: (error: string, errorCode?: string) => void): void;\n    /**\n     * @param successCallback Optional. This function is invoked when inline installation successfully completes (after the dialog is shown and the user agrees to add the item to Chrome). You may wish to use this to hide the user interface element that prompted the user to install the app or extension.\n     * @param failureCallback Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.\n     * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.\n     * Optional parameter errorCode: The error code from the stable set of possible errors.\n     * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.\n     * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.\n     * * * "aborted": The operation was aborted as the requestor is no longer alive.\n     * * * "installInProgress": An installation of the same extension is in progress.\n     * * * "notPermitted": The installation is not permitted.\n     * * * "invalidId": Invalid Chrome Web Store item ID.\n     * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.\n     * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.\n     * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.\n     * * * "iconError": Failed to retrieve the extension\'s icon from the Web Store, or the icon was invalid.\n     * * * "userCanceled": The user canceled the operation.\n     * * * "blacklisted": The extension is blacklisted.\n     * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.\n     * * * "requirementViolations": Unsatisfied requirements, such as webgl.\n     * * * "blockedByPolicy": The extension is blocked by management policies.\n     * * * "launchFeatureDisabled": The launch feature is not available.\n     * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.\n     * * * "launchInProgress": A launch of the same extension is in progress.\n     */\n    export function install(successCallback: Function, failureCallback?: (error: string, errorCode?: string) => void): void;\n    /**\n     * @param failureCallback Optional. This function is invoked when inline installation does not successfully complete. Possible reasons for this include the user canceling the dialog, the linked item not being found in the store, or the install being initiated from a non-verified site.\n     * Parameter error: The failure detail. You may wish to inspect or log this for debugging purposes, but you should not rely on specific strings being passed back.\n     * Optional parameter errorCode: The error code from the stable set of possible errors.\n     * * Enum of the possible install results, including error codes sent back in the event that an inline installation has failed.\n     * * * "otherError": An uncommon, unrecognized, or unexpected error. In some cases, the readable error string can provide more information.\n     * * * "aborted": The operation was aborted as the requestor is no longer alive.\n     * * * "installInProgress": An installation of the same extension is in progress.\n     * * * "notPermitted": The installation is not permitted.\n     * * * "invalidId": Invalid Chrome Web Store item ID.\n     * * * "webstoreRequestError": Failed to retrieve extension metadata from the Web Store.\n     * * * "invalidWebstoreResponse": The extension metadata retrieved from the Web Store was invalid.\n     * * * "invalidManifest": An error occurred while parsing the extension manifest retrieved from the Web Store.\n     * * * "iconError": Failed to retrieve the extension\'s icon from the Web Store, or the icon was invalid.\n     * * * "userCanceled": The user canceled the operation.\n     * * * "blacklisted": The extension is blacklisted.\n     * * * "missingDependencies": Unsatisfied dependencies, such as shared modules.\n     * * * "requirementViolations": Unsatisfied requirements, such as webgl.\n     * * * "blockedByPolicy": The extension is blocked by management policies.\n     * * * "launchFeatureDisabled": The launch feature is not available.\n     * * * "launchUnsupportedExtensionType": The launch feature is not supported for the extension type.\n     * * * "launchInProgress": A launch of the same extension is in progress.\n     */\n    export function install(failureCallback?: (error: string, errorCode?: string) => void): void;\n\n    export interface InstallationStageEvent extends chrome.events.Event<(stage: string) => void> { }\n\n    export interface DownloadProgressEvent extends chrome.events.Event<(percentDownloaded: number) => void> { }\n\n    /**\n     * Fired when an inline installation enters a new InstallStage. In order to receive notifications about this event, listeners must be registered before the inline installation begins.\n     * @since Chrome 35.\n     */\n    export var onInstallStageChanged: InstallationStageEvent;\n    /**\n     * Fired periodically with the download progress of an inline install. In order to receive notifications about this event, listeners must be registered before the inline installation begins.\n     * @since Chrome 35.\n     */\n    export var onDownloadProgress: DownloadProgressEvent;\n}\n\n////////////////////\n// Windows\n////////////////////\n/**\n * Use the chrome.windows API to interact with browser windows. You can use this API to create, modify, and rearrange windows in the browser.\n * Permissions: The chrome.windows API can be used without declaring any permission. However, the "tabs" permission is required in order to populate the url, title, and favIconUrl properties of Tab objects.\n * @since Chrome 5.\n */\ndeclare namespace chrome.windows {\n    export interface Window {\n        /** Array of tabs.Tab objects representing the current tabs in the window. */\n        tabs?: chrome.tabs.Tab[];\n        /** Optional. The offset of the window from the top edge of the screen in pixels. Under some circumstances a Window may not be assigned top property, for example when querying closed windows from the sessions API. */\n        top?: number;\n        /** Optional. The height of the window, including the frame, in pixels. Under some circumstances a Window may not be assigned height property, for example when querying closed windows from the sessions API. */\n        height?: number;\n        /** Optional. The width of the window, including the frame, in pixels. Under some circumstances a Window may not be assigned width property, for example when querying closed windows from the sessions API. */\n        width?: number;\n        /**\n         * The state of this browser window.\n         * One of: "normal", "minimized", "maximized", "fullscreen", or "docked"\n         * @since Chrome 17.\n         */\n        state: string;\n        /** Whether the window is currently the focused window. */\n        focused: boolean;\n        /**\n         * Whether the window is set to be always on top.\n         * @since Chrome 19.\n         */\n        alwaysOnTop: boolean;\n        /** Whether the window is incognito. */\n        incognito: boolean;\n        /**\n         * The type of browser window this is.\n         * One of: "normal", "popup", "panel", "app", or "devtools"\n         */\n        type: string;\n        /** Optional. The ID of the window. Window IDs are unique within a browser session. Under some circumstances a Window may not be assigned an ID, for example when querying windows using the sessions API, in which case a session ID may be present. */\n        id: number;\n        /** Optional. The offset of the window from the left edge of the screen in pixels. Under some circumstances a Window may not be assigned left property, for example when querying closed windows from the sessions API. */\n        left?: number;\n        /**\n         * The session ID used to uniquely identify a Window obtained from the sessions API.\n         * @since Chrome 31.\n         */\n        sessionId?: string;\n    }\n\n    export interface GetInfo {\n        /**\n         * Optional.\n         * If true, the windows.Window object will have a tabs property that contains a list of the tabs.Tab objects. The Tab objects only contain the url, title and favIconUrl properties if the extension\'s manifest file includes the "tabs" permission.\n         */\n        populate?: boolean;\n        /**\n         * If set, the windows.Window returned will be filtered based on its type. If unset the default filter is set to [\'app\', \'normal\', \'panel\', \'popup\'], with \'app\' and \'panel\' window types limited to the extension\'s own windows.\n         * Each one of: "normal", "popup", "panel", "app", or "devtools"\n         * @since Chrome 46. Warning: this is the current Beta channel.\n         */\n        windowTypes?: string[];\n    }\n\n    export interface CreateData {\n        /**\n         * Optional. The id of the tab for which you want to adopt to the new window.\n         * @since Chrome 10.\n         */\n        tabId?: number;\n        /**\n         * Optional.\n         * A URL or array of URLs to open as tabs in the window. Fully-qualified URLs must include a scheme (i.e. \'http://www.google.com\', not \'www.google.com\'). Relative URLs will be relative to the current page within the extension. Defaults to the New Tab Page.\n         */\n        url?: string | string[];\n        /**\n         * Optional.\n         * The number of pixels to position the new window from the top edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n         */\n        top?: number;\n        /**\n         * Optional.\n         * The height in pixels of the new window, including the frame. If not specified defaults to a natural height.\n         */\n        height?: number;\n        /**\n         * Optional.\n         * The width in pixels of the new window, including the frame. If not specified defaults to a natural width.\n         */\n        width?: number;\n        /**\n         * Optional. If true, opens an active window. If false, opens an inactive window.\n         * @since Chrome 12.\n         */\n        focused?: boolean;\n        /** Optional. Whether the new window should be an incognito window. */\n        incognito?: boolean;\n        /**\n         * Optional. Specifies what type of browser window to create. The \'panel\' and \'detached_panel\' types create a popup unless the \'--enable-panels\' flag is set.\n         * One of: "normal", "popup", "panel", or "detached_panel"\n         */\n        type?: string;\n        /**\n         * Optional.\n         * The number of pixels to position the new window from the left edge of the screen. If not specified, the new window is offset naturally from the last focused window. This value is ignored for panels.\n         */\n        left?: number;\n        /**\n         * Optional. The initial state of the window. The \'minimized\', \'maximized\' and \'fullscreen\' states cannot be combined with \'left\', \'top\', \'width\' or \'height\'.\n         * One of: "normal", "minimized", "maximized", "fullscreen", or "docked"\n         * @since Chrome 44.\n         */\n        state?: string;\n    }\n\n    export interface UpdateInfo {\n        /** Optional. The offset from the top edge of the screen to move the window to in pixels. This value is ignored for panels. */\n        top?: number;\n        /**\n         * Optional. If true, causes the window to be displayed in a manner that draws the user\'s attention to the window, without changing the focused window. The effect lasts until the user changes focus to the window. This option has no effect if the window already has focus. Set to false to cancel a previous draw attention request.\n         * @since Chrome 14.\n         */\n        drawAttention?: boolean;\n        /** Optional. The height to resize the window to in pixels. This value is ignored for panels. */\n        height?: number;\n        /** Optional. The width to resize the window to in pixels. This value is ignored for panels. */\n        width?: number;\n        /**\n         * Optional. The new state of the window. The \'minimized\', \'maximized\' and \'fullscreen\' states cannot be combined with \'left\', \'top\', \'width\' or \'height\'.\n         * One of: "normal", "minimized", "maximized", "fullscreen", or "docked"\n         * @since Chrome 17.\n         */\n        state?: string;\n        /**\n         * Optional. If true, brings the window to the front. If false, brings the next window in the z-order to the front.\n         * @since Chrome 8.\n         */\n        focused?: boolean;\n        /** Optional. The offset from the left edge of the screen to move the window to in pixels. This value is ignored for panels. */\n        left?: number;\n    }\n\n    export interface WindowEventFilter {\n        /**\n         * Conditions that the window\'s type being created must satisfy. By default it will satisfy [\'app\', \'normal\', \'panel\', \'popup\'], with \'app\' and \'panel\' window types limited to the extension\'s own windows.\n         * Each one of: "normal", "popup", "panel", "app", or "devtools"\n         */\n        windowTypes: string[];\n    }\n\n    export interface WindowIdEvent extends chrome.events.Event<(windowId: number, filters?: WindowEventFilter) => void> { }\n\n    export interface WindowReferenceEvent extends chrome.events.Event<(window: Window, filters?: WindowEventFilter) => void> { }\n\n    /**\n     * The windowId value that represents the current window.\n     * @since Chrome 18.\n     */\n    export var WINDOW_ID_CURRENT: number;\n    /**\n     * The windowId value that represents the absence of a chrome browser window.\n     * @since Chrome 6.\n     */\n    export var WINDOW_ID_NONE: number;\n\n    /** Gets details about a window. */\n    export function get(windowId: number, callback: (window: chrome.windows.Window) => void): void;\n    /**\n     * Gets details about a window.\n     * @since Chrome 18.\n     */\n    export function get(windowId: number, getInfo: GetInfo, callback: (window: chrome.windows.Window) => void): void;\n    /**\n     * Gets the current window.\n     */\n    export function getCurrent(callback: (window: chrome.windows.Window) => void): void;\n    /**\n     * Gets the current window.\n     * @since Chrome 18.\n     */\n    export function getCurrent(getInfo: GetInfo, callback: (window: chrome.windows.Window) => void): void;\n    /**\n     * Creates (opens) a new browser with any optional sizing, position or default URL provided.\n     * @param callback\n     * Optional parameter window: Contains details about the created window.\n     */\n    export function create(callback?: (window?: chrome.windows.Window) => void): void;\n    /**\n     * Creates (opens) a new browser with any optional sizing, position or default URL provided.\n     * @param callback\n     * Optional parameter window: Contains details about the created window.\n     */\n    export function create(createData: CreateData, callback?: (window?: chrome.windows.Window) => void): void;\n    /**\n     * Gets all windows.\n     */\n    export function getAll(callback: (windows: chrome.windows.Window[]) => void): void;\n    /**\n     * Gets all windows.\n     * @since Chrome 18.\n     */\n    export function getAll(getInfo: GetInfo, callback: (windows: chrome.windows.Window[]) => void): void;\n    /** Updates the properties of a window. Specify only the properties that you want to change; unspecified properties will be left unchanged. */\n    export function update(windowId: number, updateInfo: UpdateInfo, callback?: (window: chrome.windows.Window) => void): void;\n    /** Removes (closes) a window, and all the tabs inside it. */\n    export function remove(windowId: number, callback?: Function): void;\n    /**\n     * Gets the window that was most recently focused \u2014 typically the window \'on top\'.\n     */\n    export function getLastFocused(callback: (window: chrome.windows.Window) => void): void;\n    /**\n     * Gets the window that was most recently focused \u2014 typically the window \'on top\'.\n     * @since Chrome 18.\n     */\n    export function getLastFocused(getInfo: GetInfo, callback: (window: chrome.windows.Window) => void): void;\n\n    /** Fired when a window is removed (closed). */\n    export var onRemoved: WindowIdEvent;\n    /** Fired when a window is created. */\n    export var onCreated: WindowReferenceEvent;\n    /**\n     * Fired when the currently focused window changes. Will be chrome.windows.WINDOW_ID_NONE if all chrome windows have lost focus.\n     * Note: On some Linux window managers, WINDOW_ID_NONE will always be sent immediately preceding a switch from one chrome window to another.\n     */\n    export var onFocusChanged: WindowIdEvent;\n}\n'}}]);